var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NotifyType;
        (function (NotifyType) {
            NotifyType[NotifyType["AddChild"] = 0] = "AddChild";
            NotifyType[NotifyType["RemoveChild"] = 1] = "RemoveChild";
            NotifyType[NotifyType["ChangeVisible"] = 2] = "ChangeVisible";
            NotifyType[NotifyType["AddCamera"] = 3] = "AddCamera";
            NotifyType[NotifyType["AddCanvasRender"] = 4] = "AddCanvasRender";
        })(NotifyType = framework.NotifyType || (framework.NotifyType = {}));
        var CanvasFixedType;
        (function (CanvasFixedType) {
            CanvasFixedType[CanvasFixedType["Free"] = 0] = "Free";
            CanvasFixedType[CanvasFixedType["FixedWidthType"] = 1] = "FixedWidthType";
            CanvasFixedType[CanvasFixedType["FixedHeightType"] = 2] = "FixedHeightType";
        })(CanvasFixedType = framework.CanvasFixedType || (framework.CanvasFixedType = {}));
        var application = (function () {
            function application() {
                this.limitFrame = true;
                this.version = "v0.0.1";
                this.build = "b000077";
                this._tar = -1;
                this._standDeltaTime = -1;
                this.canvasFixedType = CanvasFixedType.Free;
                this._scaleFromPandding = 1;
                this.beStepNumber = 0;
                this.pretimer = 0;
                this.isFrustumCulling = true;
                this._userCode = [];
                this._userCodeNew = [];
                this._editorCode = [];
                this._editorCodeNew = [];
                this._bePlay = false;
                this.be2dstate = false;
                this.curcameraindex = -1;
                this._bePause = false;
                this._beStepForward = false;
                this.orientation = framework.OrientationMode.AUTO;
                this.shouldRotate = false;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.OffOrientationUpdate = false;
            }
            Object.defineProperty(application.prototype, "width", {
                get: function () {
                    return this.webgl.canvas.width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "height", {
                get: function () {
                    return this.webgl.canvas.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "timeScale", {
                get: function () {
                    return this._timeScale;
                },
                set: function (val) {
                    this._timeScale = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "targetFrame", {
                get: function () {
                    return this._tar;
                },
                set: function (val) {
                    if (val == 0)
                        val = -1;
                    this._tar = val;
                    this._standDeltaTime = 1 / this._tar;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasFixHeight", {
                set: function (val) {
                    this._fixHeight = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasFixWidth", {
                set: function (val) {
                    this._fixWidth = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasClientWidth", {
                get: function () {
                    return this._canvasClientWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasClientHeight", {
                get: function () {
                    return this._canvasClientHeight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "scaleFromPandding", {
                get: function () { return this._scaleFromPandding; },
                enumerable: true,
                configurable: true
            });
            application.prototype.start = function (div, type, val, webglDebug) {
                if (type === void 0) { type = CanvasFixedType.Free; }
                if (val === void 0) { val = 1200; }
                if (webglDebug === void 0) { webglDebug = false; }
                console.log("version: " + this.version + "  build: " + this.build);
                if (div == null) {
                    console.error("root div does Null at application start ");
                    return;
                }
                div.style.overflow = "hidden";
                div.style.position = "absolute";
                div.style.width = "100%";
                div.style.height = "100%";
                this.outcontainer = div;
                var rotateDiv = document.createElement("div");
                rotateDiv.className = "full";
                rotateDiv.style.overflow = "hidden";
                rotateDiv.style.position = "absolute";
                rotateDiv.style.width = "100%";
                rotateDiv.style.height = "100%";
                this.container = rotateDiv;
                div.appendChild(rotateDiv);
                var canvas = document.createElement("canvas");
                if (canvas == null) {
                    alert("Failed to create canvas at the application.start()");
                    throw Error("Failed to create canvas at the application.start()");
                }
                canvas.className = "full";
                canvas.style.position = "absolute";
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvas.style.backgroundColor = "#1e1e1e";
                canvas.setAttribute("tabindex", "1");
                rotateDiv.appendChild(canvas);
                this.startForCanvas(canvas, type, val, webglDebug);
            };
            application.prototype.startForCanvas = function (canvas, type, val, webglDebug) {
                if (type === void 0) { type = CanvasFixedType.Free; }
                if (val === void 0) { val = 1200; }
                if (webglDebug === void 0) { webglDebug = false; }
                this.ccWidth = this.ccWidth == undefined ? canvas.clientWidth : this.ccWidth;
                this.ccHeight = this.ccHeight == undefined ? canvas.clientHeight : this.ccHeight;
                this._timeScale = 1;
                framework.sceneMgr.app = this;
                var tempWebGlUtil = new framework.WebGLUtils();
                this.webgl = tempWebGlUtil.setupWebGL(canvas);
                if (this.webgl == null) {
                    alert("Failed to get webgl at the application.start()");
                    throw Error("Failed to get webgl at the application.start()");
                }
                switch (type) {
                    case CanvasFixedType.FixedWidthType:
                        this.canvasFixWidth = val;
                        break;
                    case CanvasFixedType.FixedHeightType:
                        this.canvasFixHeight = val;
                        break;
                }
                this.canvasFixedType = type;
                this.setScreenAsp();
                this._canvasClientWidth = this.ccWidth;
                this._canvasClientHeight = this.ccHeight;
                gd3d.render.webglkit.initConst(this.webgl);
                this.initRender();
                this.initAssetMgr();
                this.initInputMgr();
                this.initScene();
                this.beginTimer = this.lastTimer = this.pretimer = Date.now() / 1000;
                this.loop();
                gd3d.io.referenceInfo.regDefaultType();
                var initovercallback = window["initovercallback"];
                if (initovercallback != null) {
                    initovercallback(this);
                }
                if (webglDebug) {
                    var tempWebGLDebugUtils = new framework.WebGLDebugUtils();
                    this.webgl = tempWebGLDebugUtils.makeDebugContext(this.webgl);
                    console.error(" i am ---webglDebug-");
                }
            };
            application.prototype.markNotify = function (trans, type) {
            };
            application.prototype.doNotify = function (trans, type) {
                if (trans == null)
                    return;
                if (!this.checkFilter(trans))
                    return;
                if (this.notify)
                    this.notify.notify(trans, type);
                if (trans.children != null) {
                    for (var index in trans.children) {
                        this.doNotify(trans.children[index], type);
                    }
                }
            };
            application.prototype.checkFilter = function (trans) {
                if (trans instanceof gd3d.framework.transform) {
                    if (trans.gameObject.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                if (trans instanceof gd3d.framework.transform2D) {
                    if (trans.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                return true;
            };
            application.prototype.showFps = function () {
                if (!this.container)
                    return;
                if (this.stats == null) {
                    this.stats = new Stats.Stats(this);
                    this.stats.container.style.position = 'absolute';
                    this.stats.container.style.left = '0px';
                    this.stats.container.style.top = '0px';
                    this.container.appendChild(this.stats.container);
                }
                else {
                    this.container.appendChild(this.stats.container);
                }
            };
            application.prototype.closeFps = function () {
                if (this.stats != null) {
                    this.container.removeChild(this.stats.container);
                }
            };
            application.prototype.showDrawCall = function () {
                framework.DrawCallInfo.inc.showDrawcallInfo();
            };
            application.prototype.closeDrawCall = function () {
                framework.DrawCallInfo.inc.closeDrawCallInfo();
            };
            application.prototype.update = function (delta) {
                try {
                    {
                        this.updateOrientationMode();
                    }
                    this.updateScreenAsp();
                    if (this.bePlay) {
                        if (this.bePause) {
                            if (this.beStepForward && this.beStepNumber > 0) {
                                this.beStepNumber--;
                                this.updateUserCode(delta);
                            }
                        }
                        else {
                            if (this._inputmgr)
                                this._inputmgr.update(delta);
                            this.updateUserCode(delta);
                        }
                    }
                    this.updateEditorCode(delta);
                    if (this._scene != null) {
                        this._scene.update(delta);
                    }
                }
                catch (e) {
                    console.error(e);
                }
            };
            application.prototype.updateScreenAsp = function () {
                if (!this.outcontainer)
                    return;
                if (this.webgl && this.webgl.canvas) {
                    this.ccWidth = this.webgl.canvas.clientWidth != null ? this.webgl.canvas.clientWidth : this.ccWidth;
                    this.ccHeight = this.webgl.canvas.clientHeight != null ? this.webgl.canvas.clientHeight : this.ccHeight;
                }
                if (this.ccWidth != this._canvasClientWidth || this.ccHeight != this._canvasClientHeight) {
                    this._canvasClientWidth = this.ccWidth;
                    this._canvasClientHeight = this.ccHeight;
                    this.setScreenAsp();
                }
            };
            application.prototype.setScreenAsp = function () {
                if (!this.webgl || !this.webgl.canvas)
                    return;
                var canvas = this.webgl.canvas;
                var devicePixelRatio = window.devicePixelRatio || 1;
                var type = this.canvasFixedType;
                switch (type) {
                    case CanvasFixedType.Free:
                        this.screenAdaptiveType = "宽高度自适应(宽高都不固定,真实像素宽高)";
                        canvas.width = this.ccWidth * devicePixelRatio;
                        canvas.height = this.ccHeight * devicePixelRatio;
                        this._scaleFromPandding = 1;
                        break;
                    case CanvasFixedType.FixedWidthType:
                        this.screenAdaptiveType = "宽度自适应(宽度固定,一般横屏使用)";
                        canvas.width = this._fixWidth * devicePixelRatio;
                        canvas.height = canvas.width * this.ccHeight / this.ccWidth;
                        this._scaleFromPandding = this.ccHeight * devicePixelRatio / this.webgl.canvas.height;
                        break;
                    case CanvasFixedType.FixedHeightType:
                        this.screenAdaptiveType = "高度自适应(高度固定，一般竖屏使用)";
                        canvas.height = this._fixHeight * devicePixelRatio;
                        canvas.width = this.ccWidth * canvas.height / this.ccHeight;
                        this._scaleFromPandding = this.ccHeight * devicePixelRatio / this.webgl.canvas.height;
                        break;
                }
            };
            application.prototype.getUserUpdateTimer = function () {
                return this.usercodetime;
            };
            application.prototype.getTotalTime = function () {
                return this.totalTime;
            };
            Object.defineProperty(application.prototype, "deltaTime", {
                get: function () {
                    return this._deltaTime * this._timeScale;
                },
                enumerable: true,
                configurable: true
            });
            application.prototype.getUpdateTimer = function () {
                return this.updateTimer;
            };
            application.prototype.loop = function () {
                var now = Date.now() / 1000;
                this._deltaTime = now - this.lastTimer;
                this.totalTime = now - this.beginTimer;
                this.updateTimer = now - this.pretimer;
                if (this._deltaTime < this._standDeltaTime) {
                    var _this_1 = this;
                    var del = this._standDeltaTime - this._deltaTime;
                    setTimeout(function () {
                        var _now = Date.now() / 1000;
                        _this_1.lastTimer = _now;
                        _this_1.pretimer = _now;
                        _this_1.update(_this_1._standDeltaTime);
                        if (_this_1.stats != null)
                            _this_1.stats.update();
                        _this_1.loop();
                    }, del * 1000);
                }
                else {
                    this.update(this.deltaTime);
                    if (this.stats != null)
                        this.stats.update();
                    this.lastTimer = now;
                    this.pretimer = now;
                    if (this.limitFrame) {
                        requestAnimationFrame(this.loop.bind(this));
                    }
                    else {
                        setTimeout(this.loop.bind(this), 1);
                    }
                }
            };
            application.prototype.initScene = function () {
                if (this._scene == null) {
                    this._scene = new framework.scene(this);
                    framework.sceneMgr.scene = this._scene;
                }
            };
            application.prototype.initRender = function () {
                framework.uniformSetter.initAutouniform();
                gd3d.render.shaderUniform.webgl = this.webgl;
                gd3d.render.shaderUniform.initApplyUnifmFunc();
            };
            application.prototype.getScene = function () {
                return this._scene;
            };
            application.prototype.initAssetMgr = function () {
                if (this._assetmgr == null) {
                    this._assetmgr = new framework.assetMgr(this);
                    this._assetmgr.initDefAsset();
                }
            };
            application.prototype.getAssetMgr = function () {
                return this._assetmgr;
            };
            application.prototype.initInputMgr = function () {
                if (this._inputmgr == null) {
                    this._inputmgr = new framework.inputMgr(this);
                }
            };
            application.prototype.getInputMgr = function () {
                return this._inputmgr;
            };
            Object.defineProperty(application.prototype, "bePlay", {
                get: function () {
                    return this._bePlay;
                },
                set: function (value) {
                    this._bePlay = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "bePause", {
                get: function () {
                    return this._bePause;
                },
                set: function (value) {
                    this._bePause = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "beStepForward", {
                get: function () {
                    return this._beStepForward;
                },
                set: function (value) {
                    this._beStepForward = value;
                },
                enumerable: true,
                configurable: true
            });
            application.prototype.updateUserCode = function (delta) {
                for (var i = this._userCodeNew.length - 1; i >= 0; i--) {
                    var c = this._userCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._userCode.push(c);
                        this._userCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = 0; i < this._userCode.length; i++) {
                    var c = this._userCode[i];
                    if (c.isClosed() == false) {
                        c.onUpdate(delta);
                    }
                    else if (closeindex < 0) {
                        closeindex = i;
                    }
                }
                if (closeindex >= 0) {
                    this._userCode.splice(closeindex, 1);
                }
            };
            application.prototype.updateEditorCode = function (delta) {
                for (var i = this._editorCodeNew.length - 1; i >= 0; i--) {
                    var c = this._editorCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._editorCode.push(c);
                        this._editorCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = this._editorCode.length - 1; i >= 0; i--) {
                    var c = this._editorCode[i];
                    if (c.isClosed()) {
                        this._editorCode.splice(i, 1);
                    }
                    else {
                        c.onUpdate(delta);
                    }
                }
            };
            application.prototype.addUserCodeDirect = function (program) {
                this._userCodeNew.push(program);
            };
            application.prototype.addUserCode = function (classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "usercode": "1" });
                    this.addUserCodeDirect(code);
                }
            };
            application.prototype.addEditorCode = function (classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "editorcode": "1" });
                    this.addEditorCodeDirect(code);
                }
            };
            application.prototype.addEditorCodeDirect = function (program) {
                this._editorCodeNew.push(program);
            };
            application.prototype.updateOrientationMode = function () {
                if (this.OffOrientationUpdate || !this.outcontainer)
                    return;
                var screenRect = this.outcontainer.getBoundingClientRect();
                this.shouldRotate = false;
                if (this.orientation != framework.OrientationMode.AUTO) {
                    this.shouldRotate =
                        (this.orientation == framework.OrientationMode.LANDSCAPE || this.orientation == framework.OrientationMode.LANDSCAPE_FLIPPED) && screenRect.height > screenRect.width ||
                            this.orientation == framework.OrientationMode.PORTRAIT && screenRect.width > screenRect.height;
                }
                var screenWidth = this.shouldRotate ? screenRect.height : screenRect.width;
                var screenHeight = this.shouldRotate ? screenRect.width : screenRect.height;
                if (this.lastWidth == screenWidth && this.lastHeight == screenHeight)
                    return;
                this.lastWidth = screenWidth;
                this.lastHeight = screenHeight;
                if (this.container) {
                    this.container.style[getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                    this.container.style.width = screenWidth + "px";
                    this.container.style.height = screenHeight + "px";
                    var rotation = 0;
                    if (this.shouldRotate) {
                        if (this.orientation == framework.OrientationMode.LANDSCAPE) {
                            rotation = 90;
                            this.container.style.top = (screenRect.height - screenWidth) / 2 + "px";
                            this.container.style.left = (screenRect.width + screenHeight) / 2 + "px";
                        }
                        else {
                            rotation = -90;
                            this.container.style.top = (screenRect.height + screenWidth) / 2 + "px";
                            this.container.style.left = (screenRect.width - screenHeight) / 2 + "px";
                        }
                    }
                    else {
                        this.container.style.top = (screenRect.height - screenHeight) / 2 + "px";
                        this.container.style.left = (screenRect.width - screenWidth) / 2 + "px";
                    }
                    var transform_1 = "rotate(" + rotation + "deg)";
                    this.container.style[getPrefixStyleName("transform")] = transform_1;
                }
            };
            return application;
        }());
        framework.application = application;
        framework.OrientationMode = {
            AUTO: "auto",
            PORTRAIT: "portrait",
            LANDSCAPE: "landscape",
            LANDSCAPE_FLIPPED: "landscapeFlipped"
        };
        var currentPrefix = null;
        function getPrefixStyleName(name, element) {
            var header = "";
            if (element != null) {
                header = getPrefix(name, element);
            }
            else {
                if (currentPrefix == null) {
                    var tempStyle = document.createElement('div').style;
                    currentPrefix = getPrefix("transform", tempStyle);
                }
                header = currentPrefix;
            }
            if (header == "") {
                return name;
            }
            return header + name.charAt(0).toUpperCase() + name.substring(1, name.length);
        }
        framework.getPrefixStyleName = getPrefixStyleName;
        function getPrefix(name, element) {
            if (name in element) {
                return "";
            }
            name = name.charAt(0).toUpperCase() + name.substring(1, name.length);
            var transArr = ["webkit", "ms", "Moz", "O"];
            for (var i = 0; i < transArr.length; i++) {
                var tempStyle = transArr[i] + name;
                if (tempStyle in element) {
                    return transArr[i];
                }
            }
            return "";
        }
        framework.getPrefix = getPrefix;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var DeviceInfo = (function () {
            function DeviceInfo() {
            }
            DeviceInfo.getExtension = function () {
                this.debuginfo = framework.sceneMgr.app.webgl.getExtension('WEBGL_debug_renderer_info');
                if (this.debuginfo == null) {
                    console.warn("extension(WEBGL_debug_renderer_info) not support!");
                }
            };
            Object.defineProperty(DeviceInfo, "GraphDevice", {
                get: function () {
                    if (this.debuginfo == null) {
                        this.getExtension();
                    }
                    if (this.debuginfo) {
                        var device = framework.sceneMgr.app.webgl.getParameter(this.debuginfo.UNMASKED_RENDERER_WEBGL);
                        return device;
                    }
                    else {
                        return "unknown";
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "CanvasWidth", {
                get: function () {
                    if (framework.sceneMgr.app) {
                        return framework.sceneMgr.app.webgl.canvas.width;
                    }
                    else {
                        return null;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "CanvasHeight", {
                get: function () {
                    if (framework.sceneMgr.app) {
                        return framework.sceneMgr.app.webgl.canvas.height;
                    }
                    else {
                        return null;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "ScreenAdaptiveType", {
                get: function () {
                    if (framework.sceneMgr.app) {
                        return framework.sceneMgr.app.screenAdaptiveType;
                    }
                    else {
                        return "unknown";
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "ScreenWidth", {
                get: function () {
                    return window.screen.width * (window.devicePixelRatio || 1);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "ScreenHeight", {
                get: function () {
                    return window.screen.height * (window.devicePixelRatio || 1);
                },
                enumerable: true,
                configurable: true
            });
            return DeviceInfo;
        }());
        framework.DeviceInfo = DeviceInfo;
        var DrawCallEnum;
        (function (DrawCallEnum) {
            DrawCallEnum[DrawCallEnum["UI"] = 0] = "UI";
            DrawCallEnum[DrawCallEnum["SKinrender"] = 1] = "SKinrender";
            DrawCallEnum[DrawCallEnum["Meshrender"] = 2] = "Meshrender";
            DrawCallEnum[DrawCallEnum["EffectSystem"] = 3] = "EffectSystem";
        })(DrawCallEnum = framework.DrawCallEnum || (framework.DrawCallEnum = {}));
        var DrawCallInfo = (function () {
            function DrawCallInfo() {
                this.data = [];
                this.currentState = DrawCallEnum.Meshrender;
            }
            Object.defineProperty(DrawCallInfo, "inc", {
                get: function () {
                    if (this._inc == null) {
                        this._inc = new DrawCallInfo();
                    }
                    return this._inc;
                },
                enumerable: true,
                configurable: true
            });
            DrawCallInfo.prototype.reset = function () {
                this.data[DrawCallEnum.UI] = 0;
                this.data[DrawCallEnum.SKinrender] = 0;
                this.data[DrawCallEnum.Meshrender] = 0;
                this.data[DrawCallEnum.EffectSystem] = 0;
            };
            DrawCallInfo.prototype.add = function () {
                this.data[this.currentState] += 1;
            };
            DrawCallInfo.prototype.initShowPlane = function () {
                var div = document.createElement("div");
                this.rootdiv = div;
                framework.sceneMgr.app.container.appendChild(div);
                div.style.display = "inline-block";
                div.style.position = "absolute";
                div.style.left = "100px";
                div.style.top = "0px";
                div.style.height = "200px";
                div.style.width = "200px";
                var ul = document.createElement("ul");
                div.appendChild(ul);
                var li1 = document.createElement("li");
                li1.textContent = "SkinMeshDrawcall: ";
                li1.style.fontSize = "12px";
                li1.style.color = "Aqua";
                li1.style.height = "20px";
                li1.style.width = "200px";
                li1.style.left = "0px";
                ul.appendChild(li1);
                this.SKinrenderDraw = li1;
                var li3 = document.createElement("li");
                li3.textContent = "MeshrenderDrawcall: ";
                li3.style.fontSize = "12px";
                li3.style.color = "Aqua";
                li3.style.height = "20px";
                li3.style.width = "200px";
                li3.style.left = "0px";
                ul.appendChild(li3);
                this.MeshrenderDraw = li3;
                var li2 = document.createElement("li");
                li2.textContent = "EffectrenderDrawcall: ";
                li2.style.fontSize = "12px";
                li2.style.color = "Aqua";
                li2.style.height = "20px";
                li2.style.width = "200px";
                li2.style.left = "0px";
                ul.appendChild(li2);
                this.EffectrenderDraw = li2;
                var li4 = document.createElement("li");
                li4.textContent = "EffectrenderDrawcall: ";
                li4.style.fontSize = "12px";
                li4.style.color = "Aqua";
                li4.style.height = "20px";
                li4.style.width = "200px";
                li4.style.left = "0px";
                ul.appendChild(li4);
                this.UIrenderDraw = li4;
            };
            DrawCallInfo.prototype.showPerFrame = function () {
                this.MeshrenderDraw.textContent = "MeshrenderDrawcall: " + this.data[DrawCallEnum.Meshrender];
                this.SKinrenderDraw.textContent = "SkinMeshDrawcall: " + this.data[DrawCallEnum.SKinrender];
                this.EffectrenderDraw.textContent = "EffectrenderDrawcall: " + this.data[DrawCallEnum.EffectSystem];
                this.UIrenderDraw.textContent = "UIrenderDrawcall: " + this.data[DrawCallEnum.UI];
            };
            DrawCallInfo.prototype.showDrawcallInfo = function () {
                if (this.SKinrenderDraw == null) {
                    this.initShowPlane();
                }
                DrawCallInfo.BeActived = true;
                this.rootdiv.style.visibility = "visible";
            };
            DrawCallInfo.prototype.closeDrawCallInfo = function () {
                DrawCallInfo.BeActived = false;
                this.rootdiv.style.visibility = "hidden";
            };
            DrawCallInfo.BeActived = false;
            return DrawCallInfo;
        }());
        framework.DrawCallInfo = DrawCallInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var sceneMgr = (function () {
            function sceneMgr() {
            }
            Object.defineProperty(sceneMgr, "ins", {
                get: function () {
                    if (sceneMgr._ins == null)
                        sceneMgr._ins = new sceneMgr();
                    return sceneMgr._ins;
                },
                enumerable: true,
                configurable: true
            });
            return sceneMgr;
        }());
        framework.sceneMgr = sceneMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var Stats;
(function (Stats_1) {
    var Stats = (function () {
        function Stats(app) {
            var _this = this;
            this.mode = 0;
            this.app = app;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.frames = 0;
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.ratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            this.userratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            if (window && window.performance && window.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            this.beginTime = this.end();
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        Stats.prototype.begin = function () {
            this.beginTime = (performance || Date).now();
        };
        Stats.prototype.end = function () {
            this.frames++;
            var time = (performance || Date).now();
            this.msPanel.update(time - this.beginTime, 200);
            if (time > this.prevTime + 1000) {
                var fps = (this.frames * 1000) / (time - this.prevTime);
                this.fpsPanel.update(fps, 100);
                this.ratePanel.update(this.app.getUpdateTimer() * this.frames / 10, 100);
                this.userratePanel.update(this.app.getUserUpdateTimer() * this.frames / 10, 100);
                this.prevTime = time;
                this.frames = 0;
                if (this.memPanel) {
                    var memory = performance["memory"];
                    this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                }
            }
            return time;
        };
        return Stats;
    }());
    Stats_1.Stats = Stats;
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
})(Stats || (Stats = {}));
var gd3d;
(function (gd3d) {
    gd3d.gd3d_reflect_root = {};
    var reflect;
    (function (reflect) {
        function regType(constructorObj, customInfo) {
            var target = constructorObj.prototype;
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"]["class"] == undefined)
                target["__gdmeta__"]["class"] = {};
            var name = target["constructor"]["name"];
            if (name == null) {
                var fs = target["constructor"].toString();
                var i = fs.indexOf("(");
                name = fs.substring(9, i);
            }
            var classname = constructorObj["ClassName"];
            name = classname ? classname : name;
            target["__gdmeta__"]["class"]["typename"] = name;
            if (gd3d.gd3d_reflect_root["__gdmeta__"] == null)
                gd3d.gd3d_reflect_root["__gdmeta__"] = {};
            gd3d.gd3d_reflect_root["__gdmeta__"][name] = target;
            if (target["__gdmeta__"]["class"]["custom"] == null)
                target["__gdmeta__"]["class"]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"]["class"]["custom"][key] = customInfo[key];
                }
            }
        }
        function regFunc(target, funcname, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][funcname] == null)
                target["__gdmeta__"][funcname] = {};
            target["__gdmeta__"][funcname]["type"] = "function";
            var tp = Reflect.getMetadata("design:paramtypes", target, funcname);
            var tr = Reflect.getMetadata("design:returntype", target, funcname);
            target["__gdmeta__"][funcname]["paramtypes"] = [];
            for (var i in tp) {
                target["__gdmeta__"][funcname]["paramtypes"][i] = tp[i]["name"];
            }
            target["__gdmeta__"][funcname]["returntype"] = tr == null ? null : tr["name"];
            if (target["__gdmeta__"][funcname]["custom"] == null)
                target["__gdmeta__"][funcname]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][funcname]["custom"][key] = customInfo[key];
                }
            }
        }
        function regField(target, fieldName, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][fieldName] == null)
                target["__gdmeta__"][fieldName] = {};
            target["__gdmeta__"][fieldName]["type"] = "field";
            if (target["__gdmeta__"][fieldName]["custom"] == null)
                target["__gdmeta__"][fieldName]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][fieldName]["custom"][key] = customInfo[key];
                }
            }
        }
        function getPrototypes() {
            return gd3d.gd3d_reflect_root["__gdmeta__"];
        }
        reflect.getPrototypes = getPrototypes;
        function getPrototype(name) {
            return gd3d.gd3d_reflect_root["__gdmeta__"][name];
        }
        reflect.getPrototype = getPrototype;
        function createInstance(prototype, matchTag) {
            if (matchTag == null) {
                var ctor = prototype.constructor;
                return new ctor();
            }
            else {
                var info = prototype["__gdmeta__"]["class"]["custom"];
                for (var key in matchTag) {
                    if (info[key] != matchTag[key]) {
                        console.warn("createInstance:" + name + ". tag do not match.");
                        return null;
                    }
                }
                var ctor = prototype.constructor;
                return new ctor();
            }
        }
        reflect.createInstance = createInstance;
        function getClassName(prototype) {
            var info = prototype["__gdmeta__"]["class"]["typename"];
            return info;
        }
        reflect.getClassName = getClassName;
        function getClassTag(prototype, tag) {
            var info = prototype["__gdmeta__"]["class"]["custom"];
            return info[tag];
        }
        reflect.getClassTag = getClassTag;
        function getMeta(prototype) {
            var meta = prototype.__gdmeta__;
            return meta;
        }
        reflect.getMeta = getMeta;
        function attr_Class(constructorObj) {
            regType(constructorObj, null);
        }
        reflect.attr_Class = attr_Class;
        function attr_Func(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Func = attr_Func;
        function attr_Field(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey) {
                regField(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Field = attr_Field;
        function userCode(constructorObj) {
            regType(constructorObj, { "usercode": "1" });
        }
        reflect.userCode = userCode;
        function editorCode(constructorObj) {
            regType(constructorObj, { "editorcode": "1" });
        }
        reflect.editorCode = editorCode;
        function selfClone(constructorObj) {
            regType(constructorObj, { "selfclone": "1" });
        }
        reflect.selfClone = selfClone;
        function nodeComponent(constructorObj) {
            regType(constructorObj, { "nodecomp": "1" });
        }
        reflect.nodeComponent = nodeComponent;
        function nodeComponentInspector(constructorObj) {
            regType(constructorObj, { "nodecomp_inspector": "1" });
        }
        reflect.nodeComponentInspector = nodeComponentInspector;
        function nodeRender(constructorObj) {
            regType(constructorObj, { "renderer": "1" });
        }
        reflect.nodeRender = nodeRender;
        function nodeCamera(constructorObj) {
            regType(constructorObj, { "camera": "1" });
        }
        reflect.nodeCamera = nodeCamera;
        function nodeLight(constructorObj) {
            regType(constructorObj, { "light": "1" });
        }
        reflect.nodeLight = nodeLight;
        function nodeBoxCollider(constructorObj) {
            regType(constructorObj, { "boxcollider": "1" });
        }
        reflect.nodeBoxCollider = nodeBoxCollider;
        function nodeBoxCollider2d(constructorObj) {
            regType(constructorObj, { "boxcollider2d": "1" });
        }
        reflect.nodeBoxCollider2d = nodeBoxCollider2d;
        function nodeSphereCollider(constructorObj) {
            regType(constructorObj, { "spherecollider": "1" });
        }
        reflect.nodeSphereCollider = nodeSphereCollider;
        function nodeEffectBatcher(constructorObj) {
            regType(constructorObj, { "effectbatcher": "1" });
        }
        reflect.nodeEffectBatcher = nodeEffectBatcher;
        function nodeMeshCollider(constructorObj) {
            regType(constructorObj, { "meshcollider": "1" });
        }
        reflect.nodeMeshCollider = nodeMeshCollider;
        function nodeCanvasRendererCollider(constructorObj) {
            regType(constructorObj, { "canvasRenderer": "1" });
        }
        reflect.nodeCanvasRendererCollider = nodeCanvasRendererCollider;
        function node2DComponent(constructorObj) {
            regType(constructorObj, { "2dcomp": "1" });
        }
        reflect.node2DComponent = node2DComponent;
        function pluginMenuItem(constructorObj) {
            regType(constructorObj, { "plugin_menuitem": "1" });
        }
        reflect.pluginMenuItem = pluginMenuItem;
        function pluginWindow(constructorObj) {
            regType(constructorObj, { "plugin_window": "1" });
        }
        reflect.pluginWindow = pluginWindow;
        function pluginExt(constructorObj) {
            regType(constructorObj, { "plugin_ext": "1" });
        }
        reflect.pluginExt = pluginExt;
        function compValue(integer, defvalue, min, max) {
            if (integer === void 0) { integer = false; }
            if (defvalue === void 0) { defvalue = 0; }
            if (min === void 0) { min = Number.MIN_VALUE; }
            if (max === void 0) { max = Number.MAX_VALUE; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "compValue": "1",
                    "integer": integer ? "1" : "0",
                    "defvalue": defvalue.toString(),
                    "min": min.toString(),
                    "max": max.toString(),
                });
            };
        }
        reflect.compValue = compValue;
        function compCall(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, { "compcall": "1" });
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.compCall = compCall;
        function SerializeType(constructorObj) {
            regType(constructorObj, { "SerializeType": "1" });
        }
        reflect.SerializeType = SerializeType;
        function Field(valueType, defaultValue, referenceType) {
            if (defaultValue === void 0) { defaultValue = undefined; }
            if (referenceType === void 0) { referenceType = undefined; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "SerializeField": true,
                    "valueType": valueType
                });
                if (defaultValue == undefined) {
                }
                else {
                    regField(target, propertyKey, {
                        "defaultValue": defaultValue
                    });
                }
                if (valueType == "reference" && referenceType != undefined) {
                    regField(target, propertyKey, {
                        "referenceType": referenceType
                    });
                }
            };
        }
        reflect.Field = Field;
        function UIComment(comment) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "UIComment": comment
                });
            };
        }
        reflect.UIComment = UIComment;
        var FieldUIStyle;
        (function (FieldUIStyle) {
            FieldUIStyle[FieldUIStyle["None"] = 0] = "None";
            FieldUIStyle[FieldUIStyle["RangeFloat"] = 1] = "RangeFloat";
            FieldUIStyle[FieldUIStyle["MultiLineString"] = 2] = "MultiLineString";
            FieldUIStyle[FieldUIStyle["Enum"] = 3] = "Enum";
        })(FieldUIStyle = reflect.FieldUIStyle || (reflect.FieldUIStyle = {}));
        function UIStyle(style, min, max, defvalue) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "FieldUIStyle": style,
                    "min": min ? min : null,
                    "max": max ? max : null,
                    "defvalue": defvalue ? defvalue : null
                });
            };
        }
        reflect.UIStyle = UIStyle;
    })(reflect = gd3d.reflect || (gd3d.reflect = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        var _ubyte = new Uint8Array(1);
        var _byte = new Int8Array(1);
        var _int16 = new Int16Array(1);
        var _int32 = new Int32Array(1);
        var _uint16 = new Uint16Array(1);
        var _uint32 = new Uint32Array(1);
        var _float32 = new Float32Array(1);
        var _float64 = new Float64Array(1);
        function UByte(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _ubyte[0] = v;
            return _ubyte[0];
        }
        math.UByte = UByte;
        function Byte(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _byte[0] = v;
            return _byte[0];
        }
        math.Byte = Byte;
        function Int16(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _int16[0] = v;
            return _int16[0];
        }
        math.Int16 = Int16;
        function Int32(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _int32[0] = v;
            return _int32[0];
        }
        math.Int32 = Int32;
        function UInt16(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _uint16[0] = v;
            return _uint16[0];
        }
        math.UInt16 = UInt16;
        function UInt32(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _uint32[0] = v;
            return _uint32[0];
        }
        math.UInt32 = UInt32;
        function Float(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _float32[0] = v;
            return _float32[0];
        }
        math.Float = Float;
        function Double(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _float64[0] = v;
            return _float64[0];
        }
        math.Double = Double;
        var vector2 = (function () {
            function vector2(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.rawData = new Float32Array(2);
                this.rawData[0] = x;
                this.rawData[1] = y;
            }
            Object.defineProperty(vector2.prototype, "x", {
                get: function () {
                    return this.rawData[0];
                },
                set: function (x) {
                    this.rawData[0] = x;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(vector2.prototype, "y", {
                get: function () {
                    return this.rawData[1];
                },
                set: function (y) {
                    this.rawData[1] = y;
                },
                enumerable: true,
                configurable: true
            });
            ;
            vector2.prototype.toString = function () {
                return this.x + "," + this.y;
            };
            vector2.ClassName = "vector2";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector2.prototype, "x", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector2.prototype, "y", null);
            vector2 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number])
            ], vector2);
            return vector2;
        }());
        math.vector2 = vector2;
        var rect = (function () {
            function rect(x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                this.rawData = new Float32Array(4);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = w;
                this.rawData[3] = h;
            }
            Object.defineProperty(rect.prototype, "x", {
                get: function () {
                    return this.rawData[0];
                },
                set: function (x) {
                    this.rawData[0] = x;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(rect.prototype, "y", {
                get: function () {
                    return this.rawData[1];
                },
                set: function (y) {
                    this.rawData[1] = y;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(rect.prototype, "w", {
                get: function () {
                    return this.rawData[2];
                },
                set: function (w) {
                    this.rawData[2] = w;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(rect.prototype, "h", {
                get: function () {
                    return this.rawData[3];
                },
                set: function (h) {
                    this.rawData[3] = h;
                },
                enumerable: true,
                configurable: true
            });
            ;
            rect.prototype.toString = function () {
                return this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3];
            };
            rect.ClassName = "rect";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], rect.prototype, "x", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], rect.prototype, "y", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], rect.prototype, "w", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], rect.prototype, "h", null);
            rect = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], rect);
            return rect;
        }());
        math.rect = rect;
        var border = (function () {
            function border(l, t, r, b) {
                if (l === void 0) { l = 0; }
                if (t === void 0) { t = 0; }
                if (r === void 0) { r = 0; }
                if (b === void 0) { b = 0; }
                this.rawData = new Float32Array(4);
                this.rawData[0] = l;
                this.rawData[1] = t;
                this.rawData[2] = r;
                this.rawData[3] = b;
            }
            Object.defineProperty(border.prototype, "l", {
                get: function () {
                    return this.rawData[0];
                },
                set: function (l) {
                    this.rawData[0] = l;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(border.prototype, "t", {
                get: function () {
                    return this.rawData[1];
                },
                set: function (t) {
                    this.rawData[1] = t;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(border.prototype, "r", {
                get: function () {
                    return this.rawData[2];
                },
                set: function (r) {
                    this.rawData[2] = r;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(border.prototype, "b", {
                get: function () {
                    return this.rawData[3];
                },
                set: function (b) {
                    this.rawData[3] = b;
                },
                enumerable: true,
                configurable: true
            });
            ;
            border.prototype.toString = function () {
                return this.r + "," + this.t + "," + this.r + "," + this.b;
            };
            border.ClassName = "border";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], border.prototype, "l", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], border.prototype, "t", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], border.prototype, "r", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], border.prototype, "b", null);
            border = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], border);
            return border;
        }());
        math.border = border;
        var color = (function () {
            function color(r, g, b, a) {
                if (r === void 0) { r = 1; }
                if (g === void 0) { g = 1; }
                if (b === void 0) { b = 1; }
                if (a === void 0) { a = 1; }
                this.rawData = new Float32Array(4);
                this.rawData[0] = r;
                this.rawData[1] = g;
                this.rawData[2] = b;
                this.rawData[3] = a;
            }
            Object.defineProperty(color.prototype, "r", {
                get: function () {
                    return this.rawData[0];
                },
                set: function (r) {
                    this.rawData[0] = r;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(color.prototype, "g", {
                get: function () {
                    return this.rawData[1];
                },
                set: function (g) {
                    this.rawData[1] = g;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(color.prototype, "b", {
                get: function () {
                    return this.rawData[2];
                },
                set: function (b) {
                    this.rawData[2] = b;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(color.prototype, "a", {
                get: function () {
                    return this.rawData[3];
                },
                set: function (a) {
                    this.rawData[3] = a;
                },
                enumerable: true,
                configurable: true
            });
            ;
            color.prototype.toString = function () {
                return this.r + "," + this.g + "," + this.b + "," + this.a;
            };
            color.ClassName = "color";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], color.prototype, "r", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], color.prototype, "g", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], color.prototype, "b", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], color.prototype, "a", null);
            color = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], color);
            return color;
        }());
        math.color = color;
        var vector3 = (function () {
            function vector3(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.rawData = new Float32Array(3);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = z;
            }
            Object.defineProperty(vector3.prototype, "x", {
                get: function () {
                    return this.rawData[0];
                },
                set: function (x) {
                    this.rawData[0] = x;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(vector3.prototype, "y", {
                get: function () {
                    return this.rawData[1];
                },
                set: function (y) {
                    this.rawData[1] = y;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(vector3.prototype, "z", {
                get: function () {
                    return this.rawData[2];
                },
                set: function (z) {
                    this.rawData[2] = z;
                },
                enumerable: true,
                configurable: true
            });
            ;
            vector3.prototype.toString = function () {
                return this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2];
            };
            vector3.ClassName = "vector3";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector3.prototype, "x", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector3.prototype, "y", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector3.prototype, "z", null);
            vector3 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number])
            ], vector3);
            return vector3;
        }());
        math.vector3 = vector3;
        var vector4 = (function () {
            function vector4(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 0; }
                this.rawData = new Float32Array(4);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = z;
                this.rawData[3] = w;
            }
            Object.defineProperty(vector4.prototype, "x", {
                get: function () {
                    return this.rawData[0];
                },
                set: function (x) {
                    this.rawData[0] = x;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(vector4.prototype, "y", {
                get: function () {
                    return this.rawData[1];
                },
                set: function (y) {
                    this.rawData[1] = y;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(vector4.prototype, "z", {
                get: function () {
                    return this.rawData[2];
                },
                set: function (z) {
                    this.rawData[2] = z;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(vector4.prototype, "w", {
                get: function () {
                    return this.rawData[3];
                },
                set: function (w) {
                    this.rawData[3] = w;
                },
                enumerable: true,
                configurable: true
            });
            ;
            vector4.prototype.toString = function () {
                return this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3];
            };
            vector4.ClassName = "vector4";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector4.prototype, "x", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector4.prototype, "y", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector4.prototype, "z", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], vector4.prototype, "w", null);
            vector4 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], vector4);
            return vector4;
        }());
        math.vector4 = vector4;
        var quaternion = (function () {
            function quaternion(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 1; }
                this.rawData = new Float32Array(4);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = z;
                this.rawData[3] = w;
            }
            Object.defineProperty(quaternion.prototype, "x", {
                get: function () {
                    return this.rawData[0];
                },
                set: function (x) {
                    this.rawData[0] = x;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(quaternion.prototype, "y", {
                get: function () {
                    return this.rawData[1];
                },
                set: function (y) {
                    this.rawData[1] = y;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(quaternion.prototype, "z", {
                get: function () {
                    return this.rawData[2];
                },
                set: function (z) {
                    this.rawData[2] = z;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(quaternion.prototype, "w", {
                get: function () {
                    return this.rawData[3];
                },
                set: function (w) {
                    this.rawData[3] = w;
                },
                enumerable: true,
                configurable: true
            });
            ;
            quaternion.prototype.toString = function () {
                return this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3];
            };
            quaternion.ClassName = "quaternion";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], quaternion.prototype, "x", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], quaternion.prototype, "y", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], quaternion.prototype, "z", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], quaternion.prototype, "w", null);
            quaternion = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], quaternion);
            return quaternion;
        }());
        math.quaternion = quaternion;
        var matrix = (function () {
            function matrix(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }
            matrix.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3] + "],"
                    + "[" + this.rawData[4] + "," + this.rawData[5] + "," + this.rawData[6] + "," + this.rawData[7] + "],"
                    + "[" + this.rawData[8] + "," + this.rawData[9] + "," + this.rawData[10] + "," + this.rawData[11] + "],"
                    + "[" + this.rawData[12] + "," + this.rawData[13] + "," + this.rawData[14] + "," + this.rawData[15] + "]";
            };
            matrix.ClassName = "matrix";
            return matrix;
        }());
        math.matrix = matrix;
        var matrix3x2 = (function () {
            function matrix3x2(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 1, 0, 0]);
            }
            matrix3x2.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "],"
                    + "[" + this.rawData[3] + "," + this.rawData[4] + "," + this.rawData[5] + "]";
            };
            return matrix3x2;
        }());
        math.matrix3x2 = matrix3x2;
        function vec4FormJson(json, vec4) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec4.x = Number(arr[0]);
            vec4.y = Number(arr[1]);
            vec4.z = Number(arr[2]);
            vec4.w = Number(arr[3]);
        }
        math.vec4FormJson = vec4FormJson;
        function vec3FormJson(json, vec3) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec3.x = Number(arr[0]);
            vec3.y = Number(arr[1]);
            vec3.z = Number(arr[2]);
        }
        math.vec3FormJson = vec3FormJson;
        function vec2FormJson(json, vec2) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec2.x = Number(arr[0]);
            vec2.y = Number(arr[1]);
        }
        math.vec2FormJson = vec2FormJson;
        function colorFormJson(json, _color) {
            json = json.replace("RGBA(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            _color.r = Number(arr[0]);
            _color.g = Number(arr[1]);
            _color.b = Number(arr[2]);
            _color.a = Number(arr[3]);
        }
        math.colorFormJson = colorFormJson;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var helpv2 = new gd3d.math.vector2();
        var batcher2D = (function () {
            function batcher2D() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            batcher2D.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new gd3d.render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == gd3d.render.DrawModeEnum.EboLine || drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            batcher2D.prototype.begin = function (webgl, pass) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curPass = pass;
                this.vboCount = 0;
            };
            batcher2D.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > batcher2D.limitCount
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > batcher2D.limitCount)) {
                    this.end(webgl);
                    this.dataForVbo;
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == gd3d.render.DrawModeEnum.VboLine || this.drawMode == gd3d.render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            batcher2D.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexData(webgl, this.dataForVbo);
                if (this.eboCount > 0) {
                    this.mesh.uploadIndexData(webgl, 0, this.dataForEbo);
                }
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curPass.use(webgl);
                this.mesh.bind(webgl, this.curPass.program, (this.drawMode == gd3d.render.DrawModeEnum.EboLine || this.drawMode == gd3d.render.DrawModeEnum.EboTri) ? 0 : -1);
                framework.DrawCallInfo.inc.add();
                if (this.drawMode == gd3d.render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            batcher2D.limitCount = 2048 * 64;
            return batcher2D;
        }());
        framework.batcher2D = batcher2D;
        var canvas = (function () {
            function canvas() {
                this.is2dUI = true;
                this.isDrawByDepth = false;
                this.pointDown = false;
                this.pointEvent = new framework.PointEvent();
                this.pointX = 0;
                this.pointY = 0;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.lastMaskSta = -1;
                this.rendererDic = {};
                this.depthList = [];
                this.sortedList = [];
                this.canvasBounds = new gd3d.math.rect();
                this.qt_maxObjNum = 5;
                this.qt_maxlevel = 6;
                this.helpMap = {};
                this.pixelWidth = 640;
                this.pixelHeight = 480;
                this.rootNode = new framework.transform2D();
                this.rootNode.canvas = this;
            }
            canvas_1 = canvas;
            canvas.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            canvas.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            canvas.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            canvas.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            canvas.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            canvas.prototype.update = function (delta, touch, XOnModelSpace, YOnModelSpace) {
                var asp = this.pixelWidth / this.pixelHeight;
                this.rootNode.localScale.x = 2 / this.pixelWidth;
                this.rootNode.localScale.y = -2 / this.pixelHeight;
                this.rootNode.localTranslate.y = 1;
                this.rootNode.localTranslate.x = -1;
                if (this.pixelWidth != this.lastWidth || this.pixelHeight != this.lastHeight) {
                    this.lastWidth = this.rootNode.width = this.pixelWidth;
                    this.lastHeight = this.rootNode.height = this.pixelHeight;
                    this.rootNode.markDirty();
                }
                this.rootNode.pivot.x = 0;
                this.rootNode.pivot.y = 0;
                {
                    this.pointEvent.eated = false;
                    helpv2.x = this.pointEvent.x = XOnModelSpace;
                    helpv2.y = this.pointEvent.y = YOnModelSpace;
                    this.pointEvent.selected = null;
                    this.ModelPosToCanvasPos(helpv2, helpv2);
                    this.pointEvent.c_x = helpv2.x;
                    this.pointEvent.c_y = helpv2.y;
                    var skip = false;
                    if (this.pointDown == false && touch == false) {
                        skip = true;
                    }
                    else if (this.pointDown == false && touch == true) {
                        this.pointEvent.type = gd3d.event.PointEventEnum.PointDown;
                    }
                    else if (this.pointDown == true && touch == true) {
                        this.pointEvent.type = gd3d.event.PointEventEnum.PointHold;
                    }
                    else if (this.pointDown == true && touch == false) {
                        this.pointEvent.type = gd3d.event.PointEventEnum.PointUp;
                    }
                    if (!skip) {
                        if (this.scene.app.bePlay) {
                            this.rootNode.onCapturePointEvent(this, this.pointEvent);
                            this.rootNode.onPointEvent(this, this.pointEvent);
                        }
                        this.pointDown = touch;
                        this.pointX = this.pointEvent.x;
                        this.pointY = this.pointEvent.y;
                    }
                }
                this.rootNode.updateTran(false);
                if (this.scene.app.bePlay) {
                    this.objupdate(this.rootNode, delta);
                }
            };
            canvas.prototype.objupdate = function (node, delta) {
                if (!node.visible)
                    return;
                node.init(this.scene.app.bePlay);
                if (node.components.length > 0) {
                    node.update(delta);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.objupdate(node.children[i], delta);
                    }
                }
            };
            canvas.prototype.render = function (context, assetmgr) {
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.UI;
                this.context = context;
                this.assetmgr = assetmgr;
                this.lastMat = null;
                if (this.batcher == null) {
                    this.webgl = context.webgl;
                    this.batcher = new batcher2D();
                    var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0 | gd3d.render.VertexFormatMask.ColorEX;
                    this.batcher.initBuffer(context.webgl, vf, gd3d.render.DrawModeEnum.VboTri);
                }
                if (this.beforeRender != null)
                    this.beforeRender();
                if (!this.isDrawByDepth) {
                    this.drawScene(this.rootNode, context, assetmgr);
                }
                else {
                    this.drawSceneByDepth(this.rootNode, context, assetmgr);
                }
                this.batcher.end(context.webgl);
                if (this.afterRender != null)
                    this.afterRender();
            };
            canvas.prototype.pushRawData = function (mat, data) {
                if (mat != this.lastMat) {
                    this.lastMat = mat;
                    this.batcher.end(this.webgl);
                    var pass = this.lastMat.getShader().passes["base"][0];
                    pass.use(this.webgl);
                    mat.uploadUnifoms(pass, this.context);
                    this.batcher.begin(this.webgl, pass);
                }
                else {
                    var msta = mat.statedMapUniforms["MaskState"];
                    var mr = mat.statedMapUniforms["_maskRect"];
                    if (msta != null && msta.value != null && mr != null && mr.value != null) {
                        var rect = mr.value;
                        if (this.lastMaskV4 == null)
                            this.lastMaskV4 = new gd3d.math.vector4();
                        if (msta.value != this.lastMaskSta || this.lastMaskV4.x != rect.x || this.lastMaskV4.y != rect.y || this.lastMaskV4.z != rect.z || this.lastMaskV4.w != rect.w) {
                            this.lastMaskSta = msta.value;
                            gd3d.math.vec4Clone(rect, this.lastMaskV4);
                            this.batcher.end(this.webgl);
                            var pass = this.lastMat.getShader().passes["base"][0];
                            mat.uploadUnifoms(pass, this.context);
                        }
                    }
                }
                this.batcher.push(this.webgl, data, null);
            };
            canvas.prototype.drawScene = function (node, context, assetmgr) {
                if (!node.visible)
                    return;
                if (node.renderer != null) {
                    node.renderer.render(this);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.drawScene(node.children[i], context, assetmgr);
                    }
                }
            };
            canvas.prototype.drawSceneByDepth = function (node, context, assetmgr) {
                var _this = this;
                this.canvasBounds.w = this.pixelWidth;
                this.canvasBounds.h = this.pixelHeight;
                if (!this.depthQTree)
                    this.depthQTree = new framework.quadTree(this.canvasBounds, this.qt_maxObjNum, this.qt_maxlevel);
                this.depthQTree.clear();
                this.flowCount = 0;
                this.collectToDepthL(node);
                this.sortDepthList();
                this.sortedList.forEach(function (rnode) {
                    if (rnode)
                        rnode.render(_this);
                });
                this.depthList.length = this.sortedList.length = 0;
            };
            canvas.prototype.sortDepthList = function () {
                var _this = this;
                var len = this.depthList.length;
                var lastGuid = -1;
                var idList = [];
                var _loop_1 = function (i) {
                    idList.length = 0;
                    var arr = this_1.depthList[i];
                    var tempM = {};
                    arr.forEach(function (rn, idx) {
                        if (rn && rn.getMaterial()) {
                            var guid = rn.getMaterial().getGUID();
                            if (!_this.helpMap[guid])
                                _this.helpMap[guid] = [];
                            _this.helpMap[guid].push(rn);
                            if (!tempM[guid]) {
                                idList.push(guid);
                                tempM[guid] = true;
                            }
                        }
                    });
                    if (lastGuid != -1 && this_1.helpMap[lastGuid] && this_1.helpMap[lastGuid].length > 0) {
                        var sidx = idList.indexOf(lastGuid);
                        if (sidx != -1)
                            idList.splice(sidx, 1);
                        idList.unshift(lastGuid);
                    }
                    var tempLastLen = 0;
                    var endGuid = -1;
                    for (var key in this_1.helpMap) {
                        var temparr = this_1.helpMap[key];
                        if (temparr && temparr.length > tempLastLen) {
                            endGuid = Number(key);
                            tempLastLen = temparr.length;
                        }
                    }
                    if (lastGuid != endGuid && endGuid != -1 && !isNaN(endGuid)) {
                        var sidx = idList.indexOf(endGuid);
                        if (sidx != -1)
                            idList.splice(sidx, 1);
                        idList.push(endGuid);
                    }
                    idList.forEach(function (id) {
                        var rArr = _this.helpMap[id];
                        if (rArr && rArr.length > 0) {
                            rArr.forEach(function (rn) {
                                if (rn)
                                    _this.sortedList.push(rn);
                            });
                        }
                    });
                    if (idList.length > 0) {
                        lastGuid = idList[idList.length - 1];
                    }
                    for (var key in this_1.helpMap) {
                        var temparr = this_1.helpMap[key];
                        if (temparr)
                            temparr.length = 0;
                    }
                };
                var this_1 = this;
                for (var i = 0; i < len; i++) {
                    _loop_1(i);
                }
                this.helpMap = {};
            };
            canvas.prototype.collectToDepthL = function (node) {
                if (!node.visible)
                    return;
                if (node.renderer) {
                    var bounds = node.renderer.getDrawBounds();
                    bounds[canvas_1.flowIndexTag] = this.flowCount;
                    this.rendererDic[this.flowCount] = node.renderer;
                    this.checkBottomUI(node.renderer);
                    this.flowCount++;
                }
                if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.collectToDepthL(node.children[i]);
                    }
                }
            };
            canvas.prototype.checkBottomUI = function (rd) {
                var tempCup = [];
                var myr = rd.getDrawBounds();
                this.depthQTree.retrieve(myr, tempCup);
                var lastIdx = -1;
                while (tempCup.length > 0) {
                    var temp = tempCup.pop();
                    if (gd3d.math.rectCollided(temp, myr)) {
                        if (temp[canvas_1.flowIndexTag] > lastIdx) {
                            lastIdx = temp[canvas_1.flowIndexTag];
                            if (temp[canvas_1.flowIndexTag] == (myr[canvas_1.flowIndexTag] - 1))
                                break;
                        }
                    }
                }
                var depth = 0;
                if (lastIdx != -1) {
                    var wrd = this.rendererDic[lastIdx];
                    depth = wrd[canvas_1.depthTag] + 1;
                }
                rd[canvas_1.depthTag] = depth;
                this.depthQTree.insert(myr);
                if (!this.depthList[depth])
                    this.depthList[depth] = [];
                this.depthList[depth].push(rd);
            };
            canvas.prototype.getRoot = function () {
                if (this.rootNode == null) {
                    this.rootNode = new framework.transform2D();
                    this.rootNode.canvas = this;
                    this.scene.app.markNotify(this.rootNode, framework.NotifyType.AddChild);
                }
                return this.rootNode;
            };
            canvas.prototype.ModelPosToCanvasPos = function (fromP, outP) {
                if (fromP == null || outP == null)
                    return;
                var scalx = 1 - (fromP.x - 1) / -2;
                var scaly = (fromP.y - 1) / -2;
                outP.x = scalx * this.pixelWidth;
                outP.y = scaly * this.pixelHeight;
            };
            canvas.prototype.CanvasPosToModelPos = function (canvasPos, outModelPos) {
                if (!canvasPos || !outModelPos)
                    return;
                var scalx = canvasPos.x / this.pixelWidth;
                var scaly = canvasPos.y / this.pixelHeight;
                outModelPos.x = scalx * 2 - 1;
                outModelPos.y = 1 - scaly * 2;
            };
            var canvas_1;
            canvas.ClassName = "canvas";
            canvas.depthTag = "__depthTag__";
            canvas.flowIndexTag = "__flowIndexTag__";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], canvas.prototype, "pixelWidth", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], canvas.prototype, "pixelHeight", void 0);
            __decorate([
                gd3d.reflect.Field("transform2D"),
                __metadata("design:type", framework.transform2D)
            ], canvas.prototype, "rootNode", void 0);
            canvas = canvas_1 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], canvas);
            return canvas;
        }());
        framework.canvas = canvas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var canvasRenderer = (function () {
            function canvasRenderer() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this.cupTans2ds = [];
                this.canvas = new framework.canvas();
                this.canvas.is2dUI = false;
            }
            Object.defineProperty(canvasRenderer.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            canvasRenderer.prototype.getBound = function () {
                return null;
            };
            canvasRenderer.prototype.intersectsTransform = function (tran) {
                return false;
            };
            canvasRenderer.prototype.start = function () {
                this.canvas.scene = this.gameObject.getScene();
                this.canvas.parentTrans = this.gameObject.transform;
                this.inputmgr = this.gameObject.getScene().app.getInputMgr();
            };
            canvasRenderer.prototype.onPlay = function () {
            };
            canvasRenderer.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            canvasRenderer.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            canvasRenderer.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            canvasRenderer.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            canvasRenderer.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            canvasRenderer.prototype.update = function (delta) {
                var asp = this.canvas.pixelWidth / this.canvas.pixelHeight;
                this.gameObject.transform.localScale.x = this.gameObject.transform.localScale.y * asp;
                if (this.cameraTouch != null) {
                    var scene_1 = this.gameObject.getScene();
                    var tempv2 = gd3d.math.pool.new_vector2(this.inputmgr.point.x, this.inputmgr.point.y);
                    var ray_1 = this.cameraTouch.creatRayByScreen(tempv2, scene_1.app);
                    var outModel = gd3d.math.pool.new_vector2();
                    var bool = this.pickModelPos(ray_1, outModel);
                    if (bool) {
                        this.canvas.update(delta, this.inputmgr.point.touch, outModel.x, outModel.y);
                    }
                    else {
                        this.canvas.update(delta, false, 0, 0);
                    }
                    gd3d.math.pool.delete_vector2(tempv2);
                    gd3d.math.pool.delete_vector2(outModel);
                }
                else {
                    this.canvas.update(delta, false, 0, 0);
                }
            };
            canvasRenderer.prototype.pickModelPos = function (ray, outModelPos) {
                var result = false;
                if (!ray || !outModelPos)
                    return result;
                var scene = this.gameObject.getScene();
                var tempInfo = gd3d.math.pool.new_pickInfo();
                var bool = ray.intersectPlaneTransform(this.gameObject.transform, tempInfo);
                if (bool && tempInfo.pickedtran == this.gameObject.transform) {
                    var mat = this.gameObject.transform.getWorldMatrix();
                    var matinv = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixInverse(mat, matinv);
                    var outv = gd3d.math.pool.new_vector3();
                    gd3d.math.matrixTransformVector3(tempInfo.hitposition, matinv, outv);
                    outModelPos.x = outv.x;
                    outModelPos.y = outv.y;
                    result = true;
                    gd3d.math.pool.delete_matrix(matinv);
                    gd3d.math.pool.delete_vector3(outv);
                }
                return result;
            };
            canvasRenderer.prototype.pickAll2d = function (ray) {
                var result;
                var outv = gd3d.math.pool.new_vector2();
                var bool = this.pickModelPos(ray, outv);
                if (bool) {
                    result = [];
                    this.dopick2d(outv, this.canvas.getRoot(), result, true);
                }
                gd3d.math.pool.delete_vector2(outv);
                return result;
            };
            canvasRenderer.prototype.pick2d = function (ray) {
                var result;
                var outv = gd3d.math.pool.new_vector2();
                var bool = this.pickModelPos(ray, outv);
                if (bool) {
                    var temparr = [];
                    this.dopick2d(outv, this.canvas.getRoot(), temparr);
                    if (temparr && temparr[0])
                        result = temparr[0];
                }
                gd3d.math.pool.delete_vector2(outv);
                return result;
            };
            canvasRenderer.prototype.dopick2d = function (ModelPos, tran, outPicks, isAll) {
                if (isAll === void 0) { isAll = false; }
                if (!ModelPos || !tran || !outPicks)
                    return;
                if (tran.children && tran.children.length > 0) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        this.dopick2d(ModelPos, tran.children[i], outPicks, isAll);
                    }
                }
                if (tran.ContainsCanvasPoint(ModelPos)) {
                    outPicks.push(tran);
                    if (!isAll)
                        return;
                }
            };
            canvasRenderer.prototype.calScreenPosToCanvasPos = function (camera, screenPos, outCanvasPos) {
                if (!camera || !screenPos || !outCanvasPos)
                    return;
                var ray = camera.creatRayByScreen(screenPos, this.gameObject.getScene().app);
                var ModelPos = gd3d.math.pool.new_vector2();
                this.pickModelPos(ray, ModelPos);
                this.canvas.ModelPosToCanvasPos(ModelPos, outCanvasPos);
                gd3d.math.pool.delete_vector2(ModelPos);
            };
            canvasRenderer.prototype.calCanvasPosToWorldPos = function (from, out) {
                if (!this.canvas || !from || !out)
                    return;
                var ModelPos = gd3d.math.pool.new_vector3();
                ModelPos.x = (from.x / this.canvas.pixelWidth) * 2 - 1;
                ModelPos.y = (from.y / this.canvas.pixelHeight) * -2 + 1;
                var m_mtx = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixTransformVector3(ModelPos, m_mtx, out);
                out.z = this.gameObject.transform.getWorldTranslate().z;
                gd3d.math.pool.delete_vector3(ModelPos);
            };
            canvasRenderer.prototype.render = function (context, assetmgr, camera) {
                context.updateModel(this.gameObject.transform);
                this.canvas.render(context, assetmgr);
            };
            canvasRenderer.prototype.remove = function () {
            };
            canvasRenderer.prototype.clone = function () {
            };
            canvasRenderer.ClassName = "canvasRenderer";
            __decorate([
                gd3d.reflect.Field("canvas"),
                __metadata("design:type", framework.canvas)
            ], canvasRenderer.prototype, "canvas", void 0);
            canvasRenderer = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeCanvasRendererCollider,
                __metadata("design:paramtypes", [])
            ], canvasRenderer);
            return canvasRenderer;
        }());
        framework.canvasRenderer = canvasRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var UIScaleMode;
        (function (UIScaleMode) {
            UIScaleMode[UIScaleMode["CONSTANT_PIXEL_SIZE"] = 0] = "CONSTANT_PIXEL_SIZE";
            UIScaleMode[UIScaleMode["SCALE_WITH_SCREEN_SIZE"] = 1] = "SCALE_WITH_SCREEN_SIZE";
        })(UIScaleMode = framework.UIScaleMode || (framework.UIScaleMode = {}));
        var overlay2D = (function () {
            function overlay2D() {
                this.init = false;
                this.screenMatchRate = 0;
                this.matchReference_width = 800;
                this.matchReference_height = 600;
                this.scaleMode = UIScaleMode.CONSTANT_PIXEL_SIZE;
                this.sortOrder = 0;
                this.viewPixelrect = new gd3d.math.rect();
                this.helpv2 = new gd3d.math.vector2();
                this.helpv2_1 = new gd3d.math.vector2();
                this.lastVPRect = new gd3d.math.rect();
                this.lastScreenMR = 0;
                this.lastMR_width = 0;
                this.lastMR_height = 0;
                this.canvas = new framework.canvas();
                framework.sceneMgr.app.markNotify(this.canvas.getRoot(), framework.NotifyType.AddChild);
            }
            overlay2D.prototype.start = function (camera) {
                if (camera == this.camera)
                    return;
                this.camera = camera;
                this.app = camera.gameObject.getScene().app;
                this.canvas.scene = camera.gameObject.getScene();
                this.inputmgr = camera.gameObject.getScene().app.getInputMgr();
            };
            overlay2D.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            overlay2D.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            overlay2D.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            overlay2D.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            overlay2D.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            overlay2D.prototype.render = function (context, assetmgr, camera) {
                if (!this.canvas.getRoot().visible || !this.camera)
                    return;
                context.updateOverlay();
                this.canvas.render(context, assetmgr);
            };
            overlay2D.prototype.update = function (delta) {
                this.ckScaleMode();
                this.helpv2.x = this.inputmgr.point.x;
                this.helpv2.y = this.inputmgr.point.y;
                var sPos = this.helpv2;
                var mPos = this.helpv2_1;
                this.calScreenPosToModelPos(sPos, mPos);
                this.canvas.update(delta, this.inputmgr.point.touch, mPos.x, mPos.y);
            };
            overlay2D.prototype.ckScaleMode = function () {
                if (!this.canvas.getRoot().visible || !this.camera)
                    return;
                this.camera.calcViewPortPixel(this.app, this.viewPixelrect);
                var dirty = false;
                if (gd3d.math.rectEqul(this.lastVPRect, this.viewPixelrect)) {
                    switch (this.scaleMode) {
                        case UIScaleMode.CONSTANT_PIXEL_SIZE:
                            break;
                        case UIScaleMode.SCALE_WITH_SCREEN_SIZE:
                            if (this.lastScreenMR != this.screenMatchRate || this.lastMR_width != this.matchReference_width || this.lastMR_height != this.matchReference_height) {
                                dirty = true;
                            }
                            break;
                    }
                }
                else {
                    dirty = true;
                }
                if (!dirty)
                    return;
                var _w = 0;
                var _h = 0;
                gd3d.math.rectClone(this.viewPixelrect, this.lastVPRect);
                this.lastScreenMR = this.screenMatchRate;
                this.lastMR_width = this.matchReference_width;
                this.lastMR_height = this.matchReference_height;
                switch (this.scaleMode) {
                    case UIScaleMode.CONSTANT_PIXEL_SIZE:
                        _w = this.viewPixelrect.w;
                        _h = this.viewPixelrect.h;
                        break;
                    case UIScaleMode.SCALE_WITH_SCREEN_SIZE:
                        var match = this.screenMatchRate < 0 ? 0 : this.screenMatchRate;
                        match = match > 1 ? 1 : match;
                        var asp = this.viewPixelrect.w / this.viewPixelrect.h;
                        _w = gd3d.math.numberLerp(this.matchReference_width, this.matchReference_height * asp, match);
                        _h = gd3d.math.numberLerp(this.matchReference_height, this.matchReference_width / asp, 1 - match);
                        break;
                }
                this.canvas.pixelWidth = _w;
                this.canvas.pixelHeight = _h;
                this.canvas.getRoot().markDirty();
            };
            overlay2D.prototype.pick2d = function (mx, my, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (this.camera == null)
                    return null;
                var root = this.canvas.getRoot();
                this.helpv2.x = mx;
                this.helpv2.y = my;
                var sPos = this.helpv2;
                var mPos = this.helpv2_1;
                this.calScreenPosToModelPos(sPos, mPos);
                var trans = this.dopick2d(mPos, root, tolerance);
                return trans;
            };
            overlay2D.prototype.dopick2d = function (ModelPos, tran, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.comp.transform.ContainsCanvasPoint(ModelPos, tolerance)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(ModelPos, tran.children[i], tolerance);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            overlay2D.prototype.calScreenPosToCanvasPos = function (screenPos, outCanvasPos) {
                if (!this.camera || !this.canvas)
                    return;
                var mPos = this.helpv2;
                this.calScreenPosToModelPos(screenPos, mPos);
                this.canvas.ModelPosToCanvasPos(mPos, outCanvasPos);
            };
            overlay2D.prototype.calCanvasPosToScreenPos = function (canvasPos, outScreenPos) {
                if (!this.camera || !this.canvas)
                    return;
                var mPos = this.helpv2;
                this.canvas.CanvasPosToModelPos(canvasPos, mPos);
                this.calModelPosToScreenPos(mPos, outScreenPos);
            };
            overlay2D.prototype.calScreenPosToModelPos = function (screenPos, outModelPos) {
                if (!screenPos || !outModelPos || !this.camera)
                    return;
                this.camera.calcViewPortPixel(this.app, this.viewPixelrect);
                var rect = this.camera.viewport;
                var real_x = screenPos.x - rect.x * this.app.width;
                var real_y = screenPos.y - rect.y * this.app.height;
                outModelPos.x = (real_x / this.viewPixelrect.w) * 2 - 1;
                outModelPos.y = (real_y / this.viewPixelrect.h) * -2 + 1;
            };
            overlay2D.prototype.calModelPosToScreenPos = function (modelPos, outScreenPos) {
                if (!modelPos || !outScreenPos || !this.camera)
                    return;
                this.camera.calcViewPortPixel(this.app, this.viewPixelrect);
                var rect = this.camera.viewport;
                var real_x = this.viewPixelrect.w * (modelPos.x + 1) / 2;
                var real_y = this.viewPixelrect.h * (modelPos.y - 1) / -2;
                outScreenPos.x = real_x + rect.x * this.app.width;
                outScreenPos.y = real_y + rect.y * this.app.height;
            };
            overlay2D.ClassName = "overlay2D";
            __decorate([
                gd3d.reflect.Field("canvas"),
                __metadata("design:type", framework.canvas)
            ], overlay2D.prototype, "canvas", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], overlay2D.prototype, "screenMatchRate", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object)
            ], overlay2D.prototype, "matchReference_width", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object)
            ], overlay2D.prototype, "matchReference_height", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], overlay2D.prototype, "scaleMode", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], overlay2D.prototype, "sortOrder", void 0);
            overlay2D = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], overlay2D);
            return overlay2D;
        }());
        framework.overlay2D = overlay2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var layoutOption;
        (function (layoutOption) {
            layoutOption[layoutOption["LEFT"] = 1] = "LEFT";
            layoutOption[layoutOption["TOP"] = 2] = "TOP";
            layoutOption[layoutOption["RIGHT"] = 4] = "RIGHT";
            layoutOption[layoutOption["BOTTOM"] = 8] = "BOTTOM";
            layoutOption[layoutOption["H_CENTER"] = 16] = "H_CENTER";
            layoutOption[layoutOption["V_CENTER"] = 32] = "V_CENTER";
        })(layoutOption = framework.layoutOption || (framework.layoutOption = {}));
        var C2DComponent = (function () {
            function C2DComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.comp = comp;
                this.init = init;
            }
            C2DComponent.ClassName = "C2DComponent";
            __decorate([
                gd3d.reflect.Field("I2DComponent"),
                __metadata("design:type", Object)
            ], C2DComponent.prototype, "comp", void 0);
            C2DComponent = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], C2DComponent);
            return C2DComponent;
        }());
        framework.C2DComponent = C2DComponent;
        var transform2D = (function () {
            function transform2D() {
                this.prefab = "";
                this.layer = framework.cullingmaskutil.maskTolayer(framework.CullingMask.default);
                this.tag = framework.StringUtil.builtinTag_Untagged;
                this.name = "noname";
                this.isStatic = false;
                this.width = 0;
                this.height = 0;
                this.pivot = new gd3d.math.vector2(0, 0);
                this.hideFlags = framework.HideFlags.None;
                this._visible = true;
                this.insId = new framework.insID();
                this.dirty = true;
                this.dirtyChild = true;
                this.dirtyWorldDecompose = false;
                this.localTranslate = new gd3d.math.vector2(0, 0);
                this.localScale = new gd3d.math.vector2(1, 1);
                this.localRotate = 0;
                this._isMask = false;
                this._parentIsMask = false;
                this.localMatrix = new gd3d.math.matrix3x2;
                this.worldMatrix = new gd3d.math.matrix3x2();
                this.canvasWorldMatrix = new gd3d.math.matrix3x2();
                this.worldRotate = new gd3d.math.angelref();
                this.worldTranslate = new gd3d.math.vector2(0, 0);
                this.worldScale = new gd3d.math.vector2(1, 1);
                this.components = [];
                this.componentsInit = [];
                this.componentplayed = [];
                this.optionArr = [layoutOption.LEFT, layoutOption.TOP, layoutOption.RIGHT, layoutOption.BOTTOM, layoutOption.H_CENTER, layoutOption.V_CENTER];
                this._layoutState = 0;
                this.layoutValueMap = {};
                this._layoutPercentState = 0;
                this.layoutDirty = false;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.lastParentWidth = 0;
                this.lastParentHeight = 0;
                this.lastParentPivot = new gd3d.math.vector2(0, 0);
                this.lastPivot = new gd3d.math.vector2(0, 0);
            }
            Object.defineProperty(transform2D.prototype, "canvas", {
                get: function () {
                    if (this._canvas == null) {
                        if (this.parent == null)
                            return null;
                        return this.parent.canvas;
                    }
                    return this._canvas;
                },
                set: function (val) {
                    if (!val)
                        return;
                    this._canvas = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible) {
                        obj = obj.parent;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(transform2D.prototype, "transform", {
                get: function () {
                    return this;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "maskRect", {
                get: function () {
                    if (this._temp_maskRect == null)
                        this._temp_maskRect = new gd3d.math.rect();
                    if (this._maskRect != null) {
                        this._temp_maskRect.x = this._maskRect.x;
                        this._temp_maskRect.y = this._maskRect.y;
                        this._temp_maskRect.w = this._maskRect.w;
                        this._temp_maskRect.h = this._maskRect.h;
                    }
                    return this._temp_maskRect;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "isMask", {
                get: function () {
                    return this._isMask;
                },
                set: function (b) {
                    this._isMask = b;
                    this.markDirty();
                    if (this.parent != null)
                        this.updateTran(true);
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.updateMaskRect = function () {
                var rect_x;
                var rect_y;
                var rect_w;
                var rect_h;
                var ParentRect;
                if (this.parent != null) {
                    this._parentIsMask = this.parent.isMask || this.parent.parentIsMask;
                    ParentRect = this.parent.maskRect;
                }
                else
                    this._parentIsMask = false;
                if (this.isMask || this.parentIsMask) {
                    if (this.isMask) {
                        var wPos = this.getWorldTranslate();
                        var wW = this.canvas.pixelWidth;
                        var wH = this.canvas.pixelHeight;
                        rect_x = wPos.x / wW;
                        rect_y = wPos.y / wH;
                        rect_w = this.width / wW;
                        rect_h = this.height / wH;
                        if (this.parentIsMask && ParentRect != null) {
                            var min_x = Math.max(rect_x, ParentRect.x);
                            var min_y = Math.max(rect_y, ParentRect.y);
                            var max_x = Math.min(rect_x + rect_w, ParentRect.x + ParentRect.w);
                            var max_y = Math.min(rect_y + rect_h, ParentRect.y + ParentRect.h);
                            rect_x = min_x;
                            rect_y = min_y;
                            rect_w = max_x - min_x;
                            rect_h = max_y - min_y;
                        }
                    }
                    else if (ParentRect != null) {
                        rect_x = ParentRect.x;
                        rect_y = ParentRect.y;
                        rect_w = ParentRect.w;
                        rect_h = ParentRect.h;
                    }
                    if (this._maskRect == null)
                        this._maskRect = new gd3d.math.rect();
                    if (this._maskRect.x != rect_x || this._maskRect.x != rect_y || this._maskRect.x != rect_w || this._maskRect.x != rect_h) {
                        this._maskRect.x = rect_x;
                        this._maskRect.y = rect_y;
                        this._maskRect.w = rect_w;
                        this._maskRect.h = rect_h;
                    }
                }
            };
            Object.defineProperty(transform2D.prototype, "parentIsMask", {
                get: function () {
                    return this._parentIsMask;
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.addChild = function (node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.push(node);
                node.parent = this;
                node.canvas = this.canvas;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                this.markDirty();
            };
            transform2D.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.canvas = this.canvas;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                this.markDirty();
            };
            transform2D.prototype.removeChild = function (node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    node.parent = null;
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                }
            };
            transform2D.prototype.removeAllChild = function () {
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            };
            transform2D.prototype.markDirty = function () {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            };
            transform2D.prototype.updateTran = function (parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    gd3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    this.refreshLayout();
                    if (this.parent == null) {
                        gd3d.math.matrix3x2Clone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrix3x2Multiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.dirtyWorldDecompose = true;
                    this.updateMaskRect();
                    if (this.renderer != null) {
                        this.renderer.updateTran();
                    }
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
            };
            transform2D.prototype.updateWorldTran = function () {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            };
            transform2D.prototype.CalcReCanvasMtx = function (out) {
                if (!out)
                    return;
                var tsca = gd3d.math.pool.new_vector2();
                var ttran = gd3d.math.pool.new_vector2();
                tsca.x = this.canvas.pixelWidth / 2;
                tsca.y = -this.canvas.pixelHeight / 2;
                ttran.x = this.canvas.pixelWidth / 2;
                ttran.y = this.canvas.pixelHeight / 2;
                gd3d.math.matrix3x2MakeTransformRTS(ttran, tsca, 0, out);
            };
            transform2D.prototype.decomposeWorldMatrix = function () {
                if (this.dirtyWorldDecompose) {
                    var reCanvasMtx = gd3d.math.pool.new_matrix3x2();
                    this.CalcReCanvasMtx(reCanvasMtx);
                    gd3d.math.matrix3x2Multiply(reCanvasMtx, this.worldMatrix, this.canvasWorldMatrix);
                    gd3d.math.matrix3x2Decompose(this.canvasWorldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    gd3d.math.pool.delete_matrix3x2(reCanvasMtx);
                    this.dirtyWorldDecompose = false;
                }
            };
            transform2D.prototype.getWorldTranslate = function () {
                this.decomposeWorldMatrix();
                return this.worldTranslate;
            };
            transform2D.prototype.getWorldScale = function () {
                this.decomposeWorldMatrix();
                return this.worldScale;
            };
            transform2D.prototype.getWorldRotate = function () {
                this.decomposeWorldMatrix();
                return this.worldRotate;
            };
            transform2D.prototype.getLocalMatrix = function () {
                return this.localMatrix;
            };
            transform2D.prototype.getWorldMatrix = function () {
                return this.worldMatrix;
            };
            transform2D.prototype.getCanvasWorldMatrix = function () {
                this.decomposeWorldMatrix();
                return this.canvasWorldMatrix;
            };
            transform2D.getTransInfoInCanvas = function (trans, out) {
                var mat = trans.getWorldMatrix();
                var rotmat = trans.canvas.getRoot().getWorldMatrix();
                var inversemat = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(rotmat, inversemat);
                var mattoRoot = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Multiply(inversemat, mat, mattoRoot);
                var rotscale = gd3d.math.pool.new_vector2();
                var rotRot = new gd3d.math.angelref();
                var rotPos = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2Decompose(mattoRoot, rotscale, rotRot, rotPos);
                gd3d.math.vec2Clone(trans.pivot, out.pivot);
                gd3d.math.vec2Clone(rotPos, out.pivotPos);
                out.rot = rotRot.v;
                out.width = trans.width * rotscale.x;
                out.height = trans.height * rotscale.y;
                gd3d.math.pool.delete_matrix3x2(inversemat);
                gd3d.math.pool.delete_matrix3x2(mattoRoot);
                gd3d.math.pool.delete_vector2(rotscale);
                gd3d.math.pool.delete_vector2(rotPos);
            };
            transform2D.prototype.setWorldPosition = function (pos) {
                this.dirty = true;
                this.updateWorldTran();
                var thispos = this.getWorldTranslate();
                var dir = gd3d.math.pool.new_vector2();
                dir.x = pos.x - thispos.x;
                dir.y = pos.y - thispos.y;
                var pworld = gd3d.math.pool.new_matrix3x2();
                if (this.parent != null) {
                    gd3d.math.matrix3x2Clone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrix3x2MakeIdentity(pworld);
                }
                var matinv = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(pworld, matinv);
                var dirinv = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2TransformNormal(matinv, dir, dirinv);
                this.localTranslate.x += dirinv.x;
                this.localTranslate.y += dirinv.y;
                gd3d.math.pool.delete_matrix3x2(matinv);
                gd3d.math.pool.delete_vector2(dir);
                gd3d.math.pool.delete_vector2(dirinv);
            };
            transform2D.prototype.dispose = function () {
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                    this.removeAllChild();
                }
                this.removeAllComponents();
            };
            transform2D.prototype.update = function (delta) {
                if (this.components.length == 0)
                    return;
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.update(delta);
                }
            };
            transform2D.prototype.init = function (bePlayed) {
                if (bePlayed === void 0) { bePlayed = false; }
                if (this.componentsInit.length > 0) {
                    for (var i = 0; i < this.componentsInit.length; i++) {
                        this.componentsInit[i].comp.start();
                        this.componentsInit[i].init = true;
                        if (bePlayed)
                            this.componentsInit[i].comp.onPlay();
                        else
                            this.componentplayed.push(this.componentsInit[i]);
                    }
                    this.componentsInit.length = 0;
                }
                if (this.componentplayed.length > 0 && bePlayed) {
                    this.componentplayed.forEach(function (item) {
                        item.comp.onPlay();
                    });
                    this.componentplayed.length = 0;
                }
            };
            transform2D.prototype.addComponent = function (type) {
                if (this.components == null)
                    this.components = [];
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("已经有一个" + type + "的组件了，不能俩");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "2dcomp": "1" });
                return this.addComponentDirect(comp);
            };
            transform2D.prototype.addComponentDirect = function (comp) {
                if (comp.transform != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.transform = this;
                if (this.components == null)
                    this.components = [];
                var _comp = new C2DComponent(comp, false);
                this.components.push(_comp);
                this.componentsInit.push(_comp);
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                    }
                    else {
                        throw new Error("已经有一个渲染器的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider2d") == "1") {
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        throw new Error("已经有一个碰撞组件了，不能俩");
                    }
                }
                return comp;
            };
            transform2D.prototype.removeComponent = function (comp) {
                if (!comp)
                    return;
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                        }
                        var p = this.components.splice(i, 1);
                        comp.remove();
                        break;
                    }
                }
            };
            transform2D.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        var p = this.components.splice(i, 1);
                        if (p[0].comp == this.renderer)
                            this.renderer = null;
                        if (p[0].comp == this.collider)
                            this.collider = null;
                        p[0].comp.remove();
                        return p[0];
                    }
                }
            };
            transform2D.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.remove();
                }
                if (this.renderer)
                    this.renderer = null;
                if (this.collider)
                    this.renderer = null;
                this.components.length = 0;
            };
            transform2D.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            transform2D.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            transform2D.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this.getNodeCompoents(this, type, components);
                return components;
            };
            transform2D.prototype.getNodeCompoents = function (node, _type, comps) {
                for (var i in node.components) {
                    var cname = gd3d.reflect.getClassName(node.components[i].comp["__proto__"]);
                    if (cname == _type) {
                        comps.push(node.components[i].comp);
                    }
                }
                if (node.children != null) {
                    for (var i in node.children) {
                        this.getNodeCompoents(node.children[i], _type, comps);
                    }
                }
            };
            transform2D.prototype.onCapturePointEvent = function (canvas, ev) {
                if (this.components != null) {
                    for (var i = 0; i <= this.components.length; i++) {
                        if (ev.eated == false) {
                            var comp = this.components[i];
                            if (comp != null)
                                if (comp.init) {
                                    comp.comp.onPointEvent(canvas, ev, true);
                                }
                        }
                    }
                }
                if (ev.eated == false) {
                    if (this.children != null) {
                        for (var i = 0; i <= this.children.length; i++) {
                            var c = this.children[i];
                            if (c != null && c.visible)
                                c.onCapturePointEvent(canvas, ev);
                        }
                    }
                }
            };
            transform2D.prototype.ContainsCanvasPoint = function (ModelPos, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                var result = false;
                var mworld = this.getWorldMatrix();
                var mout = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(mworld, mout);
                var p2 = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2TransformVector2(mout, ModelPos, p2);
                p2.x += this.pivot.x * this.width;
                p2.y += this.pivot.y * this.height;
                result = p2.x + tolerance >= 0 && p2.y + tolerance >= 0 && p2.x < this.width + tolerance && p2.y < this.height + tolerance;
                gd3d.math.pool.delete_matrix3x2(mout);
                gd3d.math.pool.delete_vector2(p2);
                return result;
            };
            transform2D.prototype.onPointEvent = function (canvas, ev) {
                if (this.children != null) {
                    for (var i = this.children.length - 1; i >= 0; i--) {
                        if (ev.eated == false) {
                            var c = this.children[i];
                            if (c != null && c.visible)
                                c.onPointEvent(canvas, ev);
                        }
                    }
                }
                if (ev.eated == false && this.components != null) {
                    for (var i = this.components.length - 1; i >= 0; i--) {
                        var comp = this.components[i];
                        if (comp != null)
                            if (comp.init) {
                                comp.comp.onPointEvent(canvas, ev, false);
                            }
                    }
                }
            };
            Object.defineProperty(transform2D.prototype, "layoutState", {
                get: function () {
                    return this._layoutState;
                },
                set: function (state) {
                    if (isNaN(state) || state == undefined)
                        return;
                    if (state != this._layoutState) {
                        this.layoutDirty = true;
                        this.markDirty();
                        this._layoutState = state;
                    }
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.setLayoutValue = function (option, value) {
                if (isNaN(option) || isNaN(value) || option == undefined || value == undefined)
                    return;
                if (this.layoutValueMap[option] == undefined || value != this.layoutValueMap[option]) {
                    this.layoutDirty = true;
                    this.markDirty();
                    this.layoutValueMap[option] = value;
                }
            };
            transform2D.prototype.getLayoutValue = function (option) {
                if (this.layoutValueMap[option] == undefined)
                    this.layoutValueMap[option] = 0;
                return this.layoutValueMap[option];
            };
            Object.defineProperty(transform2D.prototype, "layoutPercentState", {
                get: function () {
                    return this._layoutPercentState;
                },
                set: function (state) {
                    if (isNaN(state) || state == undefined)
                        return;
                    if (state != this._layoutPercentState) {
                        this.layoutDirty = true;
                        this.markDirty();
                        this._layoutPercentState = state;
                    }
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.refreshLayout = function () {
                var parent = this.parent;
                if (!parent)
                    return;
                if (this.width != this.lastWidth || this.height != this.lastHeight || parent.width != this.lastParentWidth || parent.height != this.lastParentHeight || parent.pivot.x != this.lastParentPivot.x
                    || parent.pivot.y != this.lastParentPivot.y || this.pivot.x != this.lastPivot.x || this.pivot.y != this.lastPivot.y)
                    this.layoutDirty = true;
                if (!this.layoutDirty)
                    return;
                var state = this._layoutState;
                if (state != 0) {
                    if (state & layoutOption.LEFT) {
                        if (state & layoutOption.RIGHT) {
                            this.width = parent.width - this.getLayValue(layoutOption.LEFT) - this.getLayValue(layoutOption.RIGHT);
                        }
                        this.localTranslate.x = this.getLayValue(layoutOption.LEFT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    else if (state & layoutOption.RIGHT) {
                        this.localTranslate.x = parent.width - this.width - this.getLayValue(layoutOption.RIGHT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.H_CENTER) {
                        this.localTranslate.x = (parent.width - this.width) / 2 + this.getLayValue(layoutOption.H_CENTER) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.TOP) {
                        if (state & layoutOption.BOTTOM) {
                            this.height = parent.height - this.getLayValue(layoutOption.TOP) - this.getLayValue(layoutOption.BOTTOM);
                        }
                        this.localTranslate.y = this.getLayValue(layoutOption.TOP) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    else if (state & layoutOption.BOTTOM) {
                        this.localTranslate.y = parent.height - this.height - this.getLayValue(layoutOption.BOTTOM) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    if (state & layoutOption.V_CENTER) {
                        this.localTranslate.y = (parent.height - this.height) / 2 + this.getLayValue(layoutOption.V_CENTER) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    gd3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                this.layoutDirty = false;
                this.lastParentWidth = parent.width;
                this.lastParentHeight = parent.height;
                this.lastWidth = this.width;
                this.lastHeight = this.height;
                this.lastParentPivot.x = parent.pivot.x;
                this.lastParentPivot.y = parent.pivot.y;
                this.lastPivot.x = this.pivot.x;
                this.lastPivot.y = this.pivot.y;
            };
            transform2D.prototype.getLayValue = function (option) {
                if (this.layoutValueMap[option] == undefined)
                    this.layoutValueMap[option] = 0;
                var value = 0;
                if (this._layoutPercentState & option) {
                    if (this.parent) {
                        switch (option) {
                            case layoutOption.LEFT:
                            case layoutOption.H_CENTER:
                            case layoutOption.RIGHT:
                                value = this.parent.width * this.layoutValueMap[option] / 100;
                                break;
                            case layoutOption.TOP:
                            case layoutOption.V_CENTER:
                            case layoutOption.BOTTOM:
                                value = this.parent.height * this.layoutValueMap[option] / 100;
                                break;
                        }
                    }
                }
                else {
                    value = this.layoutValueMap[option];
                }
                return value;
            };
            transform2D.prototype.setSiblingIndex = function (siblingIndex) {
                var p = this.transform.parent;
                if (!p || !p.children || siblingIndex >= p.children.length || isNaN(siblingIndex) || siblingIndex < 0)
                    return;
                var currIdx = p.children.indexOf(this);
                if (currIdx == -1 || currIdx == siblingIndex)
                    return;
                p.children.splice(currIdx, 1);
                var useidx = siblingIndex > currIdx ? siblingIndex - 1 : siblingIndex;
                p.children.splice(useidx, 0, this);
            };
            transform2D.prototype.getSiblingIndex = function () {
                var p = this.transform.parent;
                if (!p || !p.children)
                    return -1;
                if (p.children.length < 1)
                    return 0;
                return p.children.indexOf(this);
            };
            transform2D.prototype.clone = function () {
                return gd3d.io.cloneObj(this);
            };
            transform2D.ClassName = "transform2D";
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform2D.prototype, "prefab", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("enum"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "layer", void 0);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform2D.prototype, "tag", void 0);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform2D.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], transform2D.prototype, "isStatic", void 0);
            __decorate([
                gd3d.reflect.Field("transform2D[]"),
                __metadata("design:type", Array)
            ], transform2D.prototype, "children", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "width", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "height", void 0);
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2)
            ], transform2D.prototype, "pivot", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Object)
            ], transform2D.prototype, "_visible", void 0);
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2)
            ], transform2D.prototype, "localTranslate", void 0);
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2)
            ], transform2D.prototype, "localScale", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "localRotate", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean),
                __metadata("design:paramtypes", [Boolean])
            ], transform2D.prototype, "isMask", null);
            __decorate([
                gd3d.reflect.Field("C2DComponent[]"),
                __metadata("design:type", Array)
            ], transform2D.prototype, "components", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], transform2D.prototype, "layoutState", null);
            __decorate([
                gd3d.reflect.Field("numberdic"),
                __metadata("design:type", Object)
            ], transform2D.prototype, "layoutValueMap", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], transform2D.prototype, "layoutPercentState", null);
            transform2D = __decorate([
                gd3d.reflect.SerializeType
            ], transform2D);
            return transform2D;
        }());
        framework.transform2D = transform2D;
        var t2dInfo = (function () {
            function t2dInfo() {
                this.pivot = new gd3d.math.vector2();
                this.pivotPos = new gd3d.math.vector2();
            }
            t2dInfo.getCenter = function (info, outCenter) {
                outCenter.x = info.pivotPos.x + info.width * (0.5 - info.pivot.x) * Math.cos(info.rot) - info.height * (0.5 - info.pivot.y) * Math.sin(info.rot);
                outCenter.y = info.pivotPos.y - info.width * (0.5 - info.pivot.x) * Math.sin(info.rot) + info.height * (0.5 - info.pivot.y) * Math.cos(info.rot);
            };
            return t2dInfo;
        }());
        framework.t2dInfo = t2dInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var behaviour2d = (function () {
            function behaviour2d() {
            }
            behaviour2d.prototype.start = function () {
            };
            behaviour2d.prototype.onPlay = function () {
            };
            behaviour2d.prototype.update = function (delta) {
            };
            behaviour2d.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            behaviour2d.prototype.remove = function () {
            };
            return behaviour2d;
        }());
        framework.behaviour2d = behaviour2d;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var boxcollider2d = (function () {
            function boxcollider2d() {
            }
            boxcollider2d.prototype.getBound = function () {
                return this._obb;
            };
            boxcollider2d.prototype.intersectsTransform = function (tran) {
                if (tran == null)
                    return false;
                if (this._obb == null || tran.collider.getBound() == null)
                    return false;
                var _obb = tran.collider.getBound();
                return this._obb.intersects(_obb);
            };
            boxcollider2d.prototype.build = function () {
                var t = this.transform;
                this._obb = new framework.obb2d();
                this._obb.buildByCenterSize(t.getWorldTranslate(), t.width, t.height);
                this.refreshTofullOver();
            };
            boxcollider2d.prototype.refreshTofullOver = function () {
                if (!this._obb || !this._obb.size || !this._obb.offset)
                    return;
                var t = this.transform;
                this._obb.size.x = t.width;
                this._obb.size.y = t.height;
                this._obb.offset.x = (0.5 - t.pivot.x) * this._obb.size.x;
                this._obb.offset.y = (0.5 - t.pivot.y) * this._obb.size.y;
            };
            boxcollider2d.prototype.start = function () {
                this.build();
            };
            boxcollider2d.prototype.onPlay = function () {
            };
            boxcollider2d.prototype.update = function (delta) {
                if (this._obb) {
                    this._obb.update(this.transform.getCanvasWorldMatrix());
                }
            };
            boxcollider2d.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            boxcollider2d.prototype.remove = function () {
                if (this._obb)
                    this._obb.dispose();
                this._obb = null;
            };
            boxcollider2d.ClassName = "boxcollider2d";
            boxcollider2d = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeBoxCollider2d
            ], boxcollider2d);
            return boxcollider2d;
        }());
        framework.boxcollider2d = boxcollider2d;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var helpV2 = new gd3d.math.vector2();
        var TransitionType;
        (function (TransitionType) {
            TransitionType[TransitionType["None"] = 0] = "None";
            TransitionType[TransitionType["ColorTint"] = 1] = "ColorTint";
            TransitionType[TransitionType["SpriteSwap"] = 2] = "SpriteSwap";
        })(TransitionType = framework.TransitionType || (framework.TransitionType = {}));
        var button = (function () {
            function button() {
                this._transition = TransitionType.ColorTint;
                this._origianlSpriteName = "";
                this._pressedSpriteName = "";
                this._normalColor = new gd3d.math.color(1, 1, 1, 1);
                this._pressedColor = new gd3d.math.color(0.5, 0.5, 0.5, 1);
                this._fadeDuration = 0.1;
                this.downPointV2 = new gd3d.math.vector2();
                this.isMovedLimit = false;
                this.movedLimit = 0.02;
                this.UIEventer = new gd3d.event.UIEvent();
                this._downInThis = false;
                this._dragOut = false;
            }
            Object.defineProperty(button.prototype, "transition", {
                get: function () {
                    return this._transition;
                },
                set: function (transition) {
                    this._transition = transition;
                    if (this._targetImage != null) {
                        if (transition == TransitionType.ColorTint) {
                            this._targetImage.color = this.normalColor;
                        }
                        else {
                            this._targetImage.color = this._originalColor;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "targetImage", {
                get: function () {
                    return this._targetImage;
                },
                set: function (graphic) {
                    if (this._targetImage != null) {
                        this._targetImage.color = this._originalColor;
                    }
                    if (graphic != null) {
                        this._originalColor = graphic.color;
                        this._originalSprite = graphic.sprite;
                        if (graphic.sprite)
                            this._origianlSpriteName = graphic.sprite.getName();
                        if (this._transition == TransitionType.ColorTint) {
                            graphic.color = this.normalColor;
                        }
                    }
                    else {
                        this._originalColor = null;
                        this._originalSprite = null;
                    }
                    this._targetImage = graphic;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedGraphic", {
                get: function () {
                    return this._pressedSprite;
                },
                set: function (sprite) {
                    this._pressedSprite = sprite;
                    if (sprite != null) {
                        this._pressedSpriteName = sprite.getName();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "normalColor", {
                get: function () {
                    return this._normalColor;
                },
                set: function (color) {
                    this._normalColor = color;
                    if (this._targetImage != null && this.transition == TransitionType.ColorTint) {
                        this._targetImage.color = color;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedColor", {
                get: function () {
                    return this._pressedColor;
                },
                set: function (color) {
                    this._pressedColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "fadeDuration", {
                get: function () {
                    return this._fadeDuration;
                },
                set: function (duration) {
                    this._fadeDuration = duration;
                },
                enumerable: true,
                configurable: true
            });
            button.prototype.start = function () {
            };
            button.prototype.onPlay = function () {
            };
            button.prototype.update = function (delta) {
            };
            button.prototype.remove = function () {
                this._targetImage = null;
                this.transform = null;
                this._normalColor = null;
                this._originalColor = null;
                this._pressedColor = null;
                if (this.pressedGraphic)
                    this.pressedGraphic.unuse(true);
            };
            button.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    helpV2.x = ev.x;
                    helpV2.y = ev.y;
                    var b = this.transform.ContainsCanvasPoint(helpV2);
                    if (b) {
                        if (ev.type == gd3d.event.PointEventEnum.PointDown) {
                            this._downInThis = true;
                            this.showPress();
                            var pd = gd3d.event.UIEventEnum.PointerDown;
                            if (this.UIEventer.listenerCount(gd3d.event.UIEventEnum[pd]) > 0) {
                                ev.eated = true;
                                this.UIEventer.EmitEnum(pd, ev);
                            }
                            this.downPointV2.x = ev.x;
                            this.downPointV2.y = ev.y;
                            this.isMovedLimit = false;
                        }
                        else if (ev.type == gd3d.event.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == true) {
                                this._dragOut = false;
                                this.showPress();
                            }
                            if (!this.isMovedLimit) {
                                this.isMovedLimit = gd3d.math.vec2Distance(helpV2, this.downPointV2) > this.movedLimit;
                            }
                        }
                        else if (ev.type == gd3d.event.PointEventEnum.PointUp && this._downInThis) {
                            this._downInThis = false;
                            this.showNormal();
                            var pu = gd3d.event.UIEventEnum.PointerUp;
                            if (this.UIEventer.listenerCount(gd3d.event.UIEventEnum[pu]) > 0) {
                                ev.eated = true;
                                this.UIEventer.EmitEnum(pu, ev);
                            }
                            var pc = gd3d.event.UIEventEnum.PointerClick;
                            if (!this.isMovedLimit && this.UIEventer.listenerCount(gd3d.event.UIEventEnum[pc]) > 0) {
                                ev.eated = true;
                                this.UIEventer.EmitEnum(pc, ev);
                            }
                        }
                    }
                    else {
                        if (ev.type == gd3d.event.PointEventEnum.PointUp) {
                            this._downInThis = false;
                        }
                        else if (ev.type == gd3d.event.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == false) {
                                this._dragOut = true;
                                this.showNormal();
                            }
                        }
                    }
                }
            };
            button.prototype.addListener = function (eventEnum, func, thisArg) {
                this.UIEventer.OnEnum(eventEnum, func, thisArg);
            };
            button.prototype.removeListener = function (eventEnum, func, thisArg) {
                this.UIEventer.RemoveListener(gd3d.event.UIEventEnum[eventEnum], func, thisArg);
            };
            button.prototype.showNormal = function () {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._normalColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (!this._originalSprite) {
                        this._originalSprite = this.tryGetSprite(this._origianlSpriteName);
                    }
                    this.changeSprite(this._originalSprite);
                }
            };
            button.prototype.showPress = function () {
                if (this.transition == TransitionType.None) {
                    return;
                }
                else if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._pressedColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (this._targetImage != null && this._targetImage.sprite != null && this._originalSprite == null) {
                        this._originalSprite = this._targetImage.sprite;
                    }
                    if (!this._pressedSprite) {
                        this._pressedSprite = this.tryGetSprite(this._pressedSpriteName);
                    }
                    this.changeSprite(this._pressedSprite);
                }
            };
            button.prototype.tryGetSprite = function (spriteName) {
                var temp = this.transform.canvas.assetmgr.mapNamed[spriteName];
                if (temp != null) {
                    var tsprite = this.transform.canvas.assetmgr.getAssetByName(spriteName);
                    if (tsprite)
                        return tsprite;
                }
            };
            button.prototype.changeColor = function (targetColor) {
                if (this._targetImage != null) {
                    this._targetImage.color = targetColor;
                    this._targetImage.transform.markDirty();
                }
            };
            button.prototype.changeSprite = function (sprite) {
                if (sprite == null)
                    return;
                if (this._targetImage != null) {
                    this._targetImage.sprite = sprite;
                    this._targetImage.transform.markDirty();
                }
            };
            button.ClassName = "button";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], button.prototype, "transition", null);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], button.prototype, "_origianlSpriteName", void 0);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], button.prototype, "_pressedSpriteName", void 0);
            __decorate([
                gd3d.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], button.prototype, "targetImage", null);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color),
                __metadata("design:paramtypes", [gd3d.math.color])
            ], button.prototype, "normalColor", null);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color),
                __metadata("design:paramtypes", [gd3d.math.color])
            ], button.prototype, "pressedColor", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], button.prototype, "fadeDuration", null);
            button = __decorate([
                gd3d.reflect.node2DComponent
            ], button);
            return button;
        }());
        framework.button = button;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var image2D = (function () {
            function image2D() {
                this._unitLen = 13;
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
                this._CustomShaderName = "";
                this._darwRect = new gd3d.math.rect();
                this._imageType = ImageType.Simple;
                this._fillMethod = FillMethod.Horizontal;
                this._fillAmmount = 1;
                this._spriteName = "";
                this._imageBorder = new gd3d.math.border();
                this.min_x = Number.MAX_VALUE;
                this.max_x = Number.MAX_VALUE * -1;
                this.min_y = Number.MAX_VALUE;
                this.max_y = Number.MAX_VALUE * -1;
                gd3d.io.enumMgr.enumMap["ImageType"] = ImageType;
                gd3d.io.enumMgr.enumMap["FillMethod"] = FillMethod;
            }
            image2D_1 = image2D;
            image2D.prototype.setShaderByName = function (shaderName) {
                this._CustomShaderName = shaderName;
            };
            image2D.prototype.getMaterial = function () {
                if (!this._uimat) {
                    return this.uimat;
                }
                return this._uimat;
            };
            image2D.prototype.getDrawBounds = function () {
                return this._darwRect;
            };
            Object.defineProperty(image2D.prototype, "uimat", {
                get: function () {
                    var assetmgr = this.transform.canvas.assetmgr;
                    if (!assetmgr)
                        return this._uimat;
                    this.searchTexture();
                    if (this._sprite && this._sprite.texture) {
                        var pMask = this.transform.parentIsMask;
                        var mat = this._uimat;
                        var rectTag = "";
                        var uiTag = "_ui";
                        if (pMask) {
                            var prect = this.transform.maskRect;
                            rectTag = "mask(" + prect.x + "_" + prect.y + "_" + prect.w + "_" + prect.h + ")";
                        }
                        var matName = this._sprite.texture.getName() + uiTag + rectTag;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (!mat) {
                            mat = new framework.material(matName);
                            var sh = assetmgr.getShader(this._CustomShaderName);
                            sh = sh ? sh : assetmgr.getShader(pMask ? image2D_1.defMaskUIShader : image2D_1.defUIShader);
                            mat.setShader(sh);
                            mat.use();
                            this.needRefreshImg = true;
                        }
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "imageType", {
                get: function () {
                    return this._imageType;
                },
                set: function (type) {
                    this._imageType = type;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillMethod", {
                get: function () {
                    return this._fillMethod;
                },
                set: function (method) {
                    this._fillMethod = method;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillAmmount", {
                get: function () {
                    return this._fillAmmount;
                },
                set: function (ammount) {
                    this._fillAmmount = ammount;
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "sprite", {
                get: function () {
                    return this._sprite;
                },
                set: function (sprite) {
                    if (sprite == this._sprite)
                        return;
                    if (this._sprite) {
                        this._sprite.unuse();
                    }
                    if (!this._sprite || this._sprite.texture != sprite.texture) {
                        this.needRefreshImg = true;
                    }
                    this._sprite = sprite;
                    if (sprite) {
                        this._sprite.use();
                        this._spriteName = this._sprite.getName();
                        this.prepareData();
                        if (this.transform != null) {
                            this.transform.markDirty();
                            this.updateTran();
                        }
                    }
                    else {
                        this._spriteName = "";
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "imageBorder", {
                get: function () {
                    return this._imageBorder;
                },
                enumerable: true,
                configurable: true
            });
            image2D.prototype.render = function (canvas) {
                var mat = this.uimat;
                if (!mat)
                    return;
                var img;
                if (this._sprite && this._sprite.texture) {
                    img = this._sprite.texture;
                }
                if (img) {
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                    }
                    if (this.transform.parentIsMask) {
                        if (!this._cacheMaskV4)
                            this._cacheMaskV4 = new gd3d.math.vector4();
                        var rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            };
            image2D.prototype.searchTexture = function () {
                if (this._sprite)
                    return;
                var assetmgr = this.transform.canvas.assetmgr;
                var temp = assetmgr.mapNamed[this._spriteName];
                var tspr;
                if (temp != null) {
                    tspr = assetmgr.getAssetByName(this._spriteName);
                }
                else {
                    if (assetmgr.mapDefaultSprite[this._spriteName])
                        tspr = assetmgr.getDefaultSprite(this._spriteName);
                }
                if (tspr) {
                    this.sprite = tspr;
                    this.needRefreshImg = true;
                    return;
                }
            };
            image2D.prototype.start = function () {
            };
            image2D.prototype.onPlay = function () {
            };
            image2D.prototype.update = function (delta) {
            };
            image2D.prototype.remove = function () {
                if (this._sprite)
                    this._sprite.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this.datar.length = 0;
                this.transform = null;
                this._imageBorder = null;
            };
            image2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            image2D.prototype.prepareData = function () {
                if (this._sprite == null)
                    return;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        break;
                    case ImageType.Sliced:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                        ];
                        break;
                    case ImageType.Tiled:
                        this.datar = [];
                        break;
                    case ImageType.Filled:
                        var halfu = urange.x + 0.5 * ulen;
                        var halfv = vrange.x + 0.5 * vlen;
                        switch (this._fillMethod) {
                            case FillMethod.Horizontal:
                            case FillMethod.Vertical:
                            case FillMethod.Radial_90:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_180:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_360:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                ];
                                break;
                        }
                        break;
                }
            };
            image2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                if (this._sprite == null)
                    return;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.updateSimpleData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Sliced:
                        this.updateSlicedData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Tiled:
                        this.updateTiledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Filled:
                        this.updateFilledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                }
                var vertexCount = this.datar.length / this._unitLen;
                for (var i = 0; i < vertexCount; i++) {
                    this.datar[i * this._unitLen + 3] = this.color.r;
                    this.datar[i * this._unitLen + 4] = this.color.g;
                    this.datar[i * this._unitLen + 5] = this.color.b;
                    this.datar[i * this._unitLen + 6] = this.color.a;
                }
                this.min_x = Math.min(x0, x1, x2, x3, this.min_x);
                this.min_y = Math.min(y0, y1, y2, y3, this.min_y);
                this.max_x = Math.max(x0, x1, x2, x3, this.max_x);
                this.max_y = Math.max(y0, y1, y2, y3, this.max_y);
                this.calcDrawRect();
            };
            image2D.prototype.calcDrawRect = function () {
                var canvas = this.transform.canvas;
                if (!canvas)
                    return;
                var minPos = helpv2;
                minPos.x = this.min_x;
                minPos.y = this.max_y;
                canvas.ModelPosToCanvasPos(minPos, minPos);
                var maxPos = helpv2_1;
                maxPos.x = this.max_x;
                maxPos.y = this.min_y;
                canvas.ModelPosToCanvasPos(maxPos, maxPos);
                this._darwRect.x = minPos.x;
                this._darwRect.y = minPos.y;
                this._darwRect.w = maxPos.x - minPos.x;
                this._darwRect.h = maxPos.y - minPos.y;
                this.min_x = this.min_y = Number.MAX_VALUE;
                this.max_x = this.max_y = Number.MAX_VALUE * -1;
            };
            image2D.prototype.updateQuadData = function (x0, y0, x1, y1, x2, y2, x3, y3, quadIndex, mirror) {
                if (quadIndex === void 0) { quadIndex = 0; }
                if (mirror === void 0) { mirror = false; }
                var _index = quadIndex * 6;
                if (!mirror) {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x2;
                    this.datar[(_index + 2) * this._unitLen + 1] = y2;
                    this.datar[(_index + 3) * this._unitLen] = x2;
                    this.datar[(_index + 3) * this._unitLen + 1] = y2;
                    this.datar[(_index + 4) * this._unitLen] = x1;
                    this.datar[(_index + 4) * this._unitLen + 1] = y1;
                    this.datar[(_index + 5) * this._unitLen] = x3;
                    this.datar[(_index + 5) * this._unitLen + 1] = y3;
                }
                else {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x3;
                    this.datar[(_index + 2) * this._unitLen + 1] = y3;
                    this.datar[(_index + 3) * this._unitLen] = x0;
                    this.datar[(_index + 3) * this._unitLen + 1] = y0;
                    this.datar[(_index + 4) * this._unitLen] = x3;
                    this.datar[(_index + 4) * this._unitLen + 1] = y3;
                    this.datar[(_index + 5) * this._unitLen] = x2;
                    this.datar[(_index + 5) * this._unitLen + 1] = y2;
                }
            };
            image2D.prototype.updateSimpleData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
            };
            image2D.prototype.updateSlicedData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var border = this._imageBorder;
                var rect = this._sprite.rect;
                var r1c1 = gd3d.math.pool.new_vector2();
                var r1c4 = gd3d.math.pool.new_vector2();
                var r4c1 = gd3d.math.pool.new_vector2();
                var r4c4 = gd3d.math.pool.new_vector2();
                var r1c2 = gd3d.math.pool.new_vector2();
                var r1c3 = gd3d.math.pool.new_vector2();
                var r2c1 = gd3d.math.pool.new_vector2();
                var r3c1 = gd3d.math.pool.new_vector2();
                var r2c2 = gd3d.math.pool.new_vector2();
                var r2c3 = gd3d.math.pool.new_vector2();
                var r2c4 = gd3d.math.pool.new_vector2();
                var r3c2 = gd3d.math.pool.new_vector2();
                var r3c3 = gd3d.math.pool.new_vector2();
                var r3c4 = gd3d.math.pool.new_vector2();
                var r4c2 = gd3d.math.pool.new_vector2();
                var r4c3 = gd3d.math.pool.new_vector2();
                var r1c1_uv = gd3d.math.pool.new_vector2();
                var r1c4_uv = gd3d.math.pool.new_vector2();
                var r4c1_uv = gd3d.math.pool.new_vector2();
                var r4c4_uv = gd3d.math.pool.new_vector2();
                var r1c2_uv = gd3d.math.pool.new_vector2();
                var r1c3_uv = gd3d.math.pool.new_vector2();
                var r2c1_uv = gd3d.math.pool.new_vector2();
                var r3c1_uv = gd3d.math.pool.new_vector2();
                var r2c2_uv = gd3d.math.pool.new_vector2();
                var r2c3_uv = gd3d.math.pool.new_vector2();
                var r2c4_uv = gd3d.math.pool.new_vector2();
                var r3c2_uv = gd3d.math.pool.new_vector2();
                var r3c3_uv = gd3d.math.pool.new_vector2();
                var r3c4_uv = gd3d.math.pool.new_vector2();
                var r4c2_uv = gd3d.math.pool.new_vector2();
                var r4c3_uv = gd3d.math.pool.new_vector2();
                var help1 = gd3d.math.pool.new_vector2();
                var help2 = gd3d.math.pool.new_vector2();
                var help3 = gd3d.math.pool.new_vector2();
                r1c1.x = x0;
                r1c1.y = y0;
                r1c4.x = x1;
                r1c4.y = y1;
                r4c1.x = x2;
                r4c1.y = y2;
                r4c4.x = x3;
                r4c4.y = y3;
                var width = gd3d.math.vec2Distance(r1c1, r1c4);
                var height = gd3d.math.vec2Distance(r1c1, r4c1);
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var l_vertex = (border.l) / this.transform.width;
                var r_vertex = (border.r) / this.transform.width;
                var t_vertex = (border.t) / this.transform.height;
                var b_vertex = (border.b) / this.transform.height;
                var l = (border.l) / rect.w * (urange.y - urange.x);
                var r = (border.r) / rect.w * (urange.y - urange.x);
                var t = (border.t) / rect.h * (vrange.y - vrange.x);
                var b = (border.b) / rect.h * (vrange.y - vrange.x);
                gd3d.math.vec2Subtract(r1c4, r1c1, r1c2);
                gd3d.math.vec2ScaleByNum(r1c2, l_vertex, r1c2);
                gd3d.math.vec2Add(r1c2, r1c1, r1c2);
                gd3d.math.vec2Subtract(r1c1, r1c4, r1c3);
                gd3d.math.vec2ScaleByNum(r1c3, r_vertex, r1c3);
                gd3d.math.vec2Add(r1c3, r1c4, r1c3);
                gd3d.math.vec2Subtract(r4c1, r1c1, r2c1);
                gd3d.math.vec2ScaleByNum(r2c1, t_vertex, r2c1);
                gd3d.math.vec2Add(r2c1, r1c1, r2c1);
                gd3d.math.vec2Subtract(r1c1, r4c1, r3c1);
                gd3d.math.vec2ScaleByNum(r3c1, b_vertex, r3c1);
                gd3d.math.vec2Add(r3c1, r4c1, r3c1);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c3);
                r1c1_uv.x = urange.x;
                r1c1_uv.y = vrange.x;
                r1c2_uv.x = l + urange.x;
                r1c2_uv.y = vrange.x;
                r1c3_uv.x = urange.y - r;
                r1c3_uv.y = vrange.x;
                r1c4_uv.x = urange.y;
                r1c4_uv.y = vrange.x;
                r2c1_uv.x = urange.x;
                r2c1_uv.y = t + vrange.x;
                r2c2_uv.x = l + urange.x;
                r2c2_uv.y = t + vrange.x;
                r2c3_uv.x = urange.y - r;
                r2c3_uv.y = t + vrange.x;
                r2c4_uv.x = urange.y;
                r2c4_uv.y = t + vrange.x;
                r3c1_uv.x = urange.x;
                r3c1_uv.y = vrange.y - b;
                r3c2_uv.x = l + urange.x;
                r3c2_uv.y = vrange.y - b;
                r3c3_uv.x = urange.y - r;
                r3c3_uv.y = vrange.y - b;
                r3c4_uv.x = urange.y;
                r3c4_uv.y = vrange.y - b;
                r4c1_uv.x = urange.x;
                r4c1_uv.y = vrange.y;
                r4c2_uv.x = l + urange.x;
                r4c2_uv.y = vrange.y;
                r4c3_uv.x = urange.y - r;
                r4c3_uv.y = vrange.y;
                r4c4_uv.x = urange.y;
                r4c4_uv.y = vrange.y;
                var vertexs = [r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4];
                var uvs = [r1c1_uv, r1c2_uv, r1c3_uv, r1c4_uv, r2c1_uv, r2c2_uv, r2c3_uv, r2c4_uv, r3c1_uv, r3c2_uv, r3c3_uv, r3c4_uv, r4c1_uv, r4c2_uv, r4c3_uv, r4c4_uv];
                var partVertexs;
                var partUVs;
                for (var i = 0; i < 9; i++) {
                    var r_1 = Math.floor(i / 3);
                    var c = i % 3;
                    partVertexs = [vertexs[0 + c + r_1 * 4], vertexs[1 + c + r_1 * 4], vertexs[4 + c + r_1 * 4], vertexs[5 + c + r_1 * 4]];
                    partUVs = [uvs[0 + c + r_1 * 4], uvs[1 + c + r_1 * 4], uvs[4 + c + r_1 * 4], uvs[5 + c + r_1 * 4]];
                    this.updateQuadData(partVertexs[0].x, partVertexs[0].y, partVertexs[1].x, partVertexs[1].y, partVertexs[2].x, partVertexs[2].y, partVertexs[3].x, partVertexs[3].y, i);
                    this.datar[(0 + i * 6) * this._unitLen + 7] = partUVs[0].x;
                    this.datar[(0 + i * 6) * this._unitLen + 8] = partUVs[0].y;
                    this.datar[(1 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(1 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(2 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(2 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(3 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(3 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(4 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(4 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(5 + i * 6) * this._unitLen + 7] = partUVs[3].x;
                    this.datar[(5 + i * 6) * this._unitLen + 8] = partUVs[3].y;
                    partVertexs.length = 0;
                    partUVs.length = 0;
                }
                gd3d.math.pool.delete_vector2Array(vertexs);
                gd3d.math.pool.delete_vector2Array(uvs);
                gd3d.math.pool.delete_vector2Array([help1, help2, help3]);
            };
            image2D.prototype.updateFilledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var halfu = urange.x + 0.5 * ulen;
                var halfv = vrange.x + 0.5 * vlen;
                switch (this._fillMethod) {
                    case FillMethod.Horizontal:
                    case FillMethod.Vertical:
                    case FillMethod.Radial_90:
                        if (this._fillMethod == FillMethod.Horizontal) {
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x0);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y0);
                            x3 = x3 - (1 - this.fillAmmount) * (x3 - x2);
                            y3 = y3 - (1 - this.fillAmmount) * (y3 - y2);
                            this.datar[1 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[4 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[5 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                        }
                        else if (this._fillMethod == FillMethod.Vertical) {
                            x0 = x0 - (1 - this.fillAmmount) * (x0 - x2);
                            y0 = y0 - (1 - this.fillAmmount) * (y0 - y2);
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x3);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y3);
                            this.datar[0 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[1 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[4 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                        }
                        else if (this._fillMethod == FillMethod.Radial_90) {
                            if (this.fillAmmount >= 0.5) {
                                var _fillRate = 2 * (1 - this.fillAmmount);
                                x0 = x0 - _fillRate * (x0 - x1);
                                y0 = y0 - _fillRate * (y0 - y1);
                                this.datar[0 * this._unitLen + 7] = urange.x + _fillRate * ulen;
                                this.datar[1 * this._unitLen + 8] = vrange.x;
                                this.datar[4 * this._unitLen + 8] = vrange.x;
                            }
                            else {
                                var _fillRate = 2 * (0.5 - this.fillAmmount);
                                x1 = x1 - _fillRate * (x1 - x3);
                                y1 = y1 - _fillRate * (y1 - y3);
                                x0 = x1;
                                y0 = y1;
                                this.datar[0 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[1 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[4 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            }
                        }
                        this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case FillMethod.Radial_180:
                        var tx = (x0 + x1) / 2;
                        var ty = (y0 + y1) / 2;
                        var bx = (x2 + x3) / 2;
                        var by = (y2 + y3) / 2;
                        if (this.fillAmmount >= 0.75) {
                            var _fillRate = 4 * (1 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - x0);
                            y2 = y2 - _fillRate * (y2 - y0);
                            this.datar[5 * this._unitLen + 8] = vrange.y - _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 4 * (0.75 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - tx);
                            y0 = y0 - _fillRate * (y0 - ty);
                            x2 = x0;
                            y2 = y0;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 4 * (0.5 - this.fillAmmount);
                            tx = tx - _fillRate * (tx - x1);
                            ty = ty - _fillRate * (ty - y1);
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * ulen * _fillRate;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else {
                            var _fillRate = 4 * (0.25 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - x3);
                            y1 = y1 - _fillRate * (y1 - y3);
                            tx = x1;
                            ty = y1;
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[7 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                        }
                        this.updateQuadData(x0, y0, tx, ty, x2, y2, bx, by, 0, true);
                        this.updateQuadData(tx, ty, x1, y1, bx, by, x3, y3, 1);
                        break;
                    case FillMethod.Radial_360:
                        var t_x = (x0 + x1) / 2;
                        var t_y = (y0 + y1) / 2;
                        var l_x = (x0 + x2) / 2;
                        var l_y = (y0 + y2) / 2;
                        var b_x = (x2 + x3) / 2;
                        var b_y = (y2 + y3) / 2;
                        var r_x = (x1 + x3) / 2;
                        var r_y = (y1 + y3) / 2;
                        var c_x = (l_x + r_x) / 2;
                        var c_y = (l_y + r_y) / 2;
                        var b_x1 = b_x;
                        var b_y1 = b_y;
                        if (this.fillAmmount >= 0.875) {
                            var _fillRate = 8 * (1 - this.fillAmmount);
                            b_x = b_x - _fillRate * (b_x - x2);
                            b_y = b_y - _fillRate * (b_y - y2);
                            this.datar[17 * this._unitLen + 7] = halfu - 0.5 * _fillRate * ulen;
                            this.datar[14 * this._unitLen + 8] = vrange.y;
                            this.datar[15 * this._unitLen + 8] = vrange.y;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.75) {
                            var _fillRate = 8 * (0.875 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - l_x);
                            y2 = y2 - _fillRate * (y2 - l_y);
                            b_x = x2;
                            b_y = y2;
                            this.datar[14 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[15 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.625) {
                            var _fillRate = 8 * (0.75 - this.fillAmmount);
                            l_x = l_x - _fillRate * (l_x - x0);
                            l_y = l_y - _fillRate * (l_y - y0);
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[5 * this._unitLen + 8] = halfv - 0.5 * _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 8 * (0.625 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - t_x);
                            y0 = y0 - _fillRate * (y0 - t_y);
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.375) {
                            var _fillRate = 8 * (0.5 - this.fillAmmount);
                            t_x = t_x - _fillRate * (t_x - x1);
                            t_y = t_y - _fillRate * (t_y - y1);
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * _fillRate * ulen;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 8 * (0.375 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - r_x);
                            y1 = y1 - _fillRate * (y1 - r_y);
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[7 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.125) {
                            var _fillRate = 8 * (0.25 - this.fillAmmount);
                            r_x = r_x - _fillRate * (r_x - x3);
                            r_y = r_y - _fillRate * (r_y - y3);
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[19 * this._unitLen + 8] = halfv + 0.5 * _fillRate * vlen;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else {
                            var _fillRate = 8 * (0.125 - this.fillAmmount);
                            x3 = x3 - _fillRate * (x3 - b_x);
                            y3 = y3 - _fillRate * (y3 - b_y);
                            r_x = x3;
                            r_y = y3;
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[20 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                            this.datar[22 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                        }
                        this.updateQuadData(x0, y0, t_x, t_y, l_x, l_y, c_x, c_y, 0, true);
                        this.updateQuadData(t_x, t_y, x1, y1, c_x, c_y, r_x, r_y, 1);
                        this.updateQuadData(l_x, l_y, c_x, c_y, x2, y2, b_x, b_y, 2);
                        this.updateQuadData(c_x, c_y, r_x, r_y, b_x1, b_y1, x3, y3, 3, true);
                        break;
                }
            };
            image2D.prototype.updateTiledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var rect = this._sprite.rect;
                var border = this._imageBorder;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var xlen = x1 - x0;
                var ylen = y2 - y0;
                var _ul = this.transform.width / rect.w;
                var _vl = this.transform.height / rect.h;
                var inv_ul = 1 / _ul;
                var inv_vl = 1 / _vl;
                var dindex = 0;
                for (var i = 0; i < _vl - 1; i++) {
                    for (var j = 0; j < _ul - 1; j++) {
                        var tdata = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        this.datar = this.datar.concat(tdata);
                        var tx0 = x0 + inv_ul * xlen * j;
                        var ty0 = y0 + inv_vl * ylen * i;
                        var tx1 = x0 + inv_ul * xlen * (j + 1);
                        var ty1 = y0 + inv_vl * ylen * i;
                        var tx2 = x0 + inv_ul * xlen * j;
                        var ty2 = y0 + inv_vl * ylen * (i + 1);
                        var tx3 = x0 + inv_ul * xlen * (j + 1);
                        var ty3 = y0 + inv_vl * ylen * (i + 1);
                        this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                        dindex++;
                    }
                }
                var intvl = Math.ceil(_vl) - 1;
                var tvl = _vl - Math.ceil(_vl) + 1;
                for (var j = 0; j < _ul - 1; j++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * j;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (j + 1);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * j;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (j + 1);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                var intul = Math.ceil(_ul) - 1;
                var tul = _ul - Math.ceil(_ul) + 1;
                for (var i = 0; i < _vl - 1; i++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.y, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * i;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * i;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (i + 1);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (i + 1);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
            };
            var image2D_1;
            image2D.ClassName = "image2D";
            image2D.defUIShader = "shader/defui";
            image2D.defMaskUIShader = "shader/defmaskui";
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color)
            ], image2D.prototype, "color", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("enum"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "imageType", null);
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("enum"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "fillMethod", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "fillAmmount", null);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], image2D.prototype, "_spriteName", void 0);
            __decorate([
                gd3d.reflect.Field("border"),
                __metadata("design:type", Object)
            ], image2D.prototype, "_imageBorder", void 0);
            image2D = image2D_1 = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeRender,
                __metadata("design:paramtypes", [])
            ], image2D);
            return image2D;
        }());
        framework.image2D = image2D;
        var ImageType;
        (function (ImageType) {
            ImageType[ImageType["Simple"] = 0] = "Simple";
            ImageType[ImageType["Sliced"] = 1] = "Sliced";
            ImageType[ImageType["Tiled"] = 2] = "Tiled";
            ImageType[ImageType["Filled"] = 3] = "Filled";
        })(ImageType = framework.ImageType || (framework.ImageType = {}));
        var FillMethod;
        (function (FillMethod) {
            FillMethod[FillMethod["Horizontal"] = 0] = "Horizontal";
            FillMethod[FillMethod["Vertical"] = 1] = "Vertical";
            FillMethod[FillMethod["Radial_90"] = 2] = "Radial_90";
            FillMethod[FillMethod["Radial_180"] = 3] = "Radial_180";
            FillMethod[FillMethod["Radial_360"] = 4] = "Radial_360";
        })(FillMethod = framework.FillMethod || (framework.FillMethod = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var inputField = (function () {
            function inputField() {
                this.customRegexStr = "";
                this.beFocus = false;
                this._text = "";
                this._charlimit = 0;
                this._lineType = lineType.SingleLine;
                this._contentType = contentType.None;
            }
            Object.defineProperty(inputField.prototype, "frameImage", {
                get: function () {
                    return this._frameImage;
                },
                set: function (frameImg) {
                    this._frameImage = frameImg;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "text", {
                get: function () {
                    return this._text;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "characterLimit", {
                get: function () { return this._charlimit; },
                set: function (charlimit) {
                    this._charlimit = parseInt("" + charlimit);
                    this._charlimit = isNaN(this._charlimit) || this._charlimit < 0 ? 0 : this._charlimit;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "LineType", {
                get: function () { return this._lineType; },
                set: function (lineType) {
                    this._lineType = lineType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "ContentType", {
                get: function () { return this._contentType; },
                set: function (contentType) {
                    this._contentType = contentType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "TextLabel", {
                get: function () {
                    return this._textLable;
                },
                set: function (textLabel) {
                    textLabel.text = this._text;
                    this._textLable = textLabel;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "PlaceholderLabel", {
                get: function () {
                    return this._placeholderLabel;
                },
                set: function (placeholderLabel) {
                    if (placeholderLabel.text == null || placeholderLabel.text == "")
                        placeholderLabel.text = "Enter Text...";
                    this._placeholderLabel = placeholderLabel;
                },
                enumerable: true,
                configurable: true
            });
            inputField.prototype.layoutRefresh = function () {
                this.inputElmLayout();
                if (this._placeholderLabel) {
                    if (this._placeholderLabel.transform.width != this.transform.width)
                        this._placeholderLabel.transform.width = this.transform.width;
                    if (this._placeholderLabel.transform.height != this.transform.height)
                        this._placeholderLabel.transform.height = this.transform.height;
                }
                if (this._textLable) {
                    if (this._textLable.transform.width != this.transform.width)
                        this._textLable.transform.width = this.transform.width;
                    if (this._textLable.transform.height != this.transform.height)
                        this._textLable.transform.height = this.transform.height;
                }
            };
            inputField.prototype.start = function () {
                var _this = this;
                this.inputElement = document.createElement("Input");
                this.inputElement.style.opacity = "0";
                this.inputElement.style.visibility = "hidden";
                if (this.transform.canvas.scene) {
                    var htmlCanv = this.transform.canvas.scene.webgl.canvas;
                    if (htmlCanv)
                        htmlCanv.parentElement.appendChild(this.inputElement);
                }
                this.inputElement.onblur = function (e) {
                    _this.beFocus = false;
                };
                this.inputElement.onfocus = function (e) {
                    _this.beFocus = true;
                };
                this.inputElmLayout();
            };
            inputField.prototype.onPlay = function () {
            };
            inputField.prototype.inputElmLayout = function () {
                if (this.inputElement == null)
                    return;
                var pos = this.transform.getWorldTranslate();
                var cssStyle = this.inputElement.style;
                if (pos.x + "px" == cssStyle.left && pos.y + "px" == cssStyle.top && this.transform.width + "px" == cssStyle.width && this.transform.height + "px" == cssStyle.height)
                    return;
                var scale = this.transform.canvas.scene.app.canvasClientHeight / this.transform.canvas.pixelHeight;
                cssStyle.position = "absolute";
                cssStyle.left = pos.x * scale + "px";
                cssStyle.top = pos.y * scale + "px";
                cssStyle.width = this.transform.width * scale + "px";
                cssStyle.height = this.transform.height * scale + "px";
            };
            inputField.prototype.textRefresh = function () {
                if (!this.beFocus || !this._textLable || !this._placeholderLabel || !this.inputElement || this._text == this.inputElement.value)
                    return;
                if (this._charlimit > 0 && this.inputElement.value.length >= this._charlimit) {
                    if (this.inputElement.value != this._text)
                        if (this.inputElement.value.length > this._text.length) {
                            this.inputElement.value = this._text;
                        }
                        else {
                            this._text = this.inputElement.value;
                        }
                    return;
                }
                this._text = this.inputElement.value;
                if (this._contentType == contentType.Custom) {
                    if (this.customRegexStr != null && this.customRegexStr != "")
                        this._text = this._text.replace(this.customRegexStr, '');
                }
                else {
                    if (this._contentType == contentType.None) {
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/^[\u4E00-\u9FA5a-zA-Z0-9_]{3,20}$/ig, '');
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/[^\w\.\/]/ig, '');
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z0-9)]/ig, '');
                    }
                    else if ((this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z\u4E00-\u9FA5)]/ig, '');
                    }
                    else if (this._contentType == contentType.Number) {
                        this._text = this._text.replace(/\D+/g, '');
                    }
                    else if (this._contentType == contentType.ChineseCharacter) {
                        this._text = this._text.replace(/[^\u4E00-\u9FA5]/g, '');
                    }
                }
                this.inputElement.value = this._text;
                if (this._textLable) {
                    this._textLable.text = this._text;
                    if (this.ContentType == contentType.PassWord)
                        this._textLable.text = this._textLable.text.replace(/(.\**)/g, "*");
                    this.filterContentText();
                }
                if (this._text == "") {
                    this._placeholderLabel.transform.visible = true;
                    this._textLable.transform.visible = false;
                }
                else {
                    this._placeholderLabel.transform.visible = false;
                    this._textLable.transform.visible = true;
                }
            };
            inputField.prototype.filterContentText = function () {
                if (!this._textLable || this._text == null)
                    return;
                var lab = this._textLable;
                var rate = lab.fontsize / lab.font.lineHeight;
                var font = lab.font;
                var addw = 0;
                var addh = 0;
                var str = "";
                switch (this._lineType) {
                    case lineType.SingleLine:
                        for (var i = lab.text.length - 1; i >= 0; i--) {
                            var c = lab.text.charAt(i);
                            var cinfo = font.cmap[c];
                            if (!cinfo) {
                                console.warn("can't find character \"" + c + "\" in " + font.getName() + " Font");
                                continue;
                            }
                            addw += cinfo.xAddvance * rate;
                            if (addw > lab.transform.width) {
                                lab.text = str;
                                break;
                            }
                            str = lab.text[i] + str;
                        }
                        break;
                    case lineType.MultiLine:
                        var fristline = true;
                        addh += lab.fontsize * lab.linespace;
                        for (var i = lab.text.length - 1; i >= 0; i--) {
                            var c = lab.text.charAt(i);
                            var cinfo = font.cmap[c];
                            if (!cinfo) {
                                console.warn("can't find character \"" + c + "\" in " + font.getName() + " Font");
                                continue;
                            }
                            addw += cinfo.xAddvance * rate;
                            if (addw > lab.transform.width) {
                                addw = 0;
                                fristline = false;
                                addh += lab.fontsize * lab.linespace;
                            }
                            if (!fristline && addh > lab.transform.height) {
                                lab.text = str;
                                break;
                            }
                            str = lab.text[i] + str;
                        }
                        break;
                }
            };
            inputField.prototype.update = function (delta) {
                this.layoutRefresh();
                this.textRefresh();
            };
            inputField.prototype.remove = function () {
                this._placeholderLabel = null;
                this._textLable = null;
                this.transform = null;
                this._frameImage = null;
                if (this.inputElement) {
                    this.inputElement.disabled = false;
                    this.inputElement.value = "";
                    this.inputElement.style.visibility = "hidden";
                    if (this.inputElement.parentElement)
                        this.inputElement.parentElement.removeChild(this.inputElement);
                    this.inputElement = null;
                }
            };
            inputField.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    if (ev.type != gd3d.event.PointEventEnum.PointDown)
                        return;
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        this.inputElement.style.visibility = "visible";
                        this.inputElement.focus();
                    }
                    else {
                        if (this.beFocus)
                            this.inputElement.blur();
                        if (this.inputElement.style.visibility != "hidden")
                            this.inputElement.style.visibility = "hidden";
                    }
                }
            };
            inputField.ClassName = "inputField";
            __decorate([
                gd3d.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], inputField.prototype, "frameImage", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "characterLimit", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "LineType", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "ContentType", null);
            __decorate([
                gd3d.reflect.Field("reference", null, "label"),
                __metadata("design:type", framework.label),
                __metadata("design:paramtypes", [framework.label])
            ], inputField.prototype, "TextLabel", null);
            __decorate([
                gd3d.reflect.Field("reference", null, "label"),
                __metadata("design:type", framework.label),
                __metadata("design:paramtypes", [framework.label])
            ], inputField.prototype, "PlaceholderLabel", null);
            inputField = __decorate([
                gd3d.reflect.node2DComponent
            ], inputField);
            return inputField;
        }());
        framework.inputField = inputField;
        var lineType;
        (function (lineType) {
            lineType[lineType["SingleLine"] = 0] = "SingleLine";
            lineType[lineType["MultiLine"] = 1] = "MultiLine";
        })(lineType = framework.lineType || (framework.lineType = {}));
        var contentType;
        (function (contentType) {
            contentType[contentType["None"] = 0] = "None";
            contentType[contentType["Number"] = 1] = "Number";
            contentType[contentType["Word"] = 2] = "Word";
            contentType[contentType["Underline"] = 4] = "Underline";
            contentType[contentType["ChineseCharacter"] = 8] = "ChineseCharacter";
            contentType[contentType["NoneChineseCharacter"] = 16] = "NoneChineseCharacter";
            contentType[contentType["Email"] = 32] = "Email";
            contentType[contentType["PassWord"] = 64] = "PassWord";
            contentType[contentType["Custom"] = 128] = "Custom";
        })(contentType = framework.contentType || (framework.contentType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var label = (function () {
            function label() {
                this.needRefreshFont = false;
                this._fontName = "defFont";
                this._fontsize = 14;
                this.linespace = 1;
                this.horizontalType = HorizontalType.Left;
                this.verticalType = VerticalType.Center;
                this.horizontalOverflow = false;
                this.verticalOverflow = false;
                this.indexarr = [];
                this.remainarrx = [];
                this.data_begin = new gd3d.math.vector2(0, 0);
                this.datar = [];
                this.color = new gd3d.math.color(1, 1, 1, 1);
                this.color2 = new gd3d.math.color(0, 0, 0.5, 0.5);
                this._CustomShaderName = "";
                this._darwRect = new gd3d.math.rect();
                this.dirtyData = true;
                this.min_x = Number.MAX_VALUE;
                this.max_x = Number.MAX_VALUE * -1;
                this.min_y = Number.MAX_VALUE;
                this.max_y = Number.MAX_VALUE * -1;
            }
            label_1 = label;
            Object.defineProperty(label.prototype, "text", {
                get: function () {
                    return this._text;
                },
                set: function (text) {
                    text = text == null ? "" : text;
                    this._text = text;
                    this.initdater();
                    this.dirtyData = true;
                },
                enumerable: true,
                configurable: true
            });
            label.prototype.initdater = function () {
                var cachelen = 6 * 13 * this._text.length;
                this.datar.splice(0, this.datar.length);
                while (this.datar.length < cachelen) {
                    this.datar.push(0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
                }
                while (this.datar.length < cachelen) {
                    this.datar.pop();
                }
            };
            Object.defineProperty(label.prototype, "font", {
                get: function () {
                    return this._font;
                },
                set: function (font) {
                    if (font == this._font)
                        return;
                    this.needRefreshFont = true;
                    if (this._font) {
                        this._font.unuse();
                    }
                    this._font = font;
                    if (font) {
                        this._font.use();
                        this._fontName = this._font.getName();
                    }
                    else {
                        this._fontName = "";
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(label.prototype, "fontsize", {
                get: function () {
                    return this._fontsize;
                },
                set: function (size) {
                    this._fontsize = size;
                },
                enumerable: true,
                configurable: true
            });
            label.prototype.updateData = function (_font) {
                this.dirtyData = false;
                var rate = this._fontsize / _font.lineHeight;
                var m = this.transform.getWorldMatrix();
                var m11 = m.rawData[0];
                var m12 = m.rawData[2];
                var m21 = m.rawData[1];
                var m22 = m.rawData[3];
                var bx = this.data_begin.x;
                var by = this.data_begin.y;
                var txadd = 0;
                var tyadd = 0;
                this.indexarr = [];
                this.remainarrx = [];
                var remainy = 0;
                tyadd += this._fontsize * this.linespace;
                var contrast_w = this.horizontalOverflow ? Number.MAX_VALUE : this.transform.width;
                var contrast_h = this.verticalOverflow ? Number.MAX_VALUE : this.transform.height;
                for (var i = 0; i < this._text.length; i++) {
                    var c = this._text.charAt(i);
                    var isNewline = c == "\n";
                    var cinfo = _font.cmap[c];
                    if (!isNewline && cinfo == undefined) {
                        continue;
                    }
                    if (isNewline || txadd + cinfo.xAddvance * rate > contrast_w) {
                        if (tyadd + this._fontsize * this.linespace > contrast_h) {
                            break;
                        }
                        else {
                            this.indexarr.push(i);
                            this.remainarrx.push(this.transform.width - txadd);
                            txadd = 0;
                            tyadd += this._fontsize * this.linespace;
                        }
                    }
                    if (cinfo)
                        txadd += cinfo.xAddvance * rate;
                }
                this.indexarr.push(i);
                this.remainarrx.push(this.transform.width - txadd);
                remainy = this.transform.height - tyadd;
                var i = 0;
                var xadd = 0;
                var yadd = 0;
                if (this.verticalType == VerticalType.Center) {
                    yadd += remainy / 2;
                }
                else if (this.verticalType == VerticalType.Boom) {
                    yadd += remainy;
                }
                this.initdater();
                for (var arri = 0; arri < this.indexarr.length; arri++) {
                    xadd = 0;
                    if (this.horizontalType == HorizontalType.Center) {
                        xadd += this.remainarrx[arri] / 2;
                    }
                    else if (this.horizontalType == HorizontalType.Right) {
                        xadd += this.remainarrx[arri];
                    }
                    for (; i < this.indexarr[arri]; i++) {
                        var c = this._text.charAt(i);
                        var cinfo = _font.cmap[c];
                        if (cinfo == undefined) {
                            continue;
                        }
                        var cx = xadd + cinfo.xOffset * rate;
                        var cy = yadd - cinfo.yOffset * rate + _font.baseline * rate;
                        var ch = rate * cinfo.ySize;
                        var cw = rate * cinfo.xSize;
                        xadd += cinfo.xAddvance * rate;
                        var x1 = cx + cw;
                        var y1 = cy;
                        var x2 = cx;
                        var y2 = cy + ch;
                        var x3 = cx + cw;
                        var y3 = cy + ch;
                        var _x0 = this.datar[i * 6 * 13 + 0] = bx + cx * m11 + cy * m12;
                        var _y0 = this.datar[i * 6 * 13 + 1] = by + cx * m21 + cy * m22;
                        var _x1 = this.datar[i * 6 * 13 + 13 * 1 + 0] = bx + x1 * m11 + y1 * m12;
                        var _y1 = this.datar[i * 6 * 13 + 13 * 1 + 1] = by + x1 * m21 + y1 * m22;
                        var _x2 = this.datar[i * 6 * 13 + 13 * 2 + 0] = bx + x2 * m11 + y2 * m12;
                        var _y2 = this.datar[i * 6 * 13 + 13 * 2 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 3 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 3 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 4 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 4 + 1] = by + x1 * m21 + y1 * m22;
                        var _x3 = this.datar[i * 6 * 13 + 13 * 5 + 0] = bx + x3 * m11 + y3 * m12;
                        var _y3 = this.datar[i * 6 * 13 + 13 * 5 + 1] = by + x3 * m21 + y3 * m22;
                        var u0 = cinfo.x;
                        var v0 = cinfo.y;
                        var u1 = cinfo.x + cinfo.w;
                        var v1 = cinfo.y;
                        var u2 = cinfo.x;
                        var v2 = cinfo.y + cinfo.h;
                        var u3 = cinfo.x + cinfo.w;
                        var v3 = cinfo.y + cinfo.h;
                        this.datar[i * 6 * 13 + 7] = u0;
                        this.datar[i * 6 * 13 + 8] = v0;
                        this.datar[i * 6 * 13 + 13 * 1 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 1 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 2 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 2 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 3 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 3 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 4 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 4 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 5 + 7] = u3;
                        this.datar[i * 6 * 13 + 13 * 5 + 8] = v3;
                        for (var j = 0; j < 6; j++) {
                            this.datar[i * 6 * 13 + 13 * j + 3] = this.color.r;
                            this.datar[i * 6 * 13 + 13 * j + 4] = this.color.g;
                            this.datar[i * 6 * 13 + 13 * j + 5] = this.color.b;
                            this.datar[i * 6 * 13 + 13 * j + 6] = this.color.a;
                            this.datar[i * 6 * 13 + 13 * j + 9] = this.color2.r;
                            this.datar[i * 6 * 13 + 13 * j + 10] = this.color2.g;
                            this.datar[i * 6 * 13 + 13 * j + 11] = this.color2.b;
                            this.datar[i * 6 * 13 + 13 * j + 12] = this.color2.a;
                        }
                        this.min_x = Math.min(_x0, _x1, _x2, _x3, this.min_x);
                        this.min_y = Math.min(_y0, _y1, _y2, _y3, this.min_y);
                        this.max_x = Math.max(_x0, _x1, _x2, _x3, this.max_x);
                        this.max_y = Math.max(_y0, _y1, _y2, _y3, this.max_y);
                    }
                    yadd += this._fontsize * this.linespace;
                }
                this.calcDrawRect();
            };
            label.prototype.setShaderByName = function (shaderName) {
                this._CustomShaderName = shaderName;
            };
            label.prototype.getMaterial = function () {
                if (!this._uimat) {
                    return this.uimat;
                }
                return this._uimat;
            };
            label.prototype.getDrawBounds = function () {
                return this._darwRect;
            };
            Object.defineProperty(label.prototype, "uimat", {
                get: function () {
                    var assetmgr = this.transform.canvas.assetmgr;
                    if (!assetmgr)
                        return this._uimat;
                    this.searchTexture();
                    if (this.font && this.font.texture) {
                        var pMask = this.transform.parentIsMask;
                        var mat = this._uimat;
                        var rectTag = "";
                        var uiTag = "_ui";
                        if (pMask) {
                            var prect = this.transform.maskRect;
                            rectTag = "mask(" + prect.x + "_" + prect.y + "_" + prect.w + "_" + prect.h + ")";
                        }
                        var matName = this.font.texture.getName() + uiTag + rectTag;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (!mat) {
                            mat = new framework.material(matName);
                            var sh = assetmgr.getShader(this._CustomShaderName);
                            sh = sh ? sh : assetmgr.getShader(pMask ? label_1.defMaskUIShader : label_1.defUIShader);
                            mat.setShader(sh);
                            mat.use();
                            this.needRefreshFont = true;
                        }
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: true,
                configurable: true
            });
            label.prototype.render = function (canvas) {
                var mat = this.uimat;
                if (!mat)
                    return;
                if (!this._font)
                    return;
                if (this.dirtyData == true) {
                    this.updateData(this._font);
                    this.dirtyData = false;
                }
                var img;
                if (this._font) {
                    img = this._font.texture;
                }
                if (img) {
                    if (this.needRefreshFont) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshFont = false;
                    }
                    if (this.transform.parentIsMask) {
                        if (this._cacheMaskV4 == null)
                            this._cacheMaskV4 = new gd3d.math.vector4();
                        var rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    if (this.datar.length != 0)
                        canvas.pushRawData(mat, this.datar);
                }
            };
            label.prototype.searchTexture = function () {
                if (this._font)
                    return;
                var assetmgr = this.transform.canvas.assetmgr;
                var resName = this._fontName;
                var temp = assetmgr.mapNamed[resName];
                if (temp == undefined) {
                    resName = this._fontName + ".font.json";
                    temp = assetmgr.mapNamed[resName];
                }
                if (temp != null) {
                    var tfont = assetmgr.getAssetByName(resName);
                    if (tfont) {
                        this.font = tfont;
                        this.needRefreshFont = true;
                    }
                }
            };
            label.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var t = -this.transform.pivot.y * this.transform.height;
                this.data_begin.x = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                this.data_begin.y = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                this.dirtyData = true;
            };
            label.prototype.calcDrawRect = function () {
                var canvas = this.transform.canvas;
                if (!canvas)
                    return;
                var minPos = helpv2;
                minPos.x = this.min_x;
                minPos.y = this.max_y;
                canvas.ModelPosToCanvasPos(minPos, minPos);
                var maxPos = helpv2_1;
                maxPos.x = this.max_x;
                maxPos.y = this.min_y;
                canvas.ModelPosToCanvasPos(maxPos, maxPos);
                this._darwRect.x = minPos.x;
                this._darwRect.y = minPos.y;
                this._darwRect.w = maxPos.x - minPos.x;
                this._darwRect.h = maxPos.y - minPos.y;
                this.min_x = this.min_y = Number.MAX_VALUE;
                this.max_x = this.max_y = Number.MAX_VALUE * -1;
            };
            label.prototype.start = function () {
            };
            label.prototype.onPlay = function () {
            };
            label.prototype.update = function (delta) {
            };
            label.prototype.remove = function () {
                if (this._font)
                    this._font.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this.indexarr.length = 0;
                this.remainarrx.length = 0;
                this.datar.length = 0;
                this.transform = null;
                this._cacheMaskV4 = null;
            };
            label.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            var label_1;
            label.ClassName = "label";
            label.defUIShader = "shader/defuifont";
            label.defMaskUIShader = "shader/defmaskfont";
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String),
                __metadata("design:paramtypes", [String])
            ], label.prototype, "text", null);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", Object)
            ], label.prototype, "_fontName", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], label.prototype, "fontsize", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], label.prototype, "linespace", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], label.prototype, "horizontalType", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], label.prototype, "verticalType", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], label.prototype, "horizontalOverflow", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], label.prototype, "verticalOverflow", void 0);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color)
            ], label.prototype, "color", void 0);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color)
            ], label.prototype, "color2", void 0);
            label = label_1 = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeRender
            ], label);
            return label;
        }());
        framework.label = label;
        var HorizontalType;
        (function (HorizontalType) {
            HorizontalType[HorizontalType["Center"] = 0] = "Center";
            HorizontalType[HorizontalType["Left"] = 1] = "Left";
            HorizontalType[HorizontalType["Right"] = 2] = "Right";
        })(HorizontalType = framework.HorizontalType || (framework.HorizontalType = {}));
        var VerticalType;
        (function (VerticalType) {
            VerticalType[VerticalType["Center"] = 0] = "Center";
            VerticalType[VerticalType["Top"] = 1] = "Top";
            VerticalType[VerticalType["Boom"] = 2] = "Boom";
        })(VerticalType = framework.VerticalType || (framework.VerticalType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var progressbar = (function () {
            function progressbar() {
                this._value = 0.6;
            }
            Object.defineProperty(progressbar.prototype, "cutPanel", {
                get: function () {
                    return this._cutPanel;
                },
                set: function (trans) {
                    this._cutPanel = trans;
                    this.refreshBar();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(progressbar.prototype, "barBg", {
                get: function () {
                    return this._barBg;
                },
                set: function (img) {
                    this._barBg = img;
                    this.refreshBar();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(progressbar.prototype, "barOverImg", {
                get: function () {
                    return this._barOverImg;
                },
                set: function (img) {
                    this._barOverImg = img;
                    this.refreshBar();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(progressbar.prototype, "value", {
                get: function () {
                    return this._value;
                },
                set: function (value) {
                    this._value = value < 0 ? 0 : value > 1 ? 1 : value;
                    if (!this._cutPanel || !this._barBg || !this._barBg.transform)
                        return;
                    this._cutPanel.width = this._value * this._barBg.transform.width;
                    this._cutPanel.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            progressbar.prototype.start = function () {
            };
            progressbar.prototype.onPlay = function () {
            };
            progressbar.prototype.update = function (delta) {
                this.adjustOverImg();
            };
            progressbar.prototype.refreshBar = function () {
                this.adjustOverImg();
                this.value = this._value;
            };
            progressbar.prototype.adjustOverImg = function () {
                if (!this._barOverImg || !this._barBg)
                    return;
                var tbg = this._barBg.transform;
                var tover = this._barOverImg.transform;
                if (!tbg || !tover)
                    return;
                if (tbg.width != tover.width) {
                    tover.width = tbg.width;
                    tover.markDirty();
                }
            };
            progressbar.prototype.remove = function () {
                this._barBg = null;
                this._barOverImg = null;
                this._cutPanel = null;
            };
            progressbar.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            progressbar.ClassName = "progressbar";
            __decorate([
                gd3d.reflect.Field("reference", null, "transform2D"),
                __metadata("design:type", framework.transform2D),
                __metadata("design:paramtypes", [framework.transform2D])
            ], progressbar.prototype, "cutPanel", null);
            __decorate([
                gd3d.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], progressbar.prototype, "barBg", null);
            __decorate([
                gd3d.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], progressbar.prototype, "barOverImg", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], progressbar.prototype, "value", null);
            progressbar = __decorate([
                gd3d.reflect.node2DComponent
            ], progressbar);
            return progressbar;
        }());
        framework.progressbar = progressbar;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var rawImage2D = (function () {
            function rawImage2D() {
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
                this._CustomShaderName = "";
                this._darwRect = new gd3d.math.rect();
                this.min_x = Number.MAX_VALUE;
                this.max_x = Number.MAX_VALUE * -1;
                this.min_y = Number.MAX_VALUE;
                this.max_y = Number.MAX_VALUE * -1;
            }
            rawImage2D_1 = rawImage2D;
            Object.defineProperty(rawImage2D.prototype, "image", {
                get: function () {
                    return this._image;
                },
                set: function (_image) {
                    if (this._image == _image)
                        return;
                    this.needRefreshImg = true;
                    if (this._image) {
                        this._image.unuse();
                    }
                    this._image = _image;
                    if (_image) {
                        this._image.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            rawImage2D.prototype.setShaderByName = function (shaderName) {
                this._CustomShaderName = shaderName;
            };
            rawImage2D.prototype.getMaterial = function () {
                if (!this._uimat) {
                    return this.uimat;
                }
                return this._uimat;
            };
            rawImage2D.prototype.getDrawBounds = function () {
                return this._darwRect;
            };
            Object.defineProperty(rawImage2D.prototype, "uimat", {
                get: function () {
                    if (this._image) {
                        var assetmgr = this.transform.canvas.assetmgr;
                        if (!assetmgr)
                            return this._uimat;
                        var pMask = this.transform.parentIsMask;
                        var mat = this._uimat;
                        var rectTag = "";
                        var uiTag = "_ui";
                        if (pMask) {
                            var prect = this.transform.maskRect;
                            rectTag = "mask(" + prect.x + "_" + prect.y + "_" + prect.w + "_" + prect.h + ")";
                        }
                        var matName = this._image.getName() + uiTag + rectTag;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (!mat) {
                            mat = new framework.material(matName);
                            var sh = assetmgr.getShader(this._CustomShaderName);
                            sh = sh ? sh : assetmgr.getShader(pMask ? rawImage2D_1.defMaskUIShader : rawImage2D_1.defUIShader);
                            mat.setShader(sh);
                            mat.use();
                            this.needRefreshImg = true;
                        }
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: true,
                configurable: true
            });
            rawImage2D.prototype.render = function (canvas) {
                var mat = this.uimat;
                if (!mat)
                    return;
                var img = this.image;
                if (img != null) {
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                    }
                    if (this.transform.parentIsMask) {
                        if (this._cacheMaskV4 == null)
                            this._cacheMaskV4 = new gd3d.math.vector4();
                        var rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            };
            rawImage2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                this.datar[0 * 13] = x0;
                this.datar[0 * 13 + 1] = y0;
                this.datar[1 * 13] = x1;
                this.datar[1 * 13 + 1] = y1;
                this.datar[2 * 13] = x2;
                this.datar[2 * 13 + 1] = y2;
                this.datar[3 * 13] = x2;
                this.datar[3 * 13 + 1] = y2;
                this.datar[4 * 13] = x1;
                this.datar[4 * 13 + 1] = y1;
                this.datar[5 * 13] = x3;
                this.datar[5 * 13 + 1] = y3;
                for (var i = 0; i < 6; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
                this.min_x = Math.min(x0, x1, x2, x3, this.min_x);
                this.min_y = Math.min(y0, y1, y2, y3, this.min_y);
                this.max_x = Math.max(x0, x1, x2, x3, this.max_x);
                this.max_y = Math.max(y0, y1, y2, y3, this.max_y);
                this.calcDrawRect();
            };
            rawImage2D.prototype.calcDrawRect = function () {
                var canvas = this.transform.canvas;
                if (!canvas)
                    return;
                var minPos = helpv2;
                minPos.x = this.min_x;
                minPos.y = this.max_y;
                canvas.ModelPosToCanvasPos(minPos, minPos);
                var maxPos = helpv2_1;
                maxPos.x = this.max_x;
                maxPos.y = this.min_y;
                canvas.ModelPosToCanvasPos(maxPos, maxPos);
                this._darwRect.x = minPos.x;
                this._darwRect.y = minPos.y;
                this._darwRect.w = maxPos.x - minPos.x;
                this._darwRect.h = maxPos.y - minPos.y;
                this.min_x = this.min_y = Number.MAX_VALUE;
                this.max_x = this.max_y = Number.MAX_VALUE * -1;
            };
            rawImage2D.prototype.start = function () {
            };
            rawImage2D.prototype.onPlay = function () {
            };
            rawImage2D.prototype.update = function (delta) {
            };
            rawImage2D.prototype.remove = function () {
                if (this._image)
                    this._image.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this._image = null;
                this._cacheMaskV4 = null;
                this.transform = null;
                this.datar.length = 0;
            };
            rawImage2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            var rawImage2D_1;
            rawImage2D.ClassName = "rawImage2D";
            rawImage2D.defUIShader = "shader/defui";
            rawImage2D.defMaskUIShader = "shader/defmaskui";
            __decorate([
                gd3d.reflect.Field("texture"),
                __metadata("design:type", framework.texture),
                __metadata("design:paramtypes", [framework.texture])
            ], rawImage2D.prototype, "image", null);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("vector4"),
                __metadata("design:type", gd3d.math.color)
            ], rawImage2D.prototype, "color", void 0);
            rawImage2D = rawImage2D_1 = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeRender
            ], rawImage2D);
            return rawImage2D;
        }());
        framework.rawImage2D = rawImage2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var helpV2 = new gd3d.math.vector2();
        var helpV2_1 = new gd3d.math.vector2();
        var scrollRect = (function () {
            function scrollRect() {
                this.horizontal = true;
                this.vertical = true;
                this.inertia = true;
                this.decelerationRate = 0.135;
                this.isPointDown = false;
                this.lastPoint = new gd3d.math.vector2();
                this.strPoint = new gd3d.math.vector2();
                this.strPos = new gd3d.math.vector2();
                this.collectNum = 3;
                this.points = [];
                this.flyVelocity = new gd3d.math.vector2();
                this.canfly = false;
                this.threshold = 0.01;
                this.cgTime = 0.2;
                this.cgCount = this.cgTime;
                this.lastfv = new gd3d.math.vector2();
            }
            Object.defineProperty(scrollRect.prototype, "content", {
                get: function () {
                    return this._content;
                },
                set: function (content) {
                    this._content = content;
                },
                enumerable: true,
                configurable: true
            });
            scrollRect.prototype.start = function () {
            };
            scrollRect.prototype.onPlay = function () {
            };
            scrollRect.prototype.update = function (delta) {
                this.flyingSlidr(delta);
            };
            scrollRect.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    helpV2.x = ev.x;
                    helpV2.y = ev.y;
                    var b = this.transform.ContainsCanvasPoint(helpV2);
                    if (b) {
                        ev.eated = true;
                        if (this._content == null)
                            return;
                        if (!this.horizontal && !this.vertical)
                            return;
                        var temps = helpV2;
                        var tempc = helpV2_1;
                        this.transform.canvas.ModelPosToCanvasPos(temps, tempc);
                        var sp = this.strPoint;
                        if (ev.type == gd3d.event.PointEventEnum.PointDown) {
                            this.isPointDown = true;
                            sp.x = tempc.x;
                            sp.y = tempc.y;
                            gd3d.math.vec2Clone(this._content.transform.localTranslate, this.strPos);
                            this.canfly = false;
                        }
                        if (ev.type == gd3d.event.PointEventEnum.PointHold && this.isPointDown) {
                            var lp = this.lastPoint;
                            if (lp.x != tempc.x || lp.y != tempc.y) {
                                lp.x = tempc.x;
                                lp.y = tempc.y;
                                var addtransX = lp.x - sp.x;
                                var addtransY = lp.y - sp.y;
                                gd3d.math.vec2Clone(this.strPos, this._content.localTranslate);
                                this.SlideTo(addtransX, addtransY);
                            }
                            if (this.inertia) {
                                this.collectPointing();
                            }
                        }
                    }
                }
                if (ev.type == gd3d.event.PointEventEnum.PointUp) {
                    this.isPointDown = false;
                    if (this.inertia) {
                        this.onInertiaSliderUp();
                    }
                }
            };
            scrollRect.prototype.SlideTo = function (addtransX, addtransY) {
                if (!this._content)
                    return;
                var ctrans = this._content.transform;
                var cpos = ctrans.localTranslate;
                var trans = this.transform;
                if (this.horizontal) {
                    cpos.x += addtransX;
                    if (cpos.x > 0 || ctrans.width <= trans.width)
                        cpos.x = 0;
                    if (ctrans.width > trans.width && cpos.x + ctrans.width < trans.width)
                        cpos.x = -1 * (ctrans.width - trans.width);
                }
                if (this.vertical) {
                    cpos.y += addtransY;
                    if (cpos.y > 0 || ctrans.height <= trans.height)
                        cpos.y = 0;
                    if (ctrans.height > trans.height && cpos.y + ctrans.height < trans.height)
                        cpos.y = -1 * (ctrans.height - trans.height);
                }
                ctrans.markDirty();
            };
            scrollRect.prototype.collectPointing = function () {
                if (!this.isPointDown)
                    return;
                var p = this.lastPoint;
                if (this.points.length > this.collectNum) {
                    var v2 = this.points.shift();
                    gd3d.math.pool.delete_vector2(v2);
                }
                var currpos = gd3d.math.pool.new_vector2(p.x, p.y);
                this.points.push(currpos);
            };
            scrollRect.prototype.onInertiaSliderUp = function () {
                if (this.points.length < 2) {
                    gd3d.math.pool.delete_vector2Array(this.points);
                    return;
                }
                var fv = this.flyVelocity;
                fv.x = fv.y = 0;
                var len = this.points.length;
                for (var i = 1; i < len; i++) {
                    var p_0 = this.points[i - 1];
                    var p_1 = this.points[i];
                    gd3d.math.vec2Subtract(p_1, p_0, helpv2);
                    gd3d.math.vec2Add(helpv2, fv, fv);
                }
                gd3d.math.vec2Clone(this.flyVelocity, this.lastfv);
                gd3d.math.pool.delete_vector2Array(this.points);
                this.canfly = true;
            };
            scrollRect.prototype.flyingSlidr = function (delta) {
                if (!this.canfly || !this.inertia)
                    return;
                var fv = this.flyVelocity;
                this.cgCount += delta;
                if (this.cgCount >= this.cgTime) {
                    gd3d.math.vec2Clone(fv, this.lastfv);
                    gd3d.math.vec2ScaleByNum(fv, this.decelerationRate, fv);
                    this.cgCount = 0;
                }
                if (gd3d.math.vec2Length(fv) < this.threshold) {
                    this.canfly = false;
                    this.cgCount = this.cgTime;
                }
                gd3d.math.vec2SLerp(this.lastfv, fv, this.cgCount / this.cgTime, helpv2);
                this.SlideTo(helpv2.x, helpv2.y);
            };
            scrollRect.prototype.remove = function () {
                this._content = null;
                this.transform = null;
            };
            scrollRect.ClassName = "scrollRect";
            __decorate([
                gd3d.reflect.Field("reference", null, "transform2D"),
                __metadata("design:type", framework.transform2D),
                __metadata("design:paramtypes", [framework.transform2D])
            ], scrollRect.prototype, "content", null);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "horizontal", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "vertical", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "inertia", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], scrollRect.prototype, "decelerationRate", void 0);
            scrollRect = __decorate([
                gd3d.reflect.node2DComponent
            ], scrollRect);
            return scrollRect;
        }());
        framework.scrollRect = scrollRect;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var uirect = (function () {
            function uirect() {
                this.canbeClick = true;
            }
            uirect.prototype.start = function () {
            };
            uirect.prototype.onPlay = function () {
            };
            uirect.prototype.update = function (delta) {
            };
            uirect.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            uirect.prototype.remove = function () {
                this.transform = null;
            };
            uirect.ClassName = "uirect";
            uirect = __decorate([
                gd3d.reflect.node2DComponent
            ], uirect);
            return uirect;
        }());
        framework.uirect = uirect;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var bassBody = (function () {
            function bassBody() {
            }
            bassBody.prototype.addForce = function (Force) {
                framework.physic2D.applyForceAtCenter(this.body, Force);
            };
            bassBody.prototype.setVelocity = function (velocity) {
                framework.physic2D.setVelocity(this.body, velocity);
            };
            bassBody.prototype.setAngularVelocity = function (velocity) {
                framework.physic2D.setAngularVelocity(this.body, velocity);
            };
            Object.defineProperty(bassBody.prototype, "angularVelocity", {
                get: function () {
                    return this.body.angularVelocity;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(bassBody.prototype, "speed", {
                get: function () {
                    return this.body.speed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(bassBody.prototype, "velocity", {
                get: function () {
                    if (this.m_velocity == null)
                        this.m_velocity = new gd3d.math.vector2();
                    this.m_velocity.x = this.body.velocity.x;
                    this.m_velocity.y = this.body.velocity.y;
                    return this.m_velocity;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(bassBody.prototype, "type", {
                get: function () {
                    return this.body.type;
                },
                set: function (value) {
                    this.body.type = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(bassBody.prototype, "collisionFilter", {
                get: function () {
                    return this.body.collisionFilter;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(bassBody.prototype, "tag", {
                get: function () {
                    return this.body.tag;
                },
                set: function (value) {
                    this.body.tag = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(bassBody.prototype, "name", {
                get: function () {
                    return this.body.name;
                },
                set: function (value) {
                    this.body.name = value;
                },
                enumerable: true,
                configurable: true
            });
            bassBody.prototype.setDesity = function (Desity) {
                framework.physic2D.setDesity(this.body, Desity);
            };
            bassBody.prototype.setFrictionAir = function (frictionAir) {
                framework.physic2D.setFrictionAir(this.body, frictionAir);
            };
            bassBody.prototype.setFriction = function (friction) {
                framework.physic2D.setFriction(this.body, friction);
            };
            bassBody.prototype.setFrictionStatic = function (frictionStatic) {
                framework.physic2D.setFrictionStatic(this.body, frictionStatic);
            };
            bassBody.prototype.setRestitution = function (restitution) {
                framework.physic2D.setRestitution(this.body, restitution);
            };
            bassBody.prototype.setMass = function (mass) {
                framework.physic2D.setMass(this.body, mass);
            };
            bassBody.prototype.setInitData = function (att) {
                this.initData = att;
            };
            bassBody.prototype.setPosition = function (pos) {
                framework.physic2D.setPosition(this.body, pos);
            };
            bassBody.prototype.update = function (delta) {
                this.transform.localTranslate.x = this.body.position.x;
                this.transform.localTranslate.y = this.body.position.y;
                this.transform.localRotate = this.body.angle;
                this.transform.markDirty();
            };
            bassBody.prototype.remove = function () {
                framework.physic2D.removeBody(this.body);
            };
            return bassBody;
        }());
        framework.bassBody = bassBody;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var circleBody = (function (_super) {
            __extends(circleBody, _super);
            function circleBody() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.radius = 1;
                return _this;
            }
            circleBody.prototype.start = function () {
                if (this.initData != null) {
                    this.body = framework.physic2D.creatCircleBodyByInitData(this.transform.localTranslate.x, this.transform.localTranslate.y, this.radius, this.initData);
                }
                else {
                    this.body = framework.physic2D.creatCircleBodyByInitData(this.transform.localTranslate.x, this.transform.localTranslate.y, this.radius, {});
                }
            };
            circleBody.prototype.onPlay = function () {
            };
            circleBody.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            circleBody.ClassName = "circleBody";
            circleBody = __decorate([
                gd3d.reflect.node2DComponent
            ], circleBody);
            return circleBody;
        }(framework.bassBody));
        framework.circleBody = circleBody;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var physicEngine2D = (function () {
            function physicEngine2D(op) {
                if (op === void 0) { op = null; }
                if (Matter == undefined) {
                    console.error("2d physic not supportted");
                }
                if (op != null) {
                    this.matterEngine = Matter.Engine.create(op);
                }
                else {
                    this.matterEngine = Matter.Engine.create();
                }
                this.engineWorld = this.matterEngine.world;
                this.matterVector = Matter.Vector;
                Matter.Engine.run(this.matterEngine);
            }
            physicEngine2D.prototype.update = function (delta) {
                Matter.Engine.update(this.matterEngine, delta);
            };
            physicEngine2D.prototype.creatRectBodyByInitData = function (posx, posy, width, height, initData) {
                var body = Matter.Bodies.rectangle(posx, posy, width, height, initData);
                this.addBody(body);
                return body;
            };
            physicEngine2D.prototype.creatCircleBodyByInitData = function (posx, posy, radius, initData) {
                var body = Matter.Bodies.circle(posx, posy, radius, initData);
                this.addBody(body);
                return body;
            };
            physicEngine2D.prototype.addBody = function (body) {
                Matter.World.add(this.engineWorld, body);
            };
            physicEngine2D.prototype.applyForce = function (body, positon, force) {
                Matter.Body.applyForce(body, this.matterVector.create(positon.x, positon.y), this.matterVector.create(force.x, force.y));
            };
            physicEngine2D.prototype.applyForceAtCenter = function (body, force) {
                Matter.Body.applyForce(body, body.position, this.matterVector.create(force.x, force.y));
            };
            physicEngine2D.prototype.setGravity = function (x, y) {
                this.engineWorld.gravity.x = x;
                this.engineWorld.gravity.y = y;
            };
            physicEngine2D.prototype.setVelocity = function (body, velocity) {
                Matter.Body.setVelocity(body, this.matterVector.create(velocity.x, velocity.y));
            };
            physicEngine2D.prototype.setPosition = function (body, pos) {
                Matter.Body.setPosition(body, this.matterVector.create(pos.x, pos.y));
            };
            physicEngine2D.prototype.setMass = function (body, mass) {
                Matter.Body.setMass(body, mass);
            };
            physicEngine2D.prototype.setDesity = function (body, Desity) {
                this.set(body, "desity", Desity);
            };
            physicEngine2D.prototype.setFrictionAir = function (body, frictionAir) {
                this.set(body, "frictionAir", frictionAir);
            };
            physicEngine2D.prototype.setFriction = function (body, friction) {
                this.set(body, "friction", friction);
            };
            physicEngine2D.prototype.setFrictionStatic = function (body, frictionStatic) {
                this.set(body, "frictionStatic", frictionStatic);
            };
            physicEngine2D.prototype.setRestitution = function (body, restitution) {
                this.set(body, "restitution", restitution);
            };
            physicEngine2D.prototype.setAngularVelocity = function (body, angularVelocity) {
                this.set(body, "angularVelocity", angularVelocity);
            };
            physicEngine2D.prototype.set = function (body, settings, value) {
                Matter.Body.set(body, settings, value);
            };
            physicEngine2D.prototype.addEvent = function (eventname, callback) {
                Matter.Events.on(this.matterEngine, eventname, callback);
            };
            physicEngine2D.prototype.removeEvent = function (eventname, callback) {
                Matter.Events.off(this.matterEngine, eventname, callback);
            };
            physicEngine2D.prototype.removeBody = function (body) {
                Matter.World.remove(this.engineWorld, body);
            };
            return physicEngine2D;
        }());
        framework.physicEngine2D = physicEngine2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var rectBody = (function (_super) {
            __extends(rectBody, _super);
            function rectBody() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            rectBody.prototype.start = function () {
                if (this.initData != null) {
                    this.body = framework.physic2D.creatRectBodyByInitData(this.transform.localTranslate.x, this.transform.localTranslate.y, this.transform.width, this.transform.height, this.initData);
                }
                else {
                    this.body = framework.physic2D.creatRectBodyByInitData(this.transform.localTranslate.x, this.transform.localTranslate.y, this.transform.width, this.transform.height, {});
                }
            };
            rectBody.prototype.onPlay = function () {
            };
            rectBody.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            rectBody.ClassName = "rectBody";
            rectBody = __decorate([
                gd3d.reflect.node2DComponent
            ], rectBody);
            return rectBody;
        }(framework.bassBody));
        framework.rectBody = rectBody;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var resID = (function () {
            function resID() {
                this.id = resID.next();
            }
            resID.next = function () {
                var next = resID.idAll;
                resID.idAll++;
                return next;
            };
            resID.prototype.getID = function () {
                return this.id;
            };
            resID.idAll = 1;
            return resID;
        }());
        framework.resID = resID;
        var constText = (function () {
            function constText(text) {
                this.name = text;
            }
            constText.prototype.getText = function () {
                return this.name;
            };
            constText = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], constText);
            return constText;
        }());
        framework.constText = constText;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var assetBundle = (function () {
            function assetBundle(url) {
                this.files = [];
                this.packages = [];
                this.bundlePackBin = {};
                this.totalLength = 0;
                this.loadLightMap = true;
                this.mapNamed = {};
                this.url = url;
                var i = url.lastIndexOf("/");
                this.path = url.substring(0, i);
                this.assetmgr = gd3d.framework.sceneMgr.app.getAssetMgr();
                if (this.assetmgr.waitlightmapScene[url]) {
                    this.loadLightMap = false;
                }
            }
            assetBundle.prototype.loadCompressBundle = function (url, onstate, state, assetmgr) {
                var _this = this;
                state.totalByteLength = this.totalLength;
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    if (err != null) {
                        state.isloadFail = isloadFail ? true : false;
                        state.iserror = true;
                        state.errs.push(new Error(err.message));
                        onstate(state);
                        return;
                    }
                    var json = JSON.parse(txt);
                    _this.bundlePackJson = json;
                    _this.parse(json["bundleinfo"], _this.totalLength);
                    _this.load(assetmgr, onstate, state);
                    assetmgr.mapBundle[_this.name] = _this;
                }, function (loadedLength, totalLength) {
                    state.compressTextLoaded = loadedLength;
                    onstate(state);
                });
            };
            assetBundle.prototype.parse = function (json, totalLength) {
                if (totalLength === void 0) { totalLength = 0; }
                var files = json["files"];
                for (var i = 0; i < files.length; i++) {
                    var item = files[i];
                    var packes = -1;
                    if (item.packes != undefined)
                        packes = item.packes;
                    if (!this.loadLightMap && item.name.indexOf("LightmapFar-") >= 0) {
                        this.assetmgr.waitlightmapScene[this.url].push(this.path + "/" + item.name);
                        continue;
                    }
                    this.files.push({ name: item.name, length: item.length, packes: packes });
                }
                if (json["packes"] != undefined) {
                    var packes = json["packes"];
                    for (var i = 0; i < packes.length; i++) {
                        this.packages.push(packes[i]);
                    }
                }
                else {
                    if (json["totalLength"] != undefined) {
                        if (totalLength == 0) {
                            this.totalLength = json["totalLength"];
                        }
                    }
                }
            };
            assetBundle.prototype.unload = function () {
                for (var key in this.mapNamed) {
                    var asset = this.assetmgr.getAssetByName(key, this.name);
                    if (asset) {
                        this.assetmgr.unuse(asset);
                    }
                }
                this.assetmgr.removeAssetBundle(this.name);
            };
            assetBundle.prototype.load = function (assetmgr, onstate, state) {
                var _this = this;
                state.totalByteLength = this.totalLength;
                var total = this.files.length;
                this.assetmgr = assetmgr;
                var glvshaders = [];
                var glfshaders = [];
                var shaders = [];
                var meshs = [];
                var textures = [];
                var texturedescs = [];
                var materials = [];
                var anclips = [];
                var prefabs = [];
                var scenes = [];
                var textassets = [];
                var pvrs = [];
                var packs = [];
                var f14effs = [];
                var fonts = [];
                var atlass = [];
                var ddss = [];
                var kfaniclips = [];
                var asslist = [];
                asslist.push(packs, glvshaders, glfshaders, shaders, textassets, meshs, textures, pvrs, ddss, texturedescs, fonts, atlass, materials, anclips, kfaniclips, f14effs, prefabs, scenes);
                var mapPackes = {};
                for (var _i = 0, _a = this.packages; _i < _a.length; _i++) {
                    var pack = _a[_i];
                    var type = assetmgr.calcType(pack);
                    var url = this.path + "/" + pack;
                    packs.push({ url: url, type: type, asset: null });
                }
                for (var _b = 0, _c = this.files; _b < _c.length; _b++) {
                    var fitem = _c[_b];
                    var type = assetmgr.calcType(fitem.name);
                    var url = this.path + "/" + fitem.name;
                    var fileName = assetmgr.getFileName(url);
                    if (fitem.packes != -1) {
                        mapPackes[url] = fitem.packes;
                    }
                    {
                        var asset = null;
                        switch (type) {
                            case framework.AssetTypeEnum.GLFragmentShader:
                                glfshaders.push({ url: url, type: type, asset: null });
                                break;
                            case framework.AssetTypeEnum.GLVertexShader:
                                glvshaders.push({ url: url, type: type, asset: null });
                                break;
                            case framework.AssetTypeEnum.Shader:
                                asset = new framework.shader(fileName);
                                shaders.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Texture:
                                asset = new framework.texture(fileName);
                                textures.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.TextureDesc:
                                asset = new framework.texture(fileName);
                                texturedescs.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Mesh:
                                asset = new framework.mesh(fileName);
                                meshs.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Material:
                                asset = new framework.material(fileName);
                                materials.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Aniclip:
                                asset = new framework.animationClip(fileName);
                                anclips.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Prefab:
                                asset = new framework.prefab(fileName);
                                prefabs.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Scene:
                                asset = new framework.rawscene(fileName);
                                scenes.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.TextAsset:
                                asset = new framework.textasset(fileName);
                                textassets.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.PVR:
                                asset = new framework.texture(fileName);
                                pvrs.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.F14Effect:
                                asset = new framework.f14eff(fileName);
                                f14effs.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.DDS:
                                asset = new framework.texture(fileName);
                                ddss.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Font:
                                asset = new framework.font(fileName);
                                fonts.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.Atlas:
                                asset = new framework.atlas(fileName);
                                atlass.push({ url: url, type: type, asset: asset });
                                break;
                            case framework.AssetTypeEnum.KeyFrameAniclip:
                                asset = new framework.keyFrameAniClip(fileName);
                                kfaniclips.push({ url: url, type: type, asset: asset });
                                break;
                        }
                        if (type != framework.AssetTypeEnum.GLVertexShader && type != framework.AssetTypeEnum.GLFragmentShader && type != framework.AssetTypeEnum.Shader
                            && type != framework.AssetTypeEnum.PackBin && type != framework.AssetTypeEnum.PackTxt && type != framework.AssetTypeEnum.Prefab) {
                            if (!asset)
                                continue;
                            this.mapNamed[fileName] = asset.getGUID();
                            assetmgr.regRes(fileName, asset);
                        }
                    }
                }
                var list = [];
                var handles = {};
                for (var i = 0, len = asslist.length; i < len; ++i) {
                    for (var j = 0, clen = asslist[i].length; j < clen; ++j) {
                        var item = asslist[i][j];
                        handles[item.url] = list.length;
                        list.push({ url: item.url, type: item.type, asset: item.asset, handle: undefined });
                    }
                }
                var packlist = [];
                var haveBin = false;
                var tempMap = {};
                var _loop_2 = function (item) {
                    var surl = item.url;
                    var type = item.type;
                    var asset = item.asset;
                    tempMap[surl] = 1;
                    if (mapPackes[surl] != undefined) {
                        packlist.push({ surl: surl, type: type, asset: asset });
                        delete tempMap[surl];
                        if (this_2.mapIsNull(tempMap))
                            this_2.downloadFinsih(state, list, haveBin, onstate, packlist, mapPackes, assetmgr, handles);
                    }
                    else {
                        if (type == framework.AssetTypeEnum.PackBin) {
                            haveBin = true;
                            gd3d.io.loadArrayBuffer(surl, function (_buffer, err, isloadFail) {
                                if (err != null) {
                                    state.isloadFail = isloadFail ? true : false;
                                    state.iserror = true;
                                    state.errs.push(new Error(err.message));
                                    onstate(state);
                                    return;
                                }
                                var read = new gd3d.io.binReader(_buffer);
                                var index = read.readInt32();
                                read.position = index;
                                while (read.canread()) {
                                    var indindex = read.readInt32();
                                    if (index == 0)
                                        break;
                                    var key = read.readStringUtf8FixLength(indindex);
                                    var strs = key.split('|');
                                    var start = parseInt(strs[1]);
                                    var len = parseInt(strs[2]);
                                    var bufs = _buffer.slice(start, start + len);
                                    _this.bundlePackBin[strs[0]] = bufs;
                                }
                                delete tempMap[surl];
                                if (_this.mapIsNull(tempMap))
                                    _this.downloadFinsih(state, list, haveBin, onstate, packlist, mapPackes, assetmgr, handles);
                            }, function (loadedLength, totalLength) {
                                state.compressBinLoaded = loadedLength;
                                onstate(state);
                            });
                        }
                        else {
                            assetmgr.loadSingleRes(surl, type, function (s) {
                                if (s.iserror) {
                                    state.iserror = true;
                                    onstate(state);
                                    return;
                                }
                                if (s.progressCall) {
                                    s.progressCall = false;
                                    onstate(state);
                                    return;
                                }
                            }, state, asset, function (data) {
                                list[handles[data.url]].handle = data.handle;
                                delete tempMap[data.url];
                                if (_this.mapIsNull(tempMap))
                                    _this.downloadFinsih(state, list, haveBin, onstate, packlist, mapPackes, assetmgr, handles);
                            });
                        }
                    }
                };
                var this_2 = this;
                for (var _d = 0, list_1 = list; _d < list_1.length; _d++) {
                    var item = list_1[_d];
                    _loop_2(item);
                }
            };
            assetBundle.prototype.downloadFinsih = function (state, list, haveBin, onstate, packlist, mapPackes, assetmgr, handles) {
                var _this = this;
                if (haveBin) {
                    var respackCall = function (fcall) {
                        if (packlist.length < 1)
                            fcall();
                        var count = 0;
                        var _loop_3 = function (uitem) {
                            var respack = void 0;
                            if (mapPackes[uitem.surl] == 0)
                                respack = _this.bundlePackJson;
                            else if (mapPackes[uitem.surl] == 1)
                                respack = _this.bundlePackBin;
                            else
                                console.log("未识别的packnum: " + mapPackes[uitem.surl]);
                            assetmgr.loadResByPack(respack, uitem.surl, uitem.type, function (s) {
                                if (s.progressCall) {
                                    s.progressCall = false;
                                    onstate(state);
                                    return;
                                }
                                if (state != undefined)
                                    state.bundleLoadState |= uitem.loadstate;
                            }, state, uitem.asset, function (data) {
                                list[handles[data.url]].handle = data.handle;
                                if (++count >= packlist.length)
                                    fcall();
                            });
                        };
                        for (var _i = 0, packlist_1 = packlist; _i < packlist_1.length; _i++) {
                            var uitem = packlist_1[_i];
                            _loop_3(uitem);
                        }
                    };
                    respackCall(function () {
                        _this.NextHandle(list, state, onstate);
                    });
                }
                else
                    this.NextHandle(list, state, onstate);
            };
            assetBundle.prototype.NextHandle = function (list, state, onstate) {
                var waitArrs = [];
                var count = 0;
                var lastHandle = [];
                var finish = function () {
                    state.isfinish = true;
                    onstate(state);
                };
                for (var _i = 0, list_2 = list; _i < list_2.length; _i++) {
                    var hitem = list_2[_i];
                    if (!hitem.handle)
                        continue;
                    if (hitem.type == framework.AssetTypeEnum.Scene || hitem.type == framework.AssetTypeEnum.Prefab || hitem.type == framework.AssetTypeEnum.F14Effect) {
                        lastHandle.push(hitem);
                        continue;
                    }
                    var waiting = hitem.handle();
                    if (waiting instanceof gd3d.threading.gdPromise) {
                        waitArrs.push(waiting);
                        waiting.then(function () {
                            if (++count >= waitArrs.length) {
                                lastHandle.sort(function (a, b) {
                                    return b.type - a.type;
                                });
                                while (lastHandle.length > 0)
                                    lastHandle.shift().handle();
                                waitArrs = [];
                                finish();
                            }
                        });
                    }
                }
                if (waitArrs.length < 1) {
                    while (lastHandle.length > 0)
                        lastHandle.shift().handle();
                    finish();
                }
            };
            assetBundle.prototype.mapIsNull = function (map) {
                if (!map)
                    return true;
                for (var k in map)
                    return false;
                return true;
            };
            return assetBundle;
        }());
        framework.assetBundle = assetBundle;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetTypeEnum;
        (function (AssetTypeEnum) {
            AssetTypeEnum[AssetTypeEnum["Unknown"] = 0] = "Unknown";
            AssetTypeEnum[AssetTypeEnum["Auto"] = 1] = "Auto";
            AssetTypeEnum[AssetTypeEnum["Bundle"] = 2] = "Bundle";
            AssetTypeEnum[AssetTypeEnum["CompressBundle"] = 3] = "CompressBundle";
            AssetTypeEnum[AssetTypeEnum["GLVertexShader"] = 4] = "GLVertexShader";
            AssetTypeEnum[AssetTypeEnum["GLFragmentShader"] = 5] = "GLFragmentShader";
            AssetTypeEnum[AssetTypeEnum["Shader"] = 6] = "Shader";
            AssetTypeEnum[AssetTypeEnum["Texture"] = 7] = "Texture";
            AssetTypeEnum[AssetTypeEnum["TextureDesc"] = 8] = "TextureDesc";
            AssetTypeEnum[AssetTypeEnum["Mesh"] = 9] = "Mesh";
            AssetTypeEnum[AssetTypeEnum["Prefab"] = 10] = "Prefab";
            AssetTypeEnum[AssetTypeEnum["Material"] = 11] = "Material";
            AssetTypeEnum[AssetTypeEnum["Aniclip"] = 12] = "Aniclip";
            AssetTypeEnum[AssetTypeEnum["KeyFrameAniclip"] = 13] = "KeyFrameAniclip";
            AssetTypeEnum[AssetTypeEnum["Scene"] = 14] = "Scene";
            AssetTypeEnum[AssetTypeEnum["Atlas"] = 15] = "Atlas";
            AssetTypeEnum[AssetTypeEnum["Font"] = 16] = "Font";
            AssetTypeEnum[AssetTypeEnum["TextAsset"] = 17] = "TextAsset";
            AssetTypeEnum[AssetTypeEnum["PackBin"] = 18] = "PackBin";
            AssetTypeEnum[AssetTypeEnum["PackTxt"] = 19] = "PackTxt";
            AssetTypeEnum[AssetTypeEnum["PathAsset"] = 20] = "PathAsset";
            AssetTypeEnum[AssetTypeEnum["PVR"] = 21] = "PVR";
            AssetTypeEnum[AssetTypeEnum["F14Effect"] = 22] = "F14Effect";
            AssetTypeEnum[AssetTypeEnum["DDS"] = 23] = "DDS";
        })(AssetTypeEnum = framework.AssetTypeEnum || (framework.AssetTypeEnum = {}));
        var ResourceState = (function () {
            function ResourceState() {
                this.res = null;
                this.state = 0;
                this.loadedLength = 0;
            }
            return ResourceState;
        }());
        framework.ResourceState = ResourceState;
        var RefResourceState = (function (_super) {
            __extends(RefResourceState, _super);
            function RefResourceState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.refLoadedLength = 0;
                return _this;
            }
            return RefResourceState;
        }(ResourceState));
        framework.RefResourceState = RefResourceState;
        var stateLoad = (function () {
            function stateLoad() {
                this.isloadFail = false;
                this.iserror = false;
                this.isfinish = false;
                this.resstate = {};
                this.resstateFirst = null;
                this.curtask = 0;
                this.totaltask = 0;
                this.totalByteLength = 0;
                this.progressCall = false;
                this.compressTextLoaded = 0;
                this.compressBinLoaded = 0;
                this.logs = [];
                this.errs = [];
            }
            Object.defineProperty(stateLoad.prototype, "fileProgress", {
                get: function () {
                    return this.curtask / this.totaltask;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(stateLoad.prototype, "curByteLength", {
                get: function () {
                    var result = 0;
                    for (var key in this.resstate) {
                        var _resState = this.resstate[key];
                        result += _resState.loadedLength;
                        if (_resState instanceof RefResourceState) {
                            result += _resState.refLoadedLength;
                        }
                    }
                    result += this.compressTextLoaded + this.compressBinLoaded;
                    return result;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(stateLoad.prototype, "progress", {
                get: function () {
                    return this.curByteLength / this.totalByteLength;
                },
                enumerable: true,
                configurable: true
            });
            return stateLoad;
        }());
        framework.stateLoad = stateLoad;
        var assetMgr = (function () {
            function assetMgr(app) {
                this.mapShader = {};
                this.mapDefaultMesh = {};
                this.mapDefaultTexture = {};
                this.mapDefaultCubeTexture = {};
                this.mapDefaultSprite = {};
                this.mapMaterial = {};
                this.mapBundle = {};
                this.mapRes = {};
                this.mapNamed = {};
                this._loadingTag = "_AssetLoingTag_";
                this.mapInLoad = {};
                this.assetUrlDic = {};
                this.assetFactorys = {};
                this.waitStateDic = {};
                this.waitQueueState = [];
                this.loadingQueueState = [];
                this.loadingCountLimit = 10;
                this.maploaded = {};
                this.waitlightmapScene = {};
                this.app = app;
                this.webgl = app.webgl;
                this.shaderPool = new gd3d.render.shaderPool();
                this.initAssetFactorys();
            }
            assetMgr.prototype.initDefAsset = function () {
                framework.defMesh.initDefaultMesh(this);
                framework.defTexture.initDefaultTexture(this);
                framework.defsprite.initDefaultSprite(this);
                framework.defShader.initDefaultShader(this);
                framework.defmaterial.initDefaultMaterial(this);
            };
            assetMgr.prototype.getShader = function (name) {
                return this.mapShader[name];
            };
            assetMgr.prototype.getDefaultMesh = function (name) {
                return this.mapDefaultMesh[name];
            };
            assetMgr.prototype.getDefaultTexture = function (name) {
                return this.mapDefaultTexture[name];
            };
            assetMgr.prototype.getDefaultCubeTexture = function (name) {
                return this.mapDefaultCubeTexture[name];
            };
            assetMgr.prototype.getDefaultSprite = function (name) {
                return this.mapDefaultSprite[name];
            };
            assetMgr.prototype.getMaterial = function (name) {
                return this.mapMaterial[name];
            };
            assetMgr.prototype.getAsset = function (id) {
                var r = this.mapRes[id];
                if (r == null)
                    return null;
                return r.asset;
            };
            assetMgr.prototype.getAssetByName = function (name, bundlename) {
                if (bundlename === void 0) { bundlename = null; }
                var id = null;
                if (this.mapNamed[name] != null) {
                    id = this.mapNamed[name][this.mapNamed[name].length - 1];
                }
                if (bundlename != null) {
                    var assetbundle = this.mapBundle[bundlename];
                    if (assetbundle != null)
                        id = assetbundle.mapNamed[name] || id;
                }
                var flag = true;
                if (id != null) {
                    var r = this.mapRes[id];
                    if (r != null && !r[this._loadingTag])
                        return r.asset;
                }
                if (flag) {
                    if (this.mapDefaultMesh[name] != undefined)
                        return this.mapDefaultMesh[name];
                    if (this.mapDefaultTexture[name] != undefined)
                        return this.mapDefaultTexture[name];
                    if (this.mapShader[name] != undefined)
                        return this.mapShader[name];
                }
            };
            assetMgr.prototype.getAssetBundle = function (bundlename) {
                if (this.mapBundle[bundlename])
                    return this.mapBundle[bundlename];
                return null;
            };
            assetMgr.correctFileName = function (name) {
                if (name.indexOf(this.bin) < 0) {
                    return name;
                }
                var binlen = this.bin.length;
                var substr = name.substring(name.length - binlen);
                if (substr == this.bin) {
                    return name + ".js";
                }
                return name;
            };
            assetMgr.correctTxtFileName = function (name) {
                if (name.indexOf(this.txt) < 0) {
                    return name;
                }
                var len = this.txt.length;
                var substr = name.substring(name.length - len);
                if (substr == this.txt) {
                    return name + ".js";
                }
                return name;
            };
            assetMgr.prototype.unuse = function (res, disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                var id = res.getGUID();
                var name = res.getName();
                if (res.defaultAsset) {
                    return;
                }
                if (!this.mapRes[id])
                    return;
                this.mapRes[id].refcount--;
                if (disposeNow && this.mapRes[id].refcount <= 0) {
                    this.mapRes[id].asset.dispose();
                    if (name != null) {
                        if (this.mapNamed[name].length <= 1) {
                            delete this.mapNamed[name];
                        }
                        else {
                            for (var key in this.mapNamed[name]) {
                                if (id == this.mapNamed[name][key]) {
                                    this.mapNamed[name].splice(parseInt(key), 1);
                                }
                            }
                        }
                    }
                    delete this.mapRes[id];
                }
            };
            assetMgr.prototype.use = function (res) {
                var id = res.getGUID();
                var name = res.getName();
                if (id <= 0) {
                    throw new Error("不合法的res guid:" + name);
                }
                if (res.defaultAsset) {
                    return;
                }
                if (this.mapRes[id] == null) {
                    this.mapRes[id] = { asset: res, refcount: 0 };
                    if (name != null) {
                        if (this.mapNamed[name] == null)
                            this.mapNamed[name] = [];
                        this.mapNamed[name].push(id);
                    }
                }
                this.mapRes[id].refcount++;
                if (this.mapRes[id][this._loadingTag]) {
                    delete this.mapRes[id][this._loadingTag];
                }
            };
            assetMgr.prototype.regRes = function (name, asset) {
                var id = asset.getGUID();
                if (this.mapRes[id] == null) {
                    this.mapRes[id] = { asset: asset, refcount: 0 };
                    this.mapRes[id][this._loadingTag] = true;
                    if (name != null) {
                        if (this.mapNamed[name] == null)
                            this.mapNamed[name] = [];
                        this.mapNamed[name].push(id);
                    }
                }
            };
            assetMgr.prototype.releaseUnuseAsset = function () {
                for (var k in this.mapRes) {
                    if (this.mapRes[k].refcount <= 0) {
                        if (this.mapRes[k][this._loadingTag])
                            continue;
                        var name_1 = this.mapRes[k].asset.getName();
                        if (this.mapNamed[name_1].length <= 1) {
                            delete this.mapNamed[name_1];
                        }
                        else {
                            for (var key in this.mapNamed[name_1]) {
                                if (this.mapRes[k].asset.getGUID() == this.mapNamed[name_1][key]) {
                                    this.mapNamed[name_1].splice(parseInt(key), 1);
                                }
                            }
                        }
                        this.mapRes[k].asset.dispose();
                        delete this.mapRes[k];
                    }
                }
            };
            assetMgr.prototype.getAssetsRefcount = function () {
                var mapRefcout = {};
                for (var k in this.mapNamed) {
                    if (this.mapNamed[k].length == 1) {
                        var res = this.mapRes[this.mapNamed[k][0]];
                        mapRefcout[k] = res.refcount;
                    }
                    else {
                        for (var key in this.mapNamed[k]) {
                            var res = this.mapRes[this.mapNamed[k][key]];
                            mapRefcout[k + "(" + key + ")"] = res.refcount;
                        }
                    }
                }
                return mapRefcout;
            };
            assetMgr.prototype.removeAssetBundle = function (name) {
                if (this.mapBundle[name] != null)
                    delete this.mapBundle[name];
                if (this.mapInLoad[name] != null)
                    delete this.mapInLoad[name];
            };
            assetMgr.prototype.setAssetUrl = function (asset, url) {
                this.assetUrlDic[asset.getGUID()] = url;
            };
            assetMgr.prototype.getAssetUrl = function (asset) {
                return this.assetUrlDic[asset.getGUID()];
            };
            assetMgr.prototype.loadSingleRes = function (url, type, onstate, state, asset, call) {
                var assetFactory = this.getAssetFactory(type);
                if (assetFactory != null) {
                    assetFactory.load(url, onstate, state, this, asset, function (chandle) {
                        call({ url: url, handle: chandle });
                    });
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            };
            assetMgr.prototype.loadResByPack = function (respack, url, type, onstate, state, asset, call) {
                var assetFactory = this.getAssetFactory(type);
                if (assetFactory != null) {
                    assetFactory.loadByPack(respack, url, onstate, state, this, asset, (function (chandle) {
                        call({ url: url, handle: chandle });
                    }));
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            };
            assetMgr.prototype.regAssetFactory = function (type, factory) {
                this.assetFactorys[type.toString()] = factory;
            };
            assetMgr.prototype.getAssetFactory = function (type) {
                return this.assetFactorys[type];
            };
            assetMgr.prototype.initAssetFactorys = function () {
                this.regAssetFactory(AssetTypeEnum.GLVertexShader, new framework.AssetFactory_GLVertexShader());
                this.regAssetFactory(AssetTypeEnum.GLFragmentShader, new framework.AssetFactory_GLFragmentShader());
                this.regAssetFactory(AssetTypeEnum.Shader, new framework.AssetFactory_Shader());
                this.regAssetFactory(AssetTypeEnum.Texture, new framework.AssetFactory_Texture());
                this.regAssetFactory(AssetTypeEnum.TextureDesc, new framework.AssetFactory_TextureDesc());
                this.regAssetFactory(AssetTypeEnum.Mesh, new framework.AssetFactory_Mesh());
                this.regAssetFactory(AssetTypeEnum.Prefab, new framework.AssetFactory_Prefab());
                this.regAssetFactory(AssetTypeEnum.Material, new framework.AssetFactory_Material());
                this.regAssetFactory(AssetTypeEnum.Aniclip, new framework.AssetFactory_Aniclip());
                this.regAssetFactory(AssetTypeEnum.Scene, new framework.AssetFactory_Scene());
                this.regAssetFactory(AssetTypeEnum.Atlas, new framework.AssetFactory_Atlas());
                this.regAssetFactory(AssetTypeEnum.Font, new framework.AssetFactory_Font());
                this.regAssetFactory(AssetTypeEnum.TextAsset, new framework.AssetFactory_TextAsset());
                this.regAssetFactory(AssetTypeEnum.PathAsset, new framework.AssetFactory_PathAsset());
                this.regAssetFactory(AssetTypeEnum.PVR, new framework.AssetFactory_PVR());
                this.regAssetFactory(AssetTypeEnum.F14Effect, new framework.AssetFactory_f14eff());
                this.regAssetFactory(AssetTypeEnum.DDS, new framework.AssetFactory_DDS());
                this.regAssetFactory(AssetTypeEnum.KeyFrameAniclip, new framework.assetfactory_keyFrameAniClip());
            };
            assetMgr.prototype.doWaitState = function (name, state) {
                if (this.waitStateDic[name] == null)
                    return;
                for (var key in this.waitStateDic[name]) {
                    this.waitStateDic[name][key](state);
                }
                if (state.isfinish) {
                    this.waitStateDic[name].length = 0;
                }
            };
            assetMgr.prototype.checkFreeChannel = function () {
                var freechannel = -1;
                for (var k = 0; k < this.loadingQueueState.length; k++) {
                    if (this.loadingQueueState[k] == undefined) {
                        freechannel = k;
                        break;
                    }
                    else if (!this.loadingQueueState[k].state.isfinish && !this.loadingQueueState[k].state.iserror) {
                        continue;
                    }
                    else {
                        delete this.loadingQueueState[k];
                        freechannel = k;
                        break;
                    }
                }
                if (freechannel == -1 && this.loadingQueueState.length < this.loadingCountLimit) {
                    freechannel = this.loadingQueueState.length;
                }
                return freechannel;
            };
            assetMgr.prototype.unPkg = function (type, url, state, onstate) {
                var _this = this;
                if (type == AssetTypeEnum.Bundle) {
                    gd3d.io.loadText(url, function (txt, err, isloadFail) {
                        if (err != null) {
                            state.isloadFail = isloadFail ? true : false;
                            state.iserror = true;
                            state.errs.push(new Error(err.message));
                            onstate(state);
                            return;
                        }
                        var json = JSON.parse(txt);
                        var filename = "";
                        if (json["files"]) {
                            filename = _this.getFileName(url);
                            var ab = new framework.assetBundle(url);
                            ab.name = filename;
                            ab.parse(JSON.parse(txt));
                            ab.load(_this, onstate, state);
                        }
                        else {
                            var loadurl = url.replace(".assetbundle.json", ".packs.txt");
                            filename = _this.getFileName(url);
                            var ab = new framework.assetBundle(url);
                            ab.name = filename;
                            ab.totalLength = json["totalLength"];
                            ab.loadCompressBundle(loadurl, onstate, state, _this);
                        }
                        _this.mapBundle[filename] = ab;
                    });
                }
                else if (type == AssetTypeEnum.CompressBundle) {
                    gd3d.io.loadText(url, function (txt, err, isloadFail) {
                        if (err != null) {
                            state.isloadFail = isloadFail ? true : false;
                            state.iserror = true;
                            state.errs.push(new Error(err.message));
                            onstate(state);
                            return;
                        }
                        var loadurl = url.replace(".assetbundle.json", ".packs.txt");
                        var filename = _this.getFileName(url);
                        var json = JSON.parse(txt);
                        var ab = new framework.assetBundle(url);
                        ab.name = filename;
                        ab.totalLength = json["totalLength"];
                        ab.loadCompressBundle(loadurl, onstate, state, _this);
                    });
                }
                else {
                    state.totaltask = 1;
                    this.loadSingleRes(url, type, function (s) {
                        if (s.iserror) {
                            state.iserror = true;
                            onstate(state);
                            return;
                        }
                        if (s.progressCall) {
                            s.progressCall = false;
                            onstate(state);
                            return;
                        }
                        state.curtask = 1;
                        s.isfinish = true;
                        onstate(s);
                        _this.doWaitState(url, s);
                    }, state, null, function (data) {
                        if (data.handle)
                            data.handle();
                    });
                }
            };
            assetMgr.prototype.loadCompressBundle = function (url, onstate) {
                if (onstate === void 0) { onstate = null; }
                if (this.maploaded[url]) {
                    if (onstate) {
                        var state_1 = new stateLoad();
                        state_1.isfinish = true;
                        onstate(state_1);
                    }
                    return;
                }
                var name = this.getFileName(url);
                var type = this.calcType(url);
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type != AssetTypeEnum.Bundle) {
                    state.errs.push(new Error("is not bundle compress type:" + url));
                    state.iserror = true;
                    onstate(state);
                    this.doWaitState(url, state);
                    return;
                }
                type = AssetTypeEnum.CompressBundle;
                this.unPkg(type, url, state, onstate);
            };
            assetMgr.prototype.load = function (url, type, onstate) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                if (onstate === void 0) { onstate = null; }
                if (onstate == null)
                    onstate = function () { };
                if (this.maploaded[url]) {
                    if (onstate) {
                        var state = new stateLoad();
                        state.isfinish = true;
                        onstate(state);
                    }
                    return;
                }
                var name = this.getFileName(url);
                if (this.mapInLoad[name] != null) {
                    var _state = this.mapInLoad[name];
                    if (_state.isfinish) {
                        onstate(this.mapInLoad[name]);
                    }
                    return;
                }
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    state.errs.push(new Error("can not sure about type:" + url));
                    state.iserror = true;
                    onstate(state);
                    return;
                }
                this.unPkg(type, url, state, onstate);
            };
            assetMgr.prototype.loadForNoCache = function (url, type, onstate) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                if (onstate === void 0) { onstate = null; }
                if (onstate == null)
                    onstate = function () { };
                var name = this.getFileName(url);
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    state.errs.push(new Error("can not sure about type:" + url));
                    state.iserror = true;
                    onstate(state);
                    this.doWaitState(url, state);
                    return;
                }
                this.unPkg(type, url, state, onstate);
            };
            assetMgr.prototype.unload = function (url, onstate) {
                if (onstate === void 0) { onstate = null; }
                var name = this.getFileName(url);
                if (this.mapInLoad[name] == null)
                    return;
                var state = this.mapInLoad[name];
                for (var key in state.resstate) {
                    if (state.resstate[key] && state.resstate[key].res) {
                        state.resstate[key].res.unuse();
                    }
                }
                delete this.mapInLoad[name];
            };
            assetMgr.prototype.loadSceneAssetbundleWithoutLightMap = function (url, type, onstate) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                if (onstate === void 0) { onstate = null; }
                this.waitlightmapScene[url] = [];
                this.load(url, type, onstate);
            };
            assetMgr.prototype.loadSceneLightmap = function (sceneurl) {
                var _this = this;
                var arr = this.waitlightmapScene[sceneurl];
                var scenename = this.getFileName(sceneurl).replace(".assetbundle.json", ".scene.json");
                var scene = this.getAssetByName(scenename);
                if (scene == null)
                    return;
                scene["lightmaps"] = [];
                var texarr = [];
                var texcount = 0;
                if (arr) {
                    for (var key in arr) {
                        var texurl = arr[key].replace(".imgdesc.json", ".png");
                        texarr.push(texurl);
                        this.loadForNoCache(texurl, AssetTypeEnum.Texture, function (state) {
                            if (state.isfinish) {
                                texcount++;
                                if (texcount == arr.length) {
                                    for (var item in texarr) {
                                        var texname = _this.getFileName(texarr[item]);
                                        var tex = _this.getAssetByName(texname);
                                        if (tex) {
                                            scene["lightmaps"].push(tex);
                                            tex.use();
                                        }
                                    }
                                    scene.useLightMap(_this.app.getScene());
                                }
                            }
                        });
                    }
                }
            };
            assetMgr.prototype.loadScene = function (sceneName, onComplete) {
                var firstChilds = new Array();
                var scene = this.app.getScene();
                if (sceneName.length > 0) {
                    var _rawscene = this.getAssetByName(sceneName);
                    var willLoadRoot = _rawscene.getSceneRoot();
                    while (willLoadRoot.children.length > 0) {
                        var trans = willLoadRoot.children.shift();
                        firstChilds.push(trans);
                        scene.addChild(trans);
                    }
                    scene["_overlay2d"] = new Array();
                    _rawscene.useLightMap(scene);
                    _rawscene.useFog(scene);
                    _rawscene.useNavMesh(scene);
                }
                else {
                    var _camera = new framework.transform();
                    _camera.gameObject.addComponent("camera");
                    _camera.name = "camera";
                    firstChilds.push(_camera);
                    scene.addChild(_camera);
                }
                scene.name = sceneName;
                scene.getRoot().markDirty();
                onComplete(firstChilds);
            };
            assetMgr.prototype.saveScene = function (fun) {
                gd3d.io.SerializeDependent.resourseDatas = [];
                var info = new SaveInfo();
                var _scene = {};
                var scene = this.app.getScene();
                var _rootNode = gd3d.io.serializeObj(scene.getRoot(), null, this);
                var _lightmaps = [];
                var lightmaps = scene.lightmaps;
                for (var str in lightmaps) {
                    var _lightmap = {};
                    _lightmap["name"] = lightmaps[str].getName();
                    _lightmaps.push(_lightmap);
                    var lightMapUrl = this.getAssetUrl(lightmaps[str]);
                    gd3d.io.SerializeDependent.resourseDatas.push({ "url": lightMapUrl, "type": gd3d.io.SaveAssetType.FullUrl });
                }
                var navstr = framework.NavMeshLoadManager.Instance.navmeshJson;
                navstr = navstr == null ? "" : navstr;
                var navmeshJson = { data: navstr };
                var cup;
                if (scene.fog) {
                    var cup_1 = scene.fog._Color;
                    scene.fog._Color = scene.fog._Color.x + "," + scene.fog._Color.y + "," + scene.fog._Color.z + "," + scene.fog._Color.z;
                }
                _scene["fog"] = scene.fog;
                _scene["rootNode"] = _rootNode;
                _scene["lightmap"] = _lightmaps;
                _scene["navmesh"] = navmeshJson;
                var _sceneStr = JSON.stringify(_scene);
                if (scene.fog)
                    scene.fog._Color = cup;
                var _rawscene = this.getAssetByName(scene.name);
                _rawscene.Parse(_sceneStr, this);
                var url = this.getAssetUrl(_rawscene);
                info.files[url] = _sceneStr;
                fun(info, gd3d.io.SerializeDependent.resourseDatas);
            };
            assetMgr.prototype.savePrefab = function (trans, prefabName, fun) {
                gd3d.io.SerializeDependent.resourseDatas = [];
                var info = new SaveInfo();
                var _prefab = this.getAssetByName(prefabName);
                _prefab.apply(trans);
                var _rootTrans = gd3d.io.serializeObj(trans, null, this);
                var url = this.getAssetUrl(_prefab);
                info.files[url] = JSON.stringify(_rootTrans);
                fun(info, gd3d.io.SerializeDependent.resourseDatas);
            };
            assetMgr.prototype.saveMaterial = function (mat, fun) {
                var info = new SaveInfo();
                var data = {};
                var mapUniform = {};
                var shader = mat.getShader();
                var shaderPropertis = shader.defaultMapUniform;
                data["shader"] = shader.getName();
                data["mapUniform"] = mapUniform;
                var url = this.getAssetUrl(mat);
                info.files[url] = JSON.stringify(data);
                fun(info);
            };
            assetMgr.prototype.loadSingleResImmediate = function (url, type) {
                var _this = this;
                var result;
                var filename = this.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                if (type == AssetTypeEnum.GLVertexShader) {
                    gd3d.io.loadText(url, function (txt, err) {
                        _this.shaderPool.compileVS(_this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.GLFragmentShader) {
                    gd3d.io.loadText(url, function (txt, err) {
                        _this.shaderPool.compileFS(_this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.Shader) {
                    result = new framework.shader(filename);
                    gd3d.io.loadText(url, function (txt, err) {
                        result.parse(_this, JSON.parse(txt));
                        _this.mapShader[filename] = result;
                    });
                }
                else if (type == AssetTypeEnum.Texture) {
                    result = new framework.texture(filename);
                    var img = new Image();
                    img.src = url;
                    img.onload = function () {
                        var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                        result.glTexture = new gd3d.render.glTexture2D(_this.webgl, _textureFormat);
                        result.glTexture.uploadImage(img, true, true, true, true);
                        _this.use(result);
                    };
                }
                else if (type == AssetTypeEnum.Mesh) {
                    result = new framework.mesh(filename);
                    gd3d.io.loadArrayBuffer(url, function (txt, err) {
                        result.Parse(txt, _this.webgl);
                        _this.use(result);
                    });
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
                this.regRes(filename, result);
                return result;
            };
            assetMgr.prototype.loadImmediate = function (url, type) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                var result;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    throw new Error("unknown format");
                }
                else if (type == AssetTypeEnum.Bundle) {
                    result = new framework.assetBundle(url);
                    gd3d.io.loadText(url, function (txt, err) {
                        result.parse(JSON.parse(txt));
                    });
                }
                else {
                    result = this.loadSingleResImmediate(url, type);
                }
                return result;
            };
            assetMgr.prototype.getFileName = function (url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                return file;
            };
            assetMgr.prototype.calcType = function (url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                var i = file.indexOf(".", 0);
                var extname = null;
                while (i >= 0) {
                    extname = file.substr(i);
                    if (extname == ".vs.glsl") {
                        return AssetTypeEnum.GLVertexShader;
                    }
                    else if (extname == ".assetbundle.json") {
                        return AssetTypeEnum.Bundle;
                    }
                    else if (extname == ".fs.glsl") {
                        return AssetTypeEnum.GLFragmentShader;
                    }
                    else if (extname == ".shader.json") {
                        return AssetTypeEnum.Shader;
                    }
                    else if (extname == ".png" || extname == ".jpg") {
                        return AssetTypeEnum.Texture;
                    }
                    else if (extname == ".pvr.bin" || extname == ".pvr" || extname == ".pvr.bin.js") {
                        return AssetTypeEnum.PVR;
                    }
                    else if (extname == ".imgdesc.json") {
                        return AssetTypeEnum.TextureDesc;
                    }
                    else if (extname == ".mat.json") {
                        return AssetTypeEnum.Material;
                    }
                    else if (extname == ".mesh.bin" || extname == ".mesh.bin.js") {
                        return AssetTypeEnum.Mesh;
                    }
                    else if (extname == ".aniclip.bin" || extname == ".aniclip.bin.js") {
                        return AssetTypeEnum.Aniclip;
                    }
                    else if (extname == ".prefab.json") {
                        return AssetTypeEnum.Prefab;
                    }
                    else if (extname == ".scene.json") {
                        return AssetTypeEnum.Scene;
                    }
                    else if (extname == ".atlas.json") {
                        return AssetTypeEnum.Atlas;
                    }
                    else if (extname == ".font.json") {
                        return AssetTypeEnum.Font;
                    }
                    else if (extname == ".json" || extname == ".txt" || extname == ".effect.json") {
                        return AssetTypeEnum.TextAsset;
                    }
                    else if (extname == ".packs.bin" || extname == ".packs.bin.js") {
                        return AssetTypeEnum.PackBin;
                    }
                    else if (extname == ".packs.txt") {
                        return AssetTypeEnum.PackTxt;
                    }
                    else if (extname == ".path.json") {
                        return AssetTypeEnum.PathAsset;
                    }
                    else if (extname == ".f14effect.json") {
                        return AssetTypeEnum.F14Effect;
                    }
                    else if (extname == ".dds" || extname == ".dds.bin") {
                        return AssetTypeEnum.DDS;
                    }
                    else if (extname == ".keyframeAniclip.json") {
                        return AssetTypeEnum.KeyFrameAniclip;
                    }
                    i = file.indexOf(".", i + 1);
                }
                return AssetTypeEnum.Unknown;
            };
            assetMgr.prototype.getDefParticleMat = function () {
                if (this.particlemat == null) {
                    var mat = new framework.material("defparticle");
                    var shader = this.getShader("particles_additive.shader.json");
                    if (shader == null) {
                        shader = this.getShader("shader/def");
                    }
                    mat.setShader(shader);
                    var tex = this.getDefaultTexture("grid");
                    mat.setTexture("_MainTex", tex);
                    this.particlemat = mat;
                }
                return this.particlemat;
            };
            assetMgr.useBinJs = false;
            assetMgr.bin = ".bin";
            assetMgr.txt = ".txt";
            return assetMgr;
        }());
        framework.assetMgr = assetMgr;
        var assetRef = (function () {
            function assetRef() {
            }
            return assetRef;
        }());
        framework.assetRef = assetRef;
        var SaveInfo = (function () {
            function SaveInfo() {
                this.files = {};
            }
            return SaveInfo;
        }());
        framework.SaveInfo = SaveInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var PvrParse = (function () {
    function PvrParse(gl) {
        this.version = 0x03525650;
        this.flags = 0;
        this.pixelFormatH = 0;
        this.pixelFormatL = 0;
        this.channelType = 0;
        this.height = 1;
        this.width = 1;
        this.depth = 1;
        this.numFaces = 1;
        this.mipMapCount = 1;
        this.metaDataSize = 0;
        this.gl = gl;
    }
    PvrParse.prototype.parse = function (_buffer) {
        var ar = new Uint8Array(_buffer);
        _buffer = null;
        var tool = new gd3d.io.binTool();
        tool.writeUint8Array(ar);
        this.version = tool.readUInt32();
        if (this.version === 0x03525650) {
            var tex = this.parseV3(tool);
            tool.dispose();
            return tex;
        }
        else if (this.version === 0x50565203) {
            console.error("v2");
        }
        else {
            console.error("pvr parse error!:" + this.version);
            return null;
        }
    };
    PvrParse.prototype.parseV3 = function (tool) {
        this.flags = tool.readUInt32();
        if (this.flags == 0)
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        else
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
        this.pixelFormatH = tool.readUInt32();
        this.pixelFormatL = tool.readUInt32();
        tool.readBytes(4);
        this.channelType = tool.readUInt32();
        this.height = tool.readUInt32();
        this.width = tool.readUInt32();
        this.depth = tool.readUInt32();
        tool.readBytes(4);
        this.numFaces = tool.readUInt32();
        this.mipMapCount = tool.readUInt32();
        this.metaDataSize = tool.readUInt32();
        tool.readBytes(this.metaDataSize);
        var engineFormat;
        var textureFormat;
        var textureType;
        var t2d = new gd3d.render.glTexture2D(this.gl);
        switch (this.pixelFormatH) {
            case 0:
                textureFormat = t2d.ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                break;
            case 1:
                textureFormat = t2d.ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC2_RGBA;
                break;
            case 2:
                textureFormat = t2d.ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC4_RGB;
                break;
            case 3:
                textureFormat = t2d.ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC4_RGBA;
                break;
            default:
                textureFormat = this.gl.RGB;
                engineFormat = gd3d.render.TextureFormatEnum.RGB;
                console.log("unknow pixel format::" + this.pixelFormatH);
        }
        t2d.format = engineFormat;
        switch (this.channelType) {
            case ChannelTypes.UnsignedByteNorm:
                textureType = this.gl.UNSIGNED_BYTE;
                break;
            case ChannelTypes.UnsignedShortNorm:
                break;
        }
        var target = this.gl.TEXTURE_2D;
        if (this.numFaces > 1)
            target = this.gl.TEXTURE_CUBE_MAP;
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(target, t2d.texture);
        if (this.numFaces > 1)
            target = this.gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        function textureLevelSize(format, width, height) {
            switch (format) {
                case t2d.ext.COMPRESSED_RGB_S3TC_DXT1_EXT:
                case t2d.ext.COMPRESSED_RGB_ATC_WEBGL:
                case t2d.ext.COMPRESSED_RGB_ETC1_WEBGL:
                    return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;
                case t2d.ext.COMPRESSED_RGBA_S3TC_DXT3_EXT:
                case t2d.ext.COMPRESSED_RGBA_S3TC_DXT5_EXT:
                case t2d.ext.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:
                case t2d.ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:
                    return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;
                case t2d.ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
                case t2d.ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
                    return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);
                case t2d.ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
                case t2d.ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
                    return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);
                default:
                    return 0;
            }
        }
        var offset = 0;
        var _width = this.width;
        var _height = this.height;
        for (var i = 0; i < this.mipMapCount; ++i) {
            var levelSize = textureLevelSize(textureFormat, _width, _height);
            var data = tool.readBytes(levelSize);
            this.gl.compressedTexImage2D(this.gl.TEXTURE_2D, i, textureFormat, _width, _height, 0, data);
            _width = _width >> 1;
            if (_width < 1)
                _width = 1;
            _height = _height >> 1;
            if (_height < 1)
                _height = 1;
            offset += levelSize;
        }
        if (this.mipMapCount > 1) {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_NEAREST);
        }
        else {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        }
        return t2d;
    };
    return PvrParse;
}());
var ChannelTypes;
(function (ChannelTypes) {
    ChannelTypes[ChannelTypes["UnsignedByteNorm"] = 0] = "UnsignedByteNorm";
    ChannelTypes[ChannelTypes["SignedByteNorm"] = 1] = "SignedByteNorm";
    ChannelTypes[ChannelTypes["UnsignedByte"] = 2] = "UnsignedByte";
    ChannelTypes[ChannelTypes["SignedByte"] = 3] = "SignedByte";
    ChannelTypes[ChannelTypes["UnsignedShortNorm"] = 4] = "UnsignedShortNorm";
    ChannelTypes[ChannelTypes["SignedShortNorm"] = 5] = "SignedShortNorm";
    ChannelTypes[ChannelTypes["UnsignedShort"] = 6] = "UnsignedShort";
    ChannelTypes[ChannelTypes["SignedShort"] = 7] = "SignedShort";
    ChannelTypes[ChannelTypes["UnsignedIntegerNorm"] = 8] = "UnsignedIntegerNorm";
    ChannelTypes[ChannelTypes["SignedIntegerNorm"] = 9] = "SignedIntegerNorm";
    ChannelTypes[ChannelTypes["UnsignedInteger"] = 10] = "UnsignedInteger";
    ChannelTypes[ChannelTypes["SignedInteger"] = 11] = "SignedInteger";
    ChannelTypes[ChannelTypes["SignedFloat"] = 12] = "SignedFloat";
    ChannelTypes[ChannelTypes["Float"] = 12] = "Float";
    ChannelTypes[ChannelTypes["UnsignedFloat"] = 13] = "UnsignedFloat";
})(ChannelTypes || (ChannelTypes = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defmaterial = (function () {
            function defmaterial() {
            }
            defmaterial.initDefaultMaterial = function (assetmgr) {
                {
                    var mat = new framework.material();
                    var sh = assetmgr.getShader("shader/defui");
                    mat.setShader(sh);
                    assetmgr.mapMaterial[sh.getName()] = mat;
                }
            };
            return defmaterial;
        }());
        framework.defmaterial = defmaterial;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defMesh = (function () {
            function defMesh() {
            }
            defMesh.initDefaultMesh = function (assetmgr) {
                assetmgr.mapDefaultMesh["cube"] = gd3d.framework.defMesh.createDefaultMesh("cube", gd3d.render.meshData.genBoxCCW(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["quad"] = gd3d.framework.defMesh.createDefaultMesh("quad", gd3d.render.meshData.genQuad(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["quad_particle"] = gd3d.framework.defMesh.createDefaultMesh("quad_particle", gd3d.render.meshData.genQuad_forparticle(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["plane"] = gd3d.framework.defMesh.createDefaultMesh("plane", gd3d.render.meshData.genPlaneCCW(10), assetmgr.webgl);
                assetmgr.mapDefaultMesh["sphere"] = gd3d.framework.defMesh.createDefaultMesh("sphere", gd3d.render.meshData.genSphereCCW(), assetmgr.webgl);
                assetmgr.mapDefaultMesh["sphere_quality"] = gd3d.framework.defMesh.createDefaultMesh("sphere_quality", gd3d.render.meshData.genSphereCCW(2.58, 40, 40), assetmgr.webgl);
                assetmgr.mapDefaultMesh["pyramid"] = gd3d.framework.defMesh.createDefaultMesh("pyramid", gd3d.render.meshData.genPyramid(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["cylinder"] = gd3d.framework.defMesh.createDefaultMesh("cylinder", gd3d.render.meshData.genCylinderCCW(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["circleline"] = gd3d.framework.defMesh.createDefaultMesh("circleline", gd3d.render.meshData.genCircleLineCCW(1), assetmgr.webgl);
            };
            defMesh.createDefaultMesh = function (name, meshData, webgl) {
                var _mesh = new gd3d.framework.mesh(name + ".mesh.bin");
                _mesh.defaultAsset = true;
                _mesh.data = meshData;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                _mesh.data.originVF = vf;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new gd3d.framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            return defMesh;
        }());
        framework.defMesh = defMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defShader = (function () {
            function defShader() {
            }
            defShader.initDefaultShader = function (assetmgr) {
                var pool = assetmgr.shaderPool;
                pool.compileVS(assetmgr.webgl, "def", defShader.vscode);
                pool.compileFS(assetmgr.webgl, "def", defShader.fscode);
                pool.compileFS(assetmgr.webgl, "def2", defShader.fscode2);
                pool.compileVS(assetmgr.webgl, "defui", defShader.vscodeUI);
                pool.compileFS(assetmgr.webgl, "defui", defShader.fscodeUI);
                pool.compileVS(assetmgr.webgl, "defuifont", defShader.vscodefontUI);
                pool.compileFS(assetmgr.webgl, "defuifont", defShader.fscodefontUI);
                pool.compileVS(assetmgr.webgl, "diffuse", defShader.vsdiffuse);
                pool.compileFS(assetmgr.webgl, "diffuse", defShader.fsdiffuse);
                pool.compileVS(assetmgr.webgl, "line", defShader.vsline);
                pool.compileFS(assetmgr.webgl, "line", defShader.fsline);
                pool.compileVS(assetmgr.webgl, "materialcolor", defShader.vsmaterialcolor);
                pool.compileVS(assetmgr.webgl, "defUIMaskVS", defShader.vscodeMaskUI);
                pool.compileFS(assetmgr.webgl, "defUIMaskFS", defShader.fscodeMaskUI);
                pool.compileVS(assetmgr.webgl, "defuifontMaskVS", defShader.vscodeuifontmask);
                pool.compileFS(assetmgr.webgl, "defuifontMaskFS", defShader.fscodeuifontmask);
                var program = pool.linkProgram(assetmgr.webgl, "def", "def");
                var program2 = pool.linkProgram(assetmgr.webgl, "defui", "defui");
                var programuifont = pool.linkProgram(assetmgr.webgl, "defuifont", "defuifont");
                var programdiffuse = pool.linkProgram(assetmgr.webgl, "diffuse", "diffuse");
                var programline = pool.linkProgram(assetmgr.webgl, "line", "line");
                var programmaterialcolor = pool.linkProgram(assetmgr.webgl, "materialcolor", "line");
                var programMaskUI = pool.linkProgram(assetmgr.webgl, "defUIMaskVS", "defUIMaskFS");
                var programMaskfont = pool.linkProgram(assetmgr.webgl, "defuifontMaskVS", "defuifontMaskFS");
                {
                    var sh = new framework.shader("shader/def");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def3dbeforeui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(programdiffuse);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = false;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def2");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.uishader).properties);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defuifont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(programuifont);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.shaderuifront).properties);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/line");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programline);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/materialcolor");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programmaterialcolor);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = false;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend);
                    sh.layer = framework.RenderLayerEnum.Overlay;
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.uishader).properties);
                    p.setProgram(programMaskUI);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskfont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.shaderuifront).properties);
                    p.setProgram(programMaskfont);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
            };
            defShader.shader0 = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\"\
            ]\
          }";
            defShader.vscode = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        varying lowp vec4 xlv_COLOR;                \
        varying highp vec2 xlv_TEXCOORD0;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
            defShader.fscode = "         \
        uniform sampler2D _MainTex;                                                 \
        varying lowp vec4 xlv_COLOR;                                                 \
        varying highp vec2 xlv_TEXCOORD0;   \
        void main() \
        {\
            lowp vec4 col_1;    \
            mediump vec4 prev_2;\
            lowp vec4 tmpvar_3;\
            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
            prev_2 = tmpvar_3;\
            mediump vec4 tmpvar_4;\
            tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\
            col_1 = tmpvar_4;\
            col_1.x =xlv_TEXCOORD0.x;\
            col_1.y =xlv_TEXCOORD0.y;\
            gl_FragData[0] = col_1;\
        }\
        ";
            defShader.fscode2 = "         \
        void main() \
        {\
            gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);\
        }\
        ";
            defShader.uishader = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\",\
              \"_MaskTex('MaskTex',Texture)='white'{}\"\
            ]\
            }";
            defShader.fscodeUI = "\n            uniform sampler2D _MainTex;\n            varying lowp vec4 xlv_COLOR;\n            varying highp vec2 xlv_TEXCOORD0;\n            void main()\n            {\n                lowp vec4 tmpvar_3;\n                tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n                gl_FragData[0] = tmpvar_3;\n            }";
            defShader.vscodeUI = "\n            attribute vec4 _glesVertex;    \n            attribute vec4 _glesColor;                   \n            attribute vec4 _glesMultiTexCoord0;          \n            uniform highp mat4 glstate_matrix_mvp;       \n            varying lowp vec4 xlv_COLOR;                 \n            varying highp vec2 xlv_TEXCOORD0;            \n            void main()                                      \n            {                                                \n                highp vec4 tmpvar_1;                         \n                tmpvar_1.w = 1.0;                            \n                tmpvar_1.xyz = _glesVertex.xyz;              \n                xlv_COLOR = _glesColor;                      \n                xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n                gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n            }\n        ";
            defShader.vscodeMaskUI = " \n        attribute vec4 _glesVertex;    \n        attribute vec4 _glesColor;                   \n        attribute vec4 _glesMultiTexCoord0;          \n        uniform highp mat4 glstate_matrix_mvp;       \n        varying lowp vec4 xlv_COLOR;                 \n        varying highp vec2 xlv_TEXCOORD0;            \n        varying highp vec2 mask_TEXCOORD;            \n        void main()                                      \n        {                                                \n            highp vec4 tmpvar_1;                         \n            tmpvar_1.w = 1.0;                            \n            tmpvar_1.xyz = _glesVertex.xyz;              \n            xlv_COLOR = _glesColor;                      \n            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n            mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0; \n            mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0; \n            gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n        }";
            defShader.fscodeMaskUI = "          \n        uniform sampler2D _MainTex;                                                  \n        uniform highp vec4 _maskRect;                                                  \n        varying lowp vec4 xlv_COLOR;                                                  \n        varying highp vec2 xlv_TEXCOORD0;    \n        varying highp vec2 mask_TEXCOORD;            \n        bool CalcuCut(){    \n            highp float l; \n            highp float t; \n            highp float r; \n            highp float b; \n            highp vec2 texc1; \n            bool beCut; \n            l = _maskRect.x; \n            t = _maskRect.y; \n            r = _maskRect.z + l; \n            b = _maskRect.w + t; \n            texc1 = mask_TEXCOORD; \n            if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){  \n                beCut = true;  \n            }else{ \n                beCut = false; \n            } \n            return beCut; \n        } \n            \n        void main()  \n        { \n            if(CalcuCut()) discard; \n            lowp vec4 tmpvar_3; \n            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0)); \n            gl_FragData[0] = tmpvar_3 ; \n        } \n        ";
            defShader.shaderuifront = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\"\
            ]\
            }";
            defShader.vscodefontUI = " \n        attribute vec4 _glesVertex;    \n        attribute vec4 _glesColor;                   \n        attribute vec4 _glesColorEx;                   \n        attribute vec4 _glesMultiTexCoord0;          \n        uniform highp mat4 glstate_matrix_mvp;       \n        varying lowp vec4 xlv_COLOR;                 \n        varying lowp vec4 xlv_COLOREx;                                                  \n        varying highp vec2 xlv_TEXCOORD0;            \n        void main()                                      \n        {                                                \n            highp vec4 tmpvar_1;                         \n            tmpvar_1.w = 1.0;                            \n            tmpvar_1.xyz = _glesVertex.xyz;              \n            xlv_COLOR = _glesColor;                      \n            xlv_COLOREx = _glesColorEx;                      \n            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n            gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n        }";
            defShader.fscodefontUI = " \n            precision mediump float ; \n            uniform sampler2D _MainTex; \n            varying lowp vec4 xlv_COLOR; \n            varying lowp vec4 xlv_COLOREx; \n            varying highp vec2 xlv_TEXCOORD0;     \n            void main()   \n            {  \n                float scale = 10.0;    \n                float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.47)*scale;    \n                float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.4)*scale;    \n                \n                float c=xlv_COLOR.a * clamp ( d,0.0,1.0);   \n                float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);   \n                bc =min(1.0-c,bc);  \n            gl_FragData[0] =xlv_COLOR*c + xlv_COLOREx*bc;  \n        }";
            defShader.vscodeuifontmask = " \n            attribute vec4 _glesVertex;    \n            attribute vec4 _glesColor;                   \n            attribute vec4 _glesColorEx;                   \n            attribute vec4 _glesMultiTexCoord0;          \n            uniform highp mat4 glstate_matrix_mvp;       \n            varying lowp vec4 xlv_COLOR;                 \n            varying lowp vec4 xlv_COLOREx;                                                  \n            varying highp vec2 xlv_TEXCOORD0;            \n            varying highp vec2 mask_TEXCOORD;            \n            void main()                                      \n            {                                                \n                highp vec4 tmpvar_1;                         \n                tmpvar_1.w = 1.0;                            \n                tmpvar_1.xyz = _glesVertex.xyz;              \n                xlv_COLOR = _glesColor;                      \n                xlv_COLOREx = _glesColorEx;                      \n                xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n                mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0; \n                mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0; \n                gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n            }";
            defShader.fscodeuifontmask = " \n            precision mediump float; \n            uniform sampler2D _MainTex;   \n            uniform highp vec4 _maskRect;        \n            varying lowp vec4 xlv_COLOR;  \n            varying lowp vec4 xlv_COLOREx;  \n            varying highp vec2 xlv_TEXCOORD0;     \n            varying highp vec2 mask_TEXCOORD;      \n            bool CalcuCut(){    \n                highp float l; \n                highp float t; \n                highp float r; \n                highp float b; \n                highp vec2 texc1; \n                bool beCut; \n                l = _maskRect.x; \n                t = _maskRect.y; \n                r = _maskRect.z + l; \n                b = _maskRect.w + t; \n                texc1 = mask_TEXCOORD; \n                if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){  \n                    beCut = true;  \n                }else{ \n                    beCut = false; \n                } \n                return beCut; \n            } \n             \n            void main()   \n            {  \n                if(CalcuCut())  discard; \n                float scale = 10.0;    \n                float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.47)*scale;   \n                float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.4)*scale;   \n                \n                float c=xlv_COLOR.a * clamp ( d,0.0,1.0);   \n                float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);   \n                bc =min(1.0-c,bc);  \n                lowp vec4 final =  xlv_COLOR*c + xlv_COLOREx*bc ; \n                gl_FragData[0] = final ; \n            }";
            defShader.diffuseShader = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\",\
              \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\"\
            ]\
            }";
            defShader.vsdiffuse = "\
        attribute vec4 _glesVertex;\
        attribute vec4 _glesMultiTexCoord0;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying highp vec2 xlv_TEXCOORD0;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
            defShader.fsdiffuse = "\
        uniform sampler2D _MainTex;\
        uniform lowp float _AlphaCut;\
        varying highp vec2 xlv_TEXCOORD0;\
        void main() \
        {\
            lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\
            if(tmpvar_3.a < _AlphaCut)\
                discard;\
            gl_FragData[0] = tmpvar_3;\
        }";
            defShader.vsline = "\
        attribute vec4 _glesVertex;\
        attribute vec4 _glesColor;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_COLOR = _glesColor;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
            defShader.fsline = "\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            gl_FragData[0] = xlv_COLOR;\
        }";
            defShader.materialShader = "{\
            \"properties\": [\
              \"_Color('Color',Vector) = (1,1,1,1)\",\
              \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\"\
            ]\
            }";
            defShader.vsmaterialcolor = "\
        attribute vec4 _glesVertex;\
        uniform vec4 _Color;\
        uniform float _Alpha;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_COLOR = _Color;\
            xlv_COLOR.a = xlv_COLOR.a * _Alpha;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
            return defShader;
        }());
        framework.defShader = defShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defsprite = (function () {
            function defsprite() {
            }
            defsprite.initDefaultSprite = function (assetmgr) {
                var spt_white = new framework.sprite("white_sprite");
                spt_white.texture = assetmgr.getDefaultTexture("white");
                spt_white.defaultAsset = true;
                spt_white.rect = new gd3d.math.rect(0, 0, spt_white.texture.glTexture.width, spt_white.texture.glTexture.height);
                assetmgr.mapDefaultSprite["white_sprite"] = spt_white;
                var spt_gray = new framework.sprite("gray_sprite");
                spt_gray.texture = assetmgr.getDefaultTexture("gray");
                spt_gray.defaultAsset = true;
                spt_gray.rect = new gd3d.math.rect(0, 0, spt_gray.texture.glTexture.width, spt_gray.texture.glTexture.height);
                assetmgr.mapDefaultSprite["gray_sprite"] = spt_gray;
                var spt_grid = new framework.sprite("grid_sprite");
                spt_grid.texture = assetmgr.getDefaultTexture("grid");
                spt_grid.defaultAsset = true;
                spt_grid.rect = new gd3d.math.rect(0, 0, spt_grid.texture.glTexture.width, spt_grid.texture.glTexture.height);
                assetmgr.mapDefaultSprite["grid_sprite"] = spt_grid;
            };
            return defsprite;
        }());
        framework.defsprite = defsprite;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defTexture = (function () {
            function defTexture() {
            }
            defTexture.initDefaultTexture = function (assetmgr) {
                var t = new framework.texture("white");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "white");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["white"] = t;
                var t = new framework.texture("gray");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "gray");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["gray"] = t;
                var t = new framework.texture("normal");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "normal");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["normal"] = t;
                var t = new framework.texture("grid");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "grid");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["grid"] = t;
                defTexture.initDefaultCubeTexture(assetmgr);
            };
            defTexture.initDefaultCubeTexture = function (assetmgr) {
                var whiteTex = assetmgr.mapDefaultTexture["white"];
                var t = new framework.texture("white");
                t.glTexture = new gd3d.render.glTextureCube(assetmgr.app.webgl);
                t.glTexture.uploadImages(whiteTex, whiteTex, whiteTex, whiteTex, whiteTex, whiteTex);
                t.defaultAsset = true;
                assetmgr.mapDefaultCubeTexture["white"] = t;
            };
            return defTexture;
        }());
        framework.defTexture = defTexture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Aniclip = (function () {
            function AssetFactory_Aniclip() {
            }
            AssetFactory_Aniclip.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Aniclip.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadArrayBuffer(url, function (_buffer, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _clip = asset ? asset : new framework.animationClip(filename);
                        return _clip.Parse(_buffer).then(function () {
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                        });
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Aniclip.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                var _buffer = respack[filename];
                var _clip = asset ? asset : new framework.animationClip(filename);
                call(function () {
                    return _clip.Parse(_buffer).then(function () {
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                    });
                });
            };
            return AssetFactory_Aniclip;
        }());
        framework.AssetFactory_Aniclip = AssetFactory_Aniclip;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Atlas = (function () {
            function AssetFactory_Atlas() {
            }
            AssetFactory_Atlas.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Atlas.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _atlas = asset ? asset : new framework.atlas(filename);
                        _atlas.Parse(txt, assetMgr);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Atlas.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _atlas = asset ? asset : new framework.atlas(filename);
                    _atlas.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
                });
            };
            return AssetFactory_Atlas;
        }());
        framework.AssetFactory_Atlas = AssetFactory_Atlas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_DDS = (function () {
            function AssetFactory_DDS() {
            }
            AssetFactory_DDS.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_DDS.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () { });
            };
            AssetFactory_DDS.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadArrayBuffer(url, function (_buffer, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _texture = asset ? asset : new framework.texture(filename);
                        assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                        var textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                        textureUtil.loadDDS(url, null, function (texture, error, stats) {
                            var t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                            t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                            t2d.texture = texture;
                            _texture.glTexture = t2d;
                        });
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            return AssetFactory_DDS;
        }());
        framework.AssetFactory_DDS = AssetFactory_DDS;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_f14eff = (function () {
            function AssetFactory_f14eff() {
            }
            AssetFactory_f14eff.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_f14eff.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _f14eff = asset ? asset : new framework.f14eff(filename);
                        _f14eff.assetbundle = bundlename;
                        _f14eff.Parse(txt, assetMgr);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_f14eff.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var bundlename = framework.getFileName(state.url);
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _f14eff = asset ? asset : new framework.f14eff(filename);
                    _f14eff.assetbundle = bundlename;
                    _f14eff.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
                });
            };
            return AssetFactory_f14eff;
        }());
        framework.AssetFactory_f14eff = AssetFactory_f14eff;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Font = (function () {
            function AssetFactory_Font() {
            }
            AssetFactory_Font.prototype.newAsset = function (filename) {
                return null;
            };
            AssetFactory_Font.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _font = asset ? asset : new framework.font(filename);
                        _font.Parse(txt, assetMgr);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Font.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _font = asset ? asset : new framework.font(filename);
                    _font.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
                });
            };
            return AssetFactory_Font;
        }());
        framework.AssetFactory_Font = AssetFactory_Font;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_GLFragmentShader = (function () {
            function AssetFactory_GLFragmentShader() {
            }
            AssetFactory_GLFragmentShader.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_GLFragmentShader.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        state.resstate[filename].state = 1;
                        state.logs.push("load a glshader:" + filename);
                        assetMgr.shaderPool.mapFSString[name] = txt;
                        onstate(state);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_GLFragmentShader.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    var name = filename.substring(0, filename.indexOf("."));
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    txt = decodeURI(txt);
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    assetMgr.shaderPool.mapFSString[name] = txt;
                    onstate(state);
                });
            };
            return AssetFactory_GLFragmentShader;
        }());
        framework.AssetFactory_GLFragmentShader = AssetFactory_GLFragmentShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_GLVertexShader = (function () {
            function AssetFactory_GLVertexShader() {
            }
            AssetFactory_GLVertexShader.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_GLVertexShader.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        state.resstate[filename].state = 1;
                        state.logs.push("load a glshader:" + filename);
                        assetMgr.shaderPool.mapVSString[name] = txt;
                        onstate(state);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_GLVertexShader.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    var name = filename.substring(0, filename.indexOf("."));
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    txt = decodeURI(txt);
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    assetMgr.shaderPool.mapVSString[name] = txt;
                    onstate(state);
                });
            };
            return AssetFactory_GLVertexShader;
        }());
        framework.AssetFactory_GLVertexShader = AssetFactory_GLVertexShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactoryTools = (function () {
            function AssetFactoryTools() {
            }
            AssetFactoryTools.catchError = function (err, onstate, state) {
                if (err != null) {
                    state.iserror = true;
                    state.errs.push(new Error(err.message));
                    onstate(state);
                    return true;
                }
                return false;
            };
            AssetFactoryTools.useAsset = function (assetMgr, onstate, state, asset, url) {
                var fileName = getFileName(url);
                assetMgr.setAssetUrl(asset, url);
                assetMgr.maploaded[url] = asset;
                assetMgr.use(asset);
                state.resstate[fileName].state = 1;
                state.resstate[fileName].res = asset;
                onstate(state);
            };
            AssetFactoryTools.onProgress = function (loadedLength, totalLength, onstate, state, filename) {
                state.resstate[filename].loadedLength = loadedLength;
                state.progressCall = true;
                onstate(state);
            };
            AssetFactoryTools.onRefProgress = function (loadedLength, totalLength, onstate, state, filename) {
                var _restate = state.resstate[filename];
                _restate.refLoadedLength = loadedLength;
                state.progressCall = true;
                onstate(state);
            };
            return AssetFactoryTools;
        }());
        framework.AssetFactoryTools = AssetFactoryTools;
        function getFileName(url) {
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            return file;
        }
        framework.getFileName = getFileName;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var assetfactory_keyFrameAniClip = (function () {
            function assetfactory_keyFrameAniClip() {
            }
            assetfactory_keyFrameAniClip.prototype.newAsset = function () {
                return null;
            };
            assetfactory_keyFrameAniClip.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (text, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _clip = asset ? asset : new framework.keyFrameAniClip(filename);
                        _clip.Parse(text);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            assetfactory_keyFrameAniClip.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var _buffer = respack[filename];
                    var _clip = asset ? asset : new framework.keyFrameAniClip(filename);
                    _clip.Parse(_buffer);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                });
            };
            return assetfactory_keyFrameAniClip;
        }());
        framework.assetfactory_keyFrameAniClip = assetfactory_keyFrameAniClip;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Material = (function () {
            function AssetFactory_Material() {
            }
            AssetFactory_Material.prototype.newAsset = function (filename) {
                return null;
            };
            AssetFactory_Material.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                var assetbundleName = framework.getFileName(state.url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _material = asset ? asset : new framework.material(filename);
                        _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Material.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    var assetbundleName = framework.getFileName(state.url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _material = asset ? asset : new framework.material(filename);
                    _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
                });
            };
            return AssetFactory_Material;
        }());
        framework.AssetFactory_Material = AssetFactory_Material;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Mesh = (function () {
            function AssetFactory_Mesh() {
            }
            AssetFactory_Mesh.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Mesh.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadArrayBuffer(url, function (_buffer, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _mesh = asset ? asset : new framework.mesh(filename);
                        return _mesh.Parse(_buffer, assetMgr.webgl).then(function () {
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
                        });
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Mesh.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                var _buffer = respack[filename];
                var _mesh = asset ? asset : new framework.mesh(filename);
                call(function () {
                    return _mesh.Parse(_buffer, assetMgr.webgl).then(function () {
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
                    });
                });
            };
            return AssetFactory_Mesh;
        }());
        framework.AssetFactory_Mesh = AssetFactory_Mesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_PathAsset = (function () {
            function AssetFactory_PathAsset() {
            }
            AssetFactory_PathAsset.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_PathAsset.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _path = asset ? asset : new framework.pathasset(filename);
                        _path.Parse(JSON.parse(txt));
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_PathAsset.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _path = asset ? asset : new framework.pathasset(filename);
                    _path.Parse(JSON.parse(txt));
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
                });
            };
            return AssetFactory_PathAsset;
        }());
        framework.AssetFactory_PathAsset = AssetFactory_PathAsset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Prefab = (function () {
            function AssetFactory_Prefab() {
            }
            AssetFactory_Prefab.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Prefab.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _prefab = asset ? asset : new framework.prefab(filename);
                        _prefab.assetbundle = bundlename;
                        _prefab.Parse(txt, assetMgr);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Prefab.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var bundlename = framework.getFileName(state.url);
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _prefab = asset ? asset : new framework.prefab(filename);
                    _prefab.assetbundle = bundlename;
                    _prefab.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
                });
            };
            return AssetFactory_Prefab;
        }());
        framework.AssetFactory_Prefab = AssetFactory_Prefab;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_PVR = (function () {
            function AssetFactory_PVR() {
            }
            AssetFactory_PVR.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_PVR.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadArrayBuffer(url, function (_buffer, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _texture = asset ? asset : new framework.texture(filename);
                        var pvr = new PvrParse(assetMgr.webgl);
                        _texture.glTexture = pvr.parse(_buffer);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_PVR.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () { });
            };
            return AssetFactory_PVR;
        }());
        framework.AssetFactory_PVR = AssetFactory_PVR;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Scene = (function () {
            function AssetFactory_Scene() {
            }
            AssetFactory_Scene.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Scene.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _scene = asset ? asset : new framework.rawscene(filename);
                        _scene.assetbundle = bundlename;
                        _scene.Parse(txt, assetMgr);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Scene.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var bundlename = framework.getFileName(state.url);
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _scene = asset ? asset : new framework.rawscene(filename);
                    _scene.assetbundle = bundlename;
                    _scene.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
                });
            };
            return AssetFactory_Scene;
        }());
        framework.AssetFactory_Scene = AssetFactory_Scene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Shader = (function () {
            function AssetFactory_Shader() {
                this.TryParseMap = {};
            }
            AssetFactory_Shader.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Shader.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var _this = this;
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _shader = new framework.shader(filename);
                        _this.parseShader(_shader, assetMgr, txt, filename);
                        assetMgr.setAssetUrl(_shader, url);
                        assetMgr.mapShader[filename] = _shader;
                        state.resstate[filename].state = 1;
                        onstate(state);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Shader.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                var _this = this;
                call(function () {
                    var filename = framework.getFileName(url);
                    var name = filename.substring(0, filename.indexOf("."));
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    state.resstate[filename].state = 1;
                    var _shader = new framework.shader(filename);
                    _this.parseShader(_shader, assetMgr, txt, filename);
                    assetMgr.setAssetUrl(_shader, url);
                    assetMgr.mapShader[filename] = _shader;
                    onstate(state);
                });
            };
            AssetFactory_Shader.prototype.parseShader = function (sd, assetMgr, txt, filename) {
                try {
                    sd.parse(assetMgr, JSON.parse(txt));
                }
                catch (e) {
                    if (!this.TryParseMap[filename])
                        this.TryParseMap[filename] = 0;
                    if (this.TryParseMap[filename] < 3) {
                        this.TryParseMap[filename]++;
                        this.parseShader(sd, assetMgr, txt, filename);
                    }
                    else {
                        throw new Error("shader on parse , filename :" + filename + "   :\n" + txt);
                    }
                }
            };
            return AssetFactory_Shader;
        }());
        framework.AssetFactory_Shader = AssetFactory_Shader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_TextAsset = (function () {
            function AssetFactory_TextAsset() {
            }
            AssetFactory_TextAsset.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_TextAsset.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _textasset = asset ? asset : new framework.textasset(filename);
                        _textasset.content = txt;
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_TextAsset.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                    var filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    if (state.resstateFirst == null) {
                        state.resstateFirst = state.resstate[filename];
                    }
                    var txt = respack[filename];
                    var _textasset = asset ? asset : new framework.textasset(filename);
                    _textasset.content = txt;
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
                });
            };
            return AssetFactory_TextAsset;
        }());
        framework.AssetFactory_TextAsset = AssetFactory_TextAsset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Texture = (function () {
            function AssetFactory_Texture() {
            }
            AssetFactory_Texture.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Texture.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadImg(url, function (_tex, _err, isloadFail) {
                    call(function () {
                        state.isloadFail = isloadFail ? true : false;
                        if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                            return;
                        var _texture = asset ? asset : new framework.texture(filename);
                        var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                        var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                        t2d.uploadImage(_tex, false, true, true, false);
                        _texture.glTexture = t2d;
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    });
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Texture.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                call(function () {
                });
            };
            return AssetFactory_Texture;
        }());
        framework.AssetFactory_Texture = AssetFactory_Texture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_TextureDesc = (function () {
            function AssetFactory_TextureDesc() {
            }
            AssetFactory_TextureDesc.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_TextureDesc.prototype.load = function (url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.RefResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                gd3d.io.loadText(url, function (txt, err, isloadFail) {
                    state.isloadFail = isloadFail ? true : false;
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _texturedesc = JSON.parse(txt);
                    var _name = _texturedesc["name"];
                    var _filterMode = _texturedesc["filterMode"];
                    var _format = _texturedesc["format"];
                    var _mipmap = _texturedesc["mipmap"];
                    var _wrap = _texturedesc["wrap"];
                    var _premultiplyAlpha = _texturedesc["premultiplyAlpha"];
                    if (_premultiplyAlpha == undefined) {
                        _premultiplyAlpha = true;
                    }
                    var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                    if (_format == "RGB")
                        _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                    else if (_format == "Gray")
                        _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                    var _linear = true;
                    if (_filterMode.indexOf("linear") < 0)
                        _linear = false;
                    var _repeat = false;
                    if (_wrap.indexOf("Repeat") >= 0)
                        _repeat = true;
                    var _textureSrc = url.replace(filename, _name);
                    if (_textureSrc.indexOf(".pvr.bin") >= 0) {
                        gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                            call(function () {
                                if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                    return;
                                var _texture = asset ? asset : new framework.texture(filename);
                                var pvr = new PvrParse(assetMgr.webgl);
                                _texture.glTexture = pvr.parse(_buffer);
                                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                            });
                        }, function (loadedLength, totalLength) {
                            framework.AssetFactoryTools.onRefProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                    else if (_textureSrc.indexOf(".dds.bin") >= 0) {
                        gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                            call(function () {
                                if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                    return;
                                var _texture = asset ? asset : new framework.texture(filename);
                                assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                                var textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                                textureUtil.loadDDS(_textureSrc, null, function (texture, error, stats) {
                                    var t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                                    t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                                    t2d.texture = texture;
                                    _texture.glTexture = t2d;
                                });
                                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                            });
                        }, function (loadedLength, totalLength) {
                            framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                    else {
                        gd3d.io.loadImg(_textureSrc, function (_tex, _err, isloadFail) {
                            call(function () {
                                state.isloadFail = isloadFail ? true : false;
                                if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                                    return;
                                var _texture = asset ? asset : new framework.texture(filename);
                                _texture.realName = _name;
                                var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                                t2d.uploadImage(_tex, _mipmap, _linear, _premultiplyAlpha, _repeat);
                                _texture.glTexture = t2d;
                                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                            });
                        }, function (loadedLength, totalLength) {
                            framework.AssetFactoryTools.onRefProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_TextureDesc.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset, call) {
                var filename = framework.getFileName(url);
                var txt = respack[filename];
                var _texturedesc = JSON.parse(txt);
                var _name = _texturedesc["name"];
                var _filterMode = _texturedesc["filterMode"];
                var _format = _texturedesc["format"];
                var _mipmap = _texturedesc["mipmap"];
                var _wrap = _texturedesc["wrap"];
                var _premultiplyAlpha = _texturedesc["premultiplyAlpha"];
                if (_premultiplyAlpha == undefined) {
                    _premultiplyAlpha = true;
                }
                var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                if (_format == "RGB") {
                    _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                }
                else if (_format == "Gray") {
                    _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                }
                var _linear = true;
                if (_filterMode.indexOf("linear") < 0) {
                    _linear = false;
                }
                var _repeat = false;
                if (_wrap.indexOf("Repeat") >= 0) {
                    _repeat = true;
                }
                var _textureSrc = url.replace(filename, _name);
                state.resstate[filename] = new framework.ResourceState();
                if (state.resstateFirst == null) {
                    state.resstateFirst = state.resstate[filename];
                }
                if (_textureSrc.indexOf(".pvr.bin") >= 0) {
                    gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                        call(function () {
                            if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                return;
                            var _texture = asset ? asset : new framework.texture(filename);
                            var pvr = new PvrParse(assetMgr.webgl);
                            console.log(_textureSrc);
                            _texture.glTexture = pvr.parse(_buffer);
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        });
                    }, function (loadedLength, totalLength) {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
                else if (_textureSrc.indexOf(".dds.bin") >= 0) {
                    gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                        call(function () {
                            if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                return;
                            var _texture = asset ? asset : new framework.texture(filename);
                            assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                            var textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                            textureUtil.loadDDS(_textureSrc, null, function (texture, error, stats) {
                                var t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                                t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                                t2d.texture = texture;
                                _texture.glTexture = t2d;
                            });
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        });
                    }, function (loadedLength, totalLength) {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
                else {
                    gd3d.io.loadImg(_textureSrc, function (_tex, _err, isloadFail) {
                        call(function () {
                            state.isloadFail = isloadFail ? true : false;
                            if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                                return;
                            var _texture = asset ? asset : new framework.texture(filename);
                            _texture.realName = _name;
                            var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                            t2d.uploadImage(_tex, _mipmap, _linear, _premultiplyAlpha, _repeat);
                            _texture.glTexture = t2d;
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        });
                    }, function (loadedLength, totalLength) {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
            };
            return AssetFactory_TextureDesc;
        }());
        framework.AssetFactory_TextureDesc = AssetFactory_TextureDesc;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var animationClip = (function () {
            function animationClip(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.indexDic = {};
                this.frames = {};
                if (!assetName) {
                    assetName = "animationClip_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            animationClip.prototype.getName = function () {
                return this.name.getText();
            };
            animationClip.prototype.getGUID = function () {
                return this.id.getID();
            };
            animationClip.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            animationClip.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            animationClip.prototype.dispose = function () {
                this.bones.length = 0;
                this.subclips.length = 0;
                delete this.frames;
            };
            animationClip.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.bones) {
                    total += gd3d.math.caclStringByteLength(this.bones[k]);
                }
                for (var k in this.frames) {
                    total += this.frames[k].byteLength;
                    total += gd3d.math.caclStringByteLength(k);
                }
                total += subClip.caclByteLength() * this.subclips.length;
                return total;
            };
            animationClip.prototype.Parse = function (buf) {
                var _this = this;
                return new gd3d.threading.gdPromise(function (resolve) {
                    var read = new gd3d.io.binReader(buf);
                    var _name = read.readStringAnsi();
                    _this.fps = read.readFloat();
                    _this.loop = read.readBoolean();
                    _this.boneCount = read.readInt();
                    _this.bones = [];
                    for (var i = 0; i < _this.boneCount; i++) {
                        var bonename = read.readStringAnsi();
                        _this.bones.push(bonename);
                        _this.indexDic[bonename] = i;
                    }
                    _this.indexDic["len"] = _this.boneCount;
                    _this.subclipCount = read.readInt();
                    _this.subclips = [];
                    for (var i = 0; i < _this.subclipCount; i++) {
                        var _subClip = new subClip();
                        _subClip.name = read.readStringAnsi();
                        _subClip.loop = read.readBoolean();
                        _this.subclips.push(_subClip);
                    }
                    _this.frameCount = read.readInt();
                    _this.frames = {};
                    for (var i = 0; i < _this.frameCount; i++) {
                        var _fid = read.readInt().toString();
                        var _key = read.readBoolean();
                        var _frame = new Float32Array(_this.boneCount * 7 + 1);
                        _frame[0] = _key ? 1 : 0;
                        var _boneInfo = new PoseBoneMatrix();
                        for (var i_1 = 0; i_1 < _this.boneCount; i_1++) {
                            _boneInfo.load(read);
                            _frame[i_1 * 7 + 1] = _boneInfo.r.x;
                            _frame[i_1 * 7 + 2] = _boneInfo.r.y;
                            _frame[i_1 * 7 + 3] = _boneInfo.r.z;
                            _frame[i_1 * 7 + 4] = _boneInfo.r.w;
                            _frame[i_1 * 7 + 5] = _boneInfo.t.x;
                            _frame[i_1 * 7 + 6] = _boneInfo.t.y;
                            _frame[i_1 * 7 + 7] = _boneInfo.t.z;
                        }
                        _this.frames[_fid] = _frame;
                    }
                    resolve();
                });
            };
            Object.defineProperty(animationClip.prototype, "time", {
                get: function () {
                    if (!this.frameCount || !this.fps)
                        return 0;
                    return this.frameCount / this.fps;
                },
                enumerable: true,
                configurable: true
            });
            animationClip.ClassName = "animationClip";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], animationClip.prototype, "name", void 0);
            animationClip = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], animationClip);
            return animationClip;
        }());
        framework.animationClip = animationClip;
        var PoseBoneMatrix = (function () {
            function PoseBoneMatrix() {
            }
            PoseBoneMatrix_1 = PoseBoneMatrix;
            PoseBoneMatrix.caclByteLength = function () {
                var total = 12 + 16;
                return total;
            };
            PoseBoneMatrix.prototype.Clone = function () {
                var p = new PoseBoneMatrix_1();
                p.t = new gd3d.math.vector3();
                p.r = new gd3d.math.quaternion();
                gd3d.math.vec3Clone(this.t, p.t);
                gd3d.math.quatClone(this.r, p.r);
                return p;
            };
            PoseBoneMatrix.prototype.load = function (read) {
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    var w = read.readSingle();
                    this.r = new gd3d.math.quaternion(x, y, z, w);
                }
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    this.t = new gd3d.math.vector3(x, y, z);
                }
            };
            PoseBoneMatrix.createDefault = function () {
                var pt = new PoseBoneMatrix_1();
                pt.r = new gd3d.math.quaternion(0, 0, 0, 1);
                pt.t = new gd3d.math.vector3(0, 0, 0);
                return pt;
            };
            PoseBoneMatrix.prototype.copyFrom = function (src) {
                this.r.rawData.set(src.r.rawData);
                this.t.rawData.set(src.t.rawData);
            };
            PoseBoneMatrix.prototype.copyFromData = function (src, seek) {
                this.r.x = src[seek + 0];
                this.r.y = src[seek + 1];
                this.r.z = src[seek + 2];
                this.r.w = src[seek + 3];
                this.t.x = src[seek + 4];
                this.t.y = src[seek + 5];
                this.t.z = src[seek + 6];
            };
            PoseBoneMatrix.prototype.invert = function () {
                gd3d.math.quatInverse(this.r, this.r);
                gd3d.math.quatTransformVector(this.r, this.t, this.t);
                this.t.x *= -1;
                this.t.y *= -1;
                this.t.z *= -1;
            };
            PoseBoneMatrix.prototype.lerpInWorld = function (_tpose, from, to, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiply(to, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.prototype.lerpInWorldWithData = function (_tpose, from, todata, toseek, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiplyDataAndMatrix(todata, toseek, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.sMultiply = function (left, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = gd3d.math.pool.new_vector3();
                gd3d.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                gd3d.math.quatMultiply(left.r, right.r, target.r);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sMultiplytpose = function (left, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(right.tposep, dir);
                var dirtran = gd3d.math.pool.new_vector3();
                gd3d.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                gd3d.math.quatMultiply(left.r, right.tposeq, target.r);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sMultiplyDataAndMatrix = function (leftdata, leftseek, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = gd3d.math.pool.new_vector3();
                gd3d.math.quatTransformVectorDataAndQuat(leftdata, leftseek + 0, dir, dirtran);
                target.t.x = dirtran.x + leftdata[leftseek + 4];
                target.t.y = dirtran.y + leftdata[leftseek + 5];
                target.t.z = dirtran.z + leftdata[leftseek + 6];
                gd3d.math.quatMultiplyDataAndQuat(leftdata, leftseek + 0, right.r, target.r);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sLerp = function (left, right, v, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                target.t.x = left.t.x * (1 - v) + right.t.x * v;
                target.t.y = left.t.y * (1 - v) + right.t.y * v;
                target.t.z = left.t.z * (1 - v) + right.t.z * v;
                gd3d.math.quatLerp(left.r, right.r, target.r, v);
                return target;
            };
            PoseBoneMatrix.recycle = function (mat) {
                this.poolmats.push(mat);
            };
            PoseBoneMatrix.create = function () {
                var item = this.poolmats.pop();
                if (item) {
                    return item;
                }
                else {
                    item = PoseBoneMatrix_1.createDefault();
                    return item;
                }
            };
            var PoseBoneMatrix_1;
            PoseBoneMatrix.ClassName = "PoseBoneMatrix";
            PoseBoneMatrix.poolmats = [];
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], PoseBoneMatrix.prototype, "t", void 0);
            __decorate([
                gd3d.reflect.Field("quaternion"),
                __metadata("design:type", gd3d.math.quaternion)
            ], PoseBoneMatrix.prototype, "r", void 0);
            PoseBoneMatrix = PoseBoneMatrix_1 = __decorate([
                gd3d.reflect.SerializeType
            ], PoseBoneMatrix);
            return PoseBoneMatrix;
        }());
        framework.PoseBoneMatrix = PoseBoneMatrix;
        var subClip = (function () {
            function subClip() {
            }
            subClip.caclByteLength = function () {
                var total = 0;
                total += gd3d.math.caclStringByteLength(name);
                total += 1;
                total += 8;
                return total;
            };
            return subClip;
        }());
        framework.subClip = subClip;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var atlas = (function () {
            function atlas(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.sprites = {};
                if (!assetName) {
                    assetName = "atlas_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            atlas.prototype.getName = function () {
                return this.name.getText();
            };
            atlas.prototype.getGUID = function () {
                return this.id.getID();
            };
            atlas.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            atlas.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            atlas.prototype.dispose = function () {
                for (var key in this.sprites) {
                    this.sprites[key].unuse();
                }
                this.texture.unuse();
                delete this.sprites;
            };
            atlas.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.sprites) {
                    total += this.sprites[k].caclByteLength();
                    total += gd3d.math.caclStringByteLength(k);
                }
                return total;
            };
            Object.defineProperty(atlas.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            atlas.prototype.Parse = function (jsonStr, assetmgr) {
                var json = JSON.parse(jsonStr);
                var name = json["t"];
                this.texturewidth = json["w"];
                this.textureheight = json["h"];
                var s = json["s"];
                this.texture = assetmgr.getAssetByName(name);
                if (this.texture == null) {
                    console.log("atlas的图片名字不对");
                }
                for (var i in s) {
                    var ss = s[i];
                    var spriteName = ss[0];
                    var r = new framework.sprite(this.getName() + "_" + spriteName);
                    assetmgr.use(r);
                    if (this.texture) {
                        r.texture = this.texture;
                    }
                    r.rect = new gd3d.math.rect(ss[1], ss[2], ss[3], ss[4]);
                    r.border = new gd3d.math.border(0, 0, 0, 0);
                    r.atlas = this.getName();
                    this.sprites[spriteName] = r;
                }
            };
            atlas.ClassName = "atlas";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], atlas.prototype, "name", void 0);
            atlas = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], atlas);
            return atlas;
        }());
        framework.atlas = atlas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var f14node = (function () {
            function f14node() {
            }
            return f14node;
        }());
        framework.f14node = f14node;
        var f14eff = (function () {
            function f14eff(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.defaultAsset = false;
                this.name = null;
                this.id = new framework.resID();
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "f14eff_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            f14eff.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            f14eff.prototype.getGUID = function () {
                return this.id.getID();
            };
            f14eff.prototype.use = function () {
            };
            f14eff.prototype.unuse = function (disposeNow) {
            };
            f14eff.prototype.dispose = function () {
            };
            f14eff.prototype.caclByteLength = function () {
                return 0;
            };
            f14eff.prototype.Parse = function (jsonStr, assetmgr) {
                var json = JSON.parse(jsonStr);
                this.data = new framework.F14EffectData();
                return this.data.parsejson(json, assetmgr, this.assetbundle);
            };
            f14eff.prototype.getDependents = function () {
                if (!this.data || !this.data.layers)
                    return;
                var result = [];
                this.doSearch(this.data.layers, result);
                return result;
            };
            f14eff.prototype.doSearch = function (obj, arr) {
                var _this = this;
                if (!obj)
                    return;
                if (obj instanceof framework.material || obj instanceof framework.mesh || obj instanceof framework.texture)
                    arr.push(obj);
                if (obj instanceof Array) {
                    obj.forEach(function (element) {
                        if (element && typeof (element) == "object") {
                            _this.doSearch(element, arr);
                        }
                    });
                }
                else {
                    var keys = Reflect["ownKeys"](obj);
                    for (var i = 0; i < keys.length; i++) {
                        if (typeof (obj[keys[i]]) == "object") {
                            this.doSearch(obj[keys[i]], arr);
                        }
                    }
                }
            };
            f14eff.ClassName = "f14eff";
            f14eff = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], f14eff);
            return f14eff;
        }());
        framework.f14eff = f14eff;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var font = (function () {
            function font(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                if (!assetName) {
                    assetName = "font_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            font.prototype.getName = function () {
                return this.name.getText();
            };
            font.prototype.getGUID = function () {
                return this.id.getID();
            };
            font.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            font.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            font.prototype.dispose = function () {
                if (this.texture) {
                    this.texture.unuse(true);
                }
                delete this.cmap;
            };
            font.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.cmap) {
                    total += gd3d.math.caclStringByteLength(k);
                    total += charinfo.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(font.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    if (this._texture)
                        this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            font.prototype.Parse = function (jsonStr, assetmgr) {
                var d1 = new Date().valueOf();
                var json = JSON.parse(jsonStr);
                var font = json["font"];
                this.fontname = font[0];
                var picName = font[1];
                this.texture = assetmgr.getAssetByName(picName);
                this.pointSize = font[2];
                this.padding = font[3];
                this.lineHeight = font[4];
                this.baseline = font[5];
                this.atlasWidth = font[6];
                this.atlasHeight = font[7];
                this.cmap = {};
                var map = json["map"];
                for (var c in map) {
                    var finfo = new charinfo();
                    this.cmap[c] = finfo;
                    finfo.x = (map[c][0] - 0.5) / this.atlasWidth;
                    finfo.y = (map[c][1] - 0.5) / this.atlasHeight;
                    finfo.w = (map[c][2] + 1.0) / this.atlasWidth;
                    finfo.h = (map[c][3] + 1.0) / this.atlasHeight;
                    finfo.xSize = map[c][2];
                    finfo.ySize = map[c][3];
                    finfo.xOffset = map[c][4];
                    finfo.yOffset = map[c][5];
                    finfo.xAddvance = map[c][6];
                }
                map = null;
                json = null;
                var d2 = new Date().valueOf();
                var n = d2 - d1;
            };
            font.ClassName = "font";
            font = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], font);
            return font;
        }());
        framework.font = font;
        var charinfo = (function () {
            function charinfo() {
                this.xOffset = 0;
                this.yOffset = 0;
            }
            charinfo.caclByteLength = function () {
                return 36;
            };
            return charinfo;
        }());
        framework.charinfo = charinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var helpVec3 = new gd3d.math.vector3();
        var helpVec3_1 = new gd3d.math.vector3();
        var helpMtx4 = new gd3d.math.matrix();
        var helpQuat = new gd3d.math.quaternion();
        var helpQuat_1 = new gd3d.math.quaternion();
        var helpUp = new gd3d.math.vector3(0, 1, 0);
        var helpRight = new gd3d.math.vector3(1, 0, 0);
        var helpFoward = new gd3d.math.vector3(0, 0, 1);
        var transform = (function () {
            function transform() {
                this.helpLRotate = new gd3d.math.quaternion();
                this.helpLPos = new gd3d.math.vector3();
                this.helpLScale = new gd3d.math.vector3(1, 1, 1);
                this.name = "noname";
                this.insId = new insID();
                this.prefab = "";
                this._dirtyAABB = true;
                this._children = [];
                this.dirtyLocal = false;
                this.dirtyWorld = false;
                this.hasComponent = false;
                this.hasComponentChild = false;
                this.hasRendererComp = false;
                this.hasRendererCompChild = false;
                this._localRotate = new gd3d.math.quaternion();
                this._localTranslate = new gd3d.math.vector3(0, 0, 0);
                this._localScale = new gd3d.math.vector3(1, 1, 1);
                this.localMatrix = new gd3d.math.matrix();
                this._localEulerAngles = new gd3d.math.vector3(0, 0, 0);
                this.worldMatrix = new gd3d.math.matrix();
                this.worldRotate = new gd3d.math.quaternion();
                this.worldTranslate = new gd3d.math.vector3(0, 0, 0);
                this.worldScale = new gd3d.math.vector3(1, 1, 1);
                this._beDispose = false;
            }
            transform.prototype.checkLRTSChange = function () {
                if (!this.fastEqual(this.helpLPos.rawData, this._localTranslate.rawData))
                    return true;
                if (!this.fastEqual(this.helpLRotate.rawData, this._localRotate.rawData))
                    return true;
                if (!this.fastEqual(this.helpLScale.rawData, this._localScale.rawData))
                    return true;
                return false;
            };
            transform.prototype.fastEqual = function (d_0, d_1) {
                if (d_0[0] != d_1[0])
                    return false;
                if (d_0[1] != d_1[1])
                    return false;
                if (d_0[2] != d_1[2])
                    return false;
                if (d_0.length == 4 && d_0[3] != d_1[3])
                    return false;
                return true;
            };
            Object.defineProperty(transform.prototype, "scene", {
                get: function () {
                    if (this._scene == null) {
                        if (this._parent == null)
                            return null;
                        this._scene = this._parent.scene;
                    }
                    return this._scene;
                },
                set: function (value) {
                    this._scene = value;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.updateWorldTran = function () {
            };
            transform.prototype.updateTran = function (bool) {
            };
            Object.defineProperty(transform.prototype, "aabb", {
                get: function () {
                    if (!this._aabb) {
                        this._aabb = this._buildAABB();
                    }
                    if (this._dirtyAABB) {
                        this._aabb.update(this.getWorldMatrix());
                        this._dirtyAABB = false;
                    }
                    return this._aabb;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype._buildAABB = function () {
                var minimum = new gd3d.math.vector3();
                var maximum = new gd3d.math.vector3();
                var filter = this.gameObject.getComponent("meshFilter");
                if (filter != null && filter.mesh != null && filter.mesh.data != null && filter.mesh.data.pos != null) {
                    var meshdata = filter.mesh.data;
                    gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    for (var i = 0; i < meshdata.pos.length; i++) {
                        gd3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                        gd3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                    }
                }
                else {
                    var skinmesh = this.gameObject.getComponent("skinnedMeshRenderer");
                    if (skinmesh != null && skinmesh.mesh != null && skinmesh.mesh.data != null && skinmesh.mesh.data.pos != null) {
                        var skinmeshdata = skinmesh.mesh.data;
                        gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < skinmeshdata.pos.length; i++) {
                            gd3d.math.vec3Max(skinmeshdata.pos[i], maximum, maximum);
                            gd3d.math.vec3Min(skinmeshdata.pos[i], minimum, minimum);
                        }
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                }
                var _aabb = new framework.aabb(minimum, maximum);
                return _aabb;
            };
            Object.defineProperty(transform.prototype, "children", {
                get: function () {
                    return this._children;
                },
                set: function (children) {
                    this._children = children;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "physicsImpostor", {
                get: function () {
                    return this._physicsImpostor;
                },
                set: function (physicsImp) {
                    this._physicsImpostor = physicsImp;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.addChild = function (node) {
                this.addChildAt(node, this._children.length);
            };
            transform.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (node._parent != null) {
                    node._parent.removeChild(node);
                }
                if (this._children == null)
                    this._children = [];
                this._children.splice(index, 0, node);
                node.scene = this.scene;
                node._parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                if (node.hasComponent || node.hasComponentChild)
                    this.markHaveComponent();
                if (node.hasRendererComp || node.hasRendererCompChild)
                    this.markHaveRendererComp();
                node.dirtify(true);
            };
            transform.prototype.removeAllChild = function () {
                if (this._children == undefined)
                    return;
                while (this._children.length > 0) {
                    this.removeChild(this._children[0]);
                }
            };
            transform.prototype.removeChild = function (node) {
                if (node._parent != this || this._children == null) {
                    throw new Error("not my child.");
                }
                var i = this._children.indexOf(node);
                if (i >= 0) {
                    this._children.splice(i, 1);
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                    node._parent = null;
                }
            };
            transform.prototype.find = function (name) {
                if (this.name == name)
                    return this;
                else {
                    if (this._children != undefined) {
                        for (var i in this._children) {
                            var res = this._children[i].find(name);
                            if (res != null)
                                return res;
                            else {
                                continue;
                            }
                        }
                    }
                }
                return null;
            };
            transform.prototype.checkImpactTran = function (tran) {
                if (this.gameObject.collider == null)
                    return false;
                return this.gameObject.collider.intersectsTransform(tran);
            };
            transform.prototype.checkImpact = function () {
                var trans = new Array();
                this.doImpact(this.scene.getRoot(), trans);
                return trans;
            };
            transform.prototype.doImpact = function (tran, impacted) {
                if (tran == this)
                    return;
                if (tran.gameObject != null && tran.gameObject.collider != null) {
                    if (this.checkImpactTran(tran)) {
                        impacted.push(tran);
                    }
                }
                if (tran._children != null) {
                    for (var i = 0; i < tran._children.length; i++) {
                        this.doImpact(tran._children[i], impacted);
                    }
                }
            };
            transform.prototype.dirtify = function (local) {
                if (local === void 0) { local = false; }
                if ((!local || (local && this.dirtyLocal)) && this.dirtyWorld) {
                    return;
                }
                if (local) {
                    this.dirtyLocal = true;
                }
                if (!this.dirtyWorld) {
                    this.dirtyWorld = true;
                    var i = this.children.length;
                    while (i--) {
                        if (this.children[i].dirtyWorld) {
                            continue;
                        }
                        this.children[i].dirtify();
                    }
                }
                this._dirtyAABB = true;
            };
            transform.prototype.sync = function () {
                if (this.dirtyLocal) {
                    gd3d.math.matrixMakeTransformRTS(this._localTranslate, this._localScale, this._localRotate, this.localMatrix);
                    gd3d.math.vec3Clone(this._localTranslate, this.helpLPos);
                    gd3d.math.vec3Clone(this._localScale, this.helpLScale);
                    gd3d.math.quatClone(this._localRotate, this.helpLRotate);
                    this.dirtyLocal = false;
                }
                if (this.dirtyWorld) {
                    if (!this._parent) {
                        gd3d.math.matrixClone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrixMultiply(this._parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.dirtyWorld = false;
                }
            };
            transform.prototype.markDirty = function () {
            };
            transform.prototype.markHaveComponent = function () {
                this.hasComponent = true;
                var p = this._parent;
                while (p != null) {
                    p.hasComponentChild = true;
                    p = p._parent;
                }
            };
            transform.prototype.markHaveRendererComp = function () {
                this.hasRendererComp = true;
                var p = this._parent;
                while (p != null) {
                    p.hasRendererCompChild = true;
                    p = p._parent;
                }
            };
            Object.defineProperty(transform.prototype, "localRotate", {
                get: function () {
                    return this._localRotate;
                },
                set: function (rotate) {
                    gd3d.math.quatClone(rotate, this._localRotate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localTranslate", {
                get: function () {
                    return this._localTranslate;
                },
                set: function (position) {
                    gd3d.math.vec3Clone(position, this._localTranslate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localPosition", {
                get: function () {
                    return this._localTranslate;
                },
                set: function (position) {
                    gd3d.math.vec3Clone(position, this._localTranslate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localScale", {
                get: function () {
                    return this._localScale;
                },
                set: function (scale) {
                    gd3d.math.vec3Clone(scale, this._localScale);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localEulerAngles", {
                get: function () {
                    gd3d.math.quatToEulerAngles(this._localRotate, this._localEulerAngles);
                    return this._localEulerAngles;
                },
                set: function (angles) {
                    gd3d.math.quatFromEulerAngles(angles.x, angles.y, angles.z, this._localRotate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.getWorldRotate = function () {
                if (!this._parent || !this._parent._parent) {
                    gd3d.math.quatClone(this._localRotate, this.worldRotate);
                }
                else {
                    gd3d.math.matrixGetRotation(this.getWorldMatrix(), this.worldRotate);
                }
                return this.worldRotate;
            };
            transform.prototype.setWorldRotate = function (rotate) {
                if (!this._parent || !this._parent._parent) {
                    gd3d.math.quatClone(rotate, this._localRotate);
                }
                else {
                    gd3d.math.quatClone(this._parent.getWorldRotate(), helpQuat);
                    gd3d.math.quatInverse(helpQuat, helpQuat_1);
                    gd3d.math.quatMultiply(helpQuat_1, rotate, this._localRotate);
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            transform.prototype.getWorldTranslate = function () {
                if (!this._parent || !this._parent._parent) {
                    gd3d.math.vec3Clone(this._localTranslate, this.worldTranslate);
                }
                else {
                    gd3d.math.matrixGetTranslation(this.getWorldMatrix(), this.worldTranslate);
                }
                return this.worldTranslate;
            };
            transform.prototype.getWorldPosition = function () {
                if (!this._parent || !this._parent._parent) {
                    gd3d.math.vec3Clone(this._localTranslate, this.worldTranslate);
                }
                else {
                    gd3d.math.matrixGetTranslation(this.getWorldMatrix(), this.worldTranslate);
                }
                return this.worldTranslate;
            };
            transform.prototype.setWorldPosition = function (pos) {
                if (!this._parent || !this._parent._parent) {
                    gd3d.math.vec3Clone(pos, this._localTranslate);
                }
                else {
                    gd3d.math.matrixInverse(this._parent.getWorldMatrix(), helpMtx4);
                    gd3d.math.matrixTransformVector3(pos, helpMtx4, this._localTranslate);
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            transform.prototype.getWorldScale = function () {
                if (!this._parent || !this._parent._parent) {
                    gd3d.math.vec3Clone(this._localScale, this.worldScale);
                }
                else {
                    gd3d.math.matrixGetScale(this.getWorldMatrix(), this.worldScale);
                }
                return this.worldScale;
            };
            transform.prototype.setWorldScale = function (scale) {
                if (!this._parent || !this._parent._parent) {
                    gd3d.math.vec3Clone(scale, this._localScale);
                }
                else {
                    gd3d.math.vec3Clone(this._parent.getWorldScale(), helpVec3);
                    this._localScale.x = scale.x / helpVec3.x;
                    this._localScale.y = scale.y / helpVec3.y;
                    this._localScale.z = scale.z / helpVec3.z;
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            transform.prototype.getLocalMatrix = function () {
                if (this.dirtyLocal) {
                    gd3d.math.matrixMakeTransformRTS(this._localTranslate, this._localScale, this._localRotate, this.localMatrix);
                    gd3d.math.vec3Clone(this._localTranslate, this.helpLPos);
                    gd3d.math.vec3Clone(this._localScale, this.helpLScale);
                    gd3d.math.quatClone(this._localRotate, this.helpLRotate);
                    this.dirtyLocal = false;
                }
                return this.localMatrix;
            };
            transform.prototype.getWorldMatrix = function () {
                if (!this.dirtyLocal && !this.dirtyWorld) {
                    this.checkToTop();
                }
                if (!this.dirtyLocal && !this.dirtyWorld) {
                    return this.worldMatrix;
                }
                if (this._parent) {
                    this._parent.getWorldMatrix();
                }
                this.sync();
                return this.worldMatrix;
            };
            transform.prototype.checkToTop = function () {
                var top;
                var temp = this;
                while (true) {
                    if (temp.checkLRTSChange()) {
                        temp.dirtyLocal = true;
                        top = temp;
                    }
                    if (!temp._parent)
                        break;
                    temp = temp._parent;
                }
                if (top) {
                    top.dirtify(true);
                }
            };
            transform.prototype.getForwardInWorld = function (out) {
                gd3d.math.matrixTransformNormal(helpFoward, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
            };
            transform.prototype.getRightInWorld = function (out) {
                gd3d.math.matrixTransformNormal(helpRight, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
            };
            transform.prototype.getUpInWorld = function (out) {
                gd3d.math.matrixTransformNormal(helpUp, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
            };
            transform.prototype.setWorldMatrix = function (mat) {
                if (!this._parent) {
                    gd3d.math.matrixDecompose(mat, this._localScale, this._localRotate, this._localTranslate);
                }
                else {
                    gd3d.math.matrixInverse(this._parent.getWorldMatrix(), helpMtx4);
                    gd3d.math.matrixMultiply(helpMtx4, mat, this.localMatrix);
                    gd3d.math.matrixDecompose(this.localMatrix, this._localScale, this._localRotate, this._localTranslate);
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            transform.prototype.lookat = function (trans) {
                this.calcLookAt(trans.getWorldTranslate());
            };
            transform.prototype.lookatPoint = function (point) {
                this.calcLookAt(point);
            };
            transform.prototype.calcLookAt = function (point) {
                gd3d.math.quatLookat(this.getWorldTranslate(), point, this.worldRotate);
                this.setWorldRotate(this.worldRotate);
            };
            Object.defineProperty(transform.prototype, "gameObject", {
                get: function () {
                    if (this._gameObject == null) {
                        this._gameObject = new framework.gameObject();
                        this._gameObject.transform = this;
                    }
                    return this._gameObject;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.clone = function () {
                return gd3d.io.cloneObj(this);
            };
            Object.defineProperty(transform.prototype, "beDispose", {
                get: function () {
                    return this._beDispose;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.dispose = function () {
                if (this._beDispose)
                    return;
                if (this._parent) {
                    this._parent.removeChild(this);
                }
                if (this._children) {
                    for (var k in this._children) {
                        this._children[k].dispose();
                    }
                }
                if (this._physicsImpostor) {
                    this._physicsImpostor.dispose();
                }
                this._gameObject.dispose();
                this._beDispose = true;
                if (this.onDispose)
                    this.onDispose();
            };
            transform.ClassName = "transform";
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform.prototype, "prefab", void 0);
            __decorate([
                gd3d.reflect.Field("transform[]"),
                __metadata("design:type", Array),
                __metadata("design:paramtypes", [Array])
            ], transform.prototype, "children", null);
            __decorate([
                gd3d.reflect.Field("quaternion"),
                __metadata("design:type", gd3d.math.quaternion),
                __metadata("design:paramtypes", [gd3d.math.quaternion])
            ], transform.prototype, "localRotate", null);
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3),
                __metadata("design:paramtypes", [gd3d.math.vector3])
            ], transform.prototype, "localTranslate", null);
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3),
                __metadata("design:paramtypes", [gd3d.math.vector3])
            ], transform.prototype, "localScale", null);
            __decorate([
                gd3d.reflect.Field("gameObject"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [])
            ], transform.prototype, "gameObject", null);
            transform = __decorate([
                gd3d.reflect.SerializeType
            ], transform);
            return transform;
        }());
        framework.transform = transform;
        var insID = (function () {
            function insID() {
                this.id = insID.next();
            }
            insID.next = function () {
                var next = insID.idAll;
                insID.idAll++;
                return next;
            };
            insID.prototype.getInsID = function () {
                return this.id;
            };
            insID.idAll = 1;
            return insID;
        }());
        framework.insID = insID;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var help_v3 = new gd3d.math.vector3();
        var help_v3_1 = new gd3d.math.vector3();
        var boxcollider = (function () {
            function boxcollider() {
                this.center = new gd3d.math.vector3(0, 0, 0);
                this.size = new gd3d.math.vector3(1, 1, 1);
                this._colliderVisible = false;
            }
            boxcollider_1 = boxcollider;
            boxcollider.prototype.getBound = function () {
                return this.obb;
            };
            Object.defineProperty(boxcollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    gd3d.math.matrixMakeIdentity(boxcollider_1._tempMatrix);
                    return boxcollider_1._tempMatrix;
                },
                enumerable: true,
                configurable: true
            });
            boxcollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            };
            boxcollider.prototype.onPlay = function () {
            };
            boxcollider.prototype.update = function (delta) {
                if (this.obb) {
                    this.obb.update(this.matrix);
                }
            };
            Object.defineProperty(boxcollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            boxcollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.obb == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.obb.intersects(_obb);
            };
            boxcollider.prototype.build = function () {
                this.obb = new framework.obb();
                if (this.center && this.size) {
                    this.obb.buildByCenterSize(this.center, this.size);
                }
                else {
                    var minimum = help_v3;
                    var maximum = help_v3_1;
                    if (this.filter) {
                        this.filter.getMeshOutput().calcVectexMinMax(minimum, maximum);
                    }
                    else {
                        minimum.x = minimum.y = minimum.z = -1;
                        maximum.x = maximum.y = maximum.z = 1;
                    }
                    this.obb.buildByMaxMin(minimum, maximum);
                }
                this.buildMesh();
            };
            boxcollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "boxcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
            };
            boxcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = gd3d.render.meshData.genBoxByArray_Quad(this.obb.vectors);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayQuad2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            boxcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                if (this.obb) {
                    this.obb.dispose();
                }
            };
            boxcollider.prototype.clone = function () {
            };
            var boxcollider_1;
            boxcollider.ClassName = "boxcollider";
            boxcollider._tempMatrix = new gd3d.math.matrix();
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], boxcollider.prototype, "center", void 0);
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], boxcollider.prototype, "size", void 0);
            boxcollider = boxcollider_1 = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeBoxCollider
            ], boxcollider);
            return boxcollider;
        }());
        framework.boxcollider = boxcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshcollider = (function () {
            function meshcollider() {
                this._colliderVisible = false;
                this._builded = false;
            }
            meshcollider.prototype.getBound = function () {
                return this._mesh;
            };
            meshcollider.prototype.start = function () {
                this._filter = this.gameObject.getComponent("meshFilter");
                this.ckbuildMesh();
            };
            meshcollider.prototype.onPlay = function () {
            };
            meshcollider.prototype.update = function (delta) {
            };
            Object.defineProperty(meshcollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            meshcollider.prototype.intersectsTransform = function (tran) {
                return false;
            };
            meshcollider.prototype.ckbuildMesh = function () {
                if (this._builded || !this._filter)
                    return;
                this._mesh = this._filter.getMeshOutput();
                if (!this._mesh)
                    return;
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = this.gameObject.getName() + "_meshcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
                this._builded = true;
            };
            meshcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = this._mesh.data;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayTri2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            meshcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                this._mesh = null;
                this._filter = null;
            };
            meshcollider.prototype.clone = function () {
            };
            meshcollider.ClassName = "meshcollider";
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], meshcollider.prototype, "_colliderVisible", void 0);
            meshcollider = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeMeshCollider
            ], meshcollider);
            return meshcollider;
        }());
        framework.meshcollider = meshcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshFilter = (function () {
            function meshFilter() {
            }
            meshFilter.prototype.start = function () {
            };
            meshFilter.prototype.onPlay = function () {
            };
            meshFilter.prototype.update = function (delta) {
            };
            Object.defineProperty(meshFilter.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            meshFilter.prototype.getMeshOutput = function () {
                return this._mesh;
            };
            meshFilter.prototype.remove = function () {
                if (this.mesh)
                    this.mesh.unuse(true);
            };
            meshFilter.prototype.clone = function () {
            };
            meshFilter.ClassName = "meshFilter";
            __decorate([
                gd3d.reflect.Field("mesh"),
                gd3d.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", framework.mesh),
                __metadata("design:paramtypes", [framework.mesh])
            ], meshFilter.prototype, "mesh", null);
            meshFilter = __decorate([
                gd3d.reflect.nodeComponent
            ], meshFilter);
            return meshFilter;
        }());
        framework.meshFilter = meshFilter;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshRenderer = (function () {
            function meshRenderer() {
                this.materials = [];
                this.useGlobalLightMap = true;
                this.lightmapIndex = -1;
                this.lightmapScaleOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.layer = framework.RenderLayerEnum.Common;
                this.issetq = false;
                this._queue = 0;
            }
            Object.defineProperty(meshRenderer.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(meshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            meshRenderer.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.refreshLayerAndQue();
                if (this.lightmapIndex == -2) {
                    this.useGlobalLightMap = false;
                }
            };
            meshRenderer.prototype.onPlay = function () {
            };
            meshRenderer.prototype.refreshLayerAndQue = function () {
                if (this.materials == null || this.materials.length == 0) {
                    this.materials = [];
                    var material_1 = new framework.material();
                    material_1.use();
                    this.materials.push(material_1);
                    this.materials[0].setShader(framework.sceneMgr.app.getAssetMgr().getShader("shader/def"));
                }
                this.layer = this.materials[0].getLayer();
                if (!this.issetq)
                    this._queue = this.materials[0].getQueue();
            };
            meshRenderer.prototype.update = function (delta) {
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                if (this.filter == null) {
                    this.filter = this.gameObject.getComponent("meshFilter");
                }
            };
            meshRenderer.prototype.render = function (context, assetmgr, camera) {
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.Meshrender;
                context.updateLightMask(this.gameObject.layer);
                context.updateModel(this.gameObject.transform);
                if (this.filter != null) {
                    var mesh = this.filter.getMeshOutput();
                    if (mesh != null && mesh.glMesh) {
                        mesh.glMesh.bindVboBuffer(context.webgl);
                        if (mesh.submesh != null) {
                            for (var i = 0; i < mesh.submesh.length; i++) {
                                var sm = mesh.submesh[i];
                                var mid = mesh.submesh[i].matIndex;
                                var usemat = this.materials[mid];
                                var drawtype = this.gameObject.transform.scene.fog ? "base_fog" : "base";
                                if (this.lightmapIndex >= 0 && this.gameObject.transform.scene.lightmaps.length > 0) {
                                    drawtype = this.gameObject.transform.scene.fog ? "lightmap_fog" : "lightmap";
                                    if (this.gameObject.transform.scene.lightmaps.length > this.lightmapIndex) {
                                        context.lightmap = this.gameObject.transform.scene.lightmaps[this.lightmapIndex];
                                        context.lightmapOffset = this.lightmapScaleOffset;
                                        context.lightmapUV = mesh.glMesh.vertexFormat & gd3d.render.VertexFormatMask.UV1 ? 1 : 0;
                                    }
                                }
                                else {
                                    if (!this.useGlobalLightMap) {
                                        drawtype = this.gameObject.transform.scene.fog ? "lightmap_fog" : "lightmap";
                                        context.lightmap = usemat.statedMapUniforms["_LightmapTex"];
                                        context.lightmapOffset = this.lightmapScaleOffset;
                                        context.lightmapUV = mesh.glMesh.vertexFormat & gd3d.render.VertexFormatMask.UV1 ? 1 : 0;
                                    }
                                }
                                if (this.gameObject.transform.scene.fog) {
                                    context.fog = this.gameObject.transform.scene.fog;
                                }
                                if (usemat != null)
                                    usemat.draw(context, mesh, sm, drawtype, this.useGlobalLightMap);
                            }
                        }
                    }
                }
            };
            meshRenderer.prototype.remove = function () {
                this.materials.forEach(function (element) {
                    if (element)
                        element.unuse();
                });
                this.materials.length = 0;
            };
            meshRenderer.prototype.clone = function () {
            };
            meshRenderer.ClassName = "meshRenderer";
            __decorate([
                gd3d.reflect.Field("material[]"),
                __metadata("design:type", Array)
            ], meshRenderer.prototype, "materials", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], meshRenderer.prototype, "lightmapIndex", void 0);
            __decorate([
                gd3d.reflect.Field("vector4"),
                __metadata("design:type", gd3d.math.vector4)
            ], meshRenderer.prototype, "lightmapScaleOffset", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], meshRenderer.prototype, "layer", void 0);
            meshRenderer = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], meshRenderer);
            return meshRenderer;
        }());
        framework.meshRenderer = meshRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var skinnedMeshRenderer = (function () {
            function skinnedMeshRenderer() {
                this.layer = framework.RenderLayerEnum.Common;
                this.issetq = false;
                this._queue = 0;
                this.maxBoneCount = 55;
                this._efficient = true;
            }
            Object.defineProperty(skinnedMeshRenderer.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "player", {
                get: function () {
                    if (this._player == null) {
                        this._player = this.gameObject.getComponentInParent("aniplayer");
                    }
                    return this._player;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            skinnedMeshRenderer.prototype.start = function () {
            };
            skinnedMeshRenderer.prototype.onPlay = function () {
            };
            skinnedMeshRenderer.prototype.getMatByIndex = function (index) {
                var data = this.mesh.data;
                if (data.blendIndex[index].v0 >= this.maxBoneCount || data.blendIndex[index].v1 >= this.maxBoneCount || data.blendIndex[index].v2 >= this.maxBoneCount || data.blendIndex[index].v3 >= this.maxBoneCount) {
                    return null;
                }
                var mat = new gd3d.math.matrix();
                if (this._efficient) {
                    var vec40r = gd3d.math.pool.new_vector4();
                    var vec30p = gd3d.math.pool.new_vector3();
                    vec40r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 0];
                    vec40r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 1];
                    vec40r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 2];
                    vec40r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 3];
                    vec30p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 4];
                    vec30p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 5];
                    vec30p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 6];
                    var vec41r = gd3d.math.pool.new_vector4();
                    var vec31p = gd3d.math.pool.new_vector3();
                    vec41r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 0];
                    vec41r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 1];
                    vec41r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 2];
                    vec41r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 3];
                    vec31p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 4];
                    vec31p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 5];
                    vec31p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 6];
                    var vec42r = gd3d.math.pool.new_vector4();
                    var vec32p = gd3d.math.pool.new_vector3();
                    vec42r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 0];
                    vec42r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 1];
                    vec42r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 2];
                    vec42r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 3];
                    vec32p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 4];
                    vec32p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 5];
                    vec32p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 6];
                    var vec43r = gd3d.math.pool.new_vector4();
                    var vec33p = gd3d.math.pool.new_vector3();
                    vec43r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 0];
                    vec43r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 1];
                    vec43r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 2];
                    vec43r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 3];
                    vec33p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 4];
                    vec33p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 5];
                    vec33p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 6];
                    var mat0 = gd3d.math.pool.new_matrix();
                    var mat1 = gd3d.math.pool.new_matrix();
                    var mat2 = gd3d.math.pool.new_matrix();
                    var mat3 = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixMakeTransformRTS(vec30p, gd3d.math.pool.vector3_one, vec40r, mat0);
                    gd3d.math.matrixMakeTransformRTS(vec31p, gd3d.math.pool.vector3_one, vec41r, mat1);
                    gd3d.math.matrixMakeTransformRTS(vec32p, gd3d.math.pool.vector3_one, vec42r, mat2);
                    gd3d.math.matrixMakeTransformRTS(vec33p, gd3d.math.pool.vector3_one, vec43r, mat3);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_vector4(vec40r);
                    gd3d.math.pool.delete_vector4(vec41r);
                    gd3d.math.pool.delete_vector4(vec42r);
                    gd3d.math.pool.delete_vector4(vec43r);
                    gd3d.math.pool.delete_vector3(vec30p);
                    gd3d.math.pool.delete_vector3(vec31p);
                    gd3d.math.pool.delete_vector3(vec32p);
                    gd3d.math.pool.delete_vector3(vec33p);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                else {
                    var mat0 = gd3d.math.pool.new_matrix();
                    mat0.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v0, 16 * data.blendIndex[index].v0 + 16);
                    var mat1 = gd3d.math.pool.new_matrix();
                    mat1.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v1, 16 * data.blendIndex[index].v1 + 16);
                    var mat2 = gd3d.math.pool.new_matrix();
                    mat2.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v2, 16 * data.blendIndex[index].v2 + 16);
                    var mat3 = gd3d.math.pool.new_matrix();
                    mat3.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v3, 16 * data.blendIndex[index].v3 + 16);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                return mat;
            };
            skinnedMeshRenderer.prototype.intersects = function (ray, outInfo) {
                var ishided = false;
                var lastDistance = Number.MAX_VALUE;
                var mvpmat = this.player.gameObject.transform.getWorldMatrix();
                var data = this.mesh.data;
                for (var i = 0; i < this.mesh.submesh.length; i++) {
                    var submesh = this.mesh.submesh[i];
                    var t0 = gd3d.math.pool.new_vector3();
                    var t1 = gd3d.math.pool.new_vector3();
                    var t2 = gd3d.math.pool.new_vector3();
                    for (var index = submesh.start; index < submesh.size; index += 3) {
                        var verindex0 = data.trisindex[index];
                        var verindex1 = data.trisindex[index + 1];
                        var verindex2 = data.trisindex[index + 2];
                        var p0 = data.pos[verindex0];
                        var p1 = data.pos[verindex1];
                        var p2 = data.pos[verindex2];
                        var mat0 = this.getMatByIndex(verindex0);
                        var mat1 = this.getMatByIndex(verindex1);
                        var mat2 = this.getMatByIndex(verindex2);
                        if (mat0 == null || mat1 == null || mat2 == null)
                            continue;
                        var mat00 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat0, mat00);
                        var mat11 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat1, mat11);
                        var mat22 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat2, mat22);
                        gd3d.math.matrixTransformVector3(p0, mat00, t0);
                        gd3d.math.matrixTransformVector3(p1, mat11, t1);
                        gd3d.math.matrixTransformVector3(p2, mat22, t2);
                        var tempinfo = gd3d.math.pool.new_pickInfo();
                        var bool = ray.intersectsTriangle(t0, t1, t2, tempinfo);
                        if (bool) {
                            if (tempinfo.distance < 0)
                                continue;
                            if (lastDistance > tempinfo.distance) {
                                ishided = true;
                                outInfo.cloneFrom(tempinfo);
                                lastDistance = outInfo.distance;
                                outInfo.faceId = index / 3;
                                outInfo.subMeshId = i;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(ray.direction, outInfo.distance, tdir);
                                gd3d.math.vec3Add(ray.origin, tdir, outInfo.hitposition);
                                gd3d.math.pool.delete_vector3(tdir);
                            }
                        }
                        gd3d.math.pool.delete_pickInfo(tempinfo);
                    }
                    gd3d.math.pool.delete_vector3(t0);
                    gd3d.math.pool.delete_vector3(t1);
                    gd3d.math.pool.delete_vector3(t2);
                }
                return ishided;
            };
            skinnedMeshRenderer.prototype.update = function (delta) {
                if (this._skeletonMatrixData == null) {
                    this.maxBoneCount = 55;
                    this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
                }
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                if (this.player != null) {
                    this.player.fillPoseData(this._skeletonMatrixData, this.bones);
                }
            };
            skinnedMeshRenderer.prototype.render = function (context, assetmgr, camera) {
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.SKinrender;
                if (this.player != null) {
                    context.updateLightMask(this.gameObject.layer);
                    context.updateModel(this.player.gameObject.transform);
                }
                context.vec4_bones = this._skeletonMatrixData;
                if (this._mesh && this.mesh.glMesh) {
                    this._mesh.glMesh.bindVboBuffer(context.webgl);
                    if (this._mesh.submesh != null) {
                        for (var i = 0; i < this._mesh.submesh.length; i++) {
                            var sm = this._mesh.submesh[i];
                            var mid = this._mesh.submesh[i].matIndex;
                            var usemat = this.materials[mid];
                            if (usemat != null) {
                                if (this.gameObject.transform.scene.fog) {
                                    context.fog = this.gameObject.transform.scene.fog;
                                    usemat.draw(context, this._mesh, sm, "skin_fog");
                                }
                                else {
                                    usemat.draw(context, this._mesh, sm, "skin");
                                }
                            }
                        }
                    }
                }
            };
            skinnedMeshRenderer.prototype.remove = function () {
                this.materials.forEach(function (element) {
                    if (element)
                        element.unuse();
                });
                if (this.mesh)
                    this.mesh.unuse(true);
                this.bones.length = 0;
                this._skeletonMatrixData = null;
            };
            skinnedMeshRenderer.prototype.clone = function () {
            };
            skinnedMeshRenderer.ClassName = "skinnedMeshRenderer";
            __decorate([
                gd3d.reflect.Field("material[]"),
                __metadata("design:type", Array)
            ], skinnedMeshRenderer.prototype, "materials", void 0);
            __decorate([
                gd3d.reflect.Field("mesh"),
                __metadata("design:type", framework.mesh),
                __metadata("design:paramtypes", [framework.mesh])
            ], skinnedMeshRenderer.prototype, "mesh", null);
            __decorate([
                gd3d.reflect.Field("transform[]"),
                __metadata("design:type", Array)
            ], skinnedMeshRenderer.prototype, "bones", void 0);
            __decorate([
                gd3d.reflect.Field("transform"),
                __metadata("design:type", framework.transform)
            ], skinnedMeshRenderer.prototype, "rootBone", void 0);
            skinnedMeshRenderer = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], skinnedMeshRenderer);
            return skinnedMeshRenderer;
        }());
        framework.skinnedMeshRenderer = skinnedMeshRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var WrapMode;
        (function (WrapMode) {
            WrapMode[WrapMode["Default"] = 0] = "Default";
            WrapMode[WrapMode["Once"] = 1] = "Once";
            WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
            WrapMode[WrapMode["Loop"] = 2] = "Loop";
            WrapMode[WrapMode["PingPong"] = 4] = "PingPong";
            WrapMode[WrapMode["ClampForever"] = 8] = "ClampForever";
        })(WrapMode = framework.WrapMode || (framework.WrapMode = {}));
        var keyFrameAniClip = (function () {
            function keyFrameAniClip(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.length = 0;
                this.frameRate = 0;
                this.curves = [];
                if (!assetName) {
                    assetName = "keyFrameAniClip_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            keyFrameAniClip.prototype.getName = function () {
                return this.name.getText();
            };
            keyFrameAniClip.prototype.getGUID = function () {
                return this.id.getID();
            };
            keyFrameAniClip.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            keyFrameAniClip.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            keyFrameAniClip.prototype.dispose = function () {
                this.curves.length = 0;
            };
            keyFrameAniClip.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            keyFrameAniClip.prototype.Parse = function (jsonStr) {
                var obj = JSON.parse(jsonStr);
                var tag = obj["tag"];
                this.length = obj["length"];
                this._wrapMode = obj["wrapMode"];
                this.frameRate = obj["frameRate"];
                var curves_o = obj["curves"];
                for (var i = 0; i < curves_o.length; i++) {
                    var curve = new AnimationCurve();
                    var curve_o = curves_o[i];
                    var kfs_o = curve_o["keyFrames"];
                    curve.path = curve_o["path"];
                    curve.propertyName = kFAniClipUtil.converUnityTypeProperty(curve_o["type"], curve_o["propertyName"]);
                    curve.type = kFAniClipUtil.converUnityType(curve_o["type"]);
                    for (var j = 0; j < kfs_o.length; j++) {
                        var kf_o = kfs_o[j];
                        var kf = new keyFrame();
                        if (typeof (kf_o["inTangent"]) === "string")
                            kf.inTangent = Number(kf_o["inTangent"]);
                        else
                            kf.inTangent = kf_o["inTangent"];
                        if (typeof (kf_o["outTangent"]) === "string")
                            kf.outTangent = Number(kf_o["outTangent"]);
                        else
                            kf.outTangent = kf_o["outTangent"];
                        kf.tangentMode = kf_o["tangentMode"];
                        kf.time = kf_o["time"];
                        kf.value = kf_o["value"];
                        curve.keyFrames.push(kf);
                    }
                    this.curves.push(curve);
                }
            };
            Object.defineProperty(keyFrameAniClip.prototype, "wrapMode", {
                get: function () { return this._wrapMode; },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(keyFrameAniClip.prototype, "fps", {
                get: function () {
                    return this.frameRate;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(keyFrameAniClip.prototype, "time", {
                get: function () {
                    return this.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(keyFrameAniClip.prototype, "frameCount", {
                get: function () { return Math.floor(this.frameRate * this.length); },
                enumerable: true,
                configurable: true
            });
            keyFrameAniClip.ClassName = "keyFrameAniClip";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], keyFrameAniClip.prototype, "name", void 0);
            keyFrameAniClip = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], keyFrameAniClip);
            return keyFrameAniClip;
        }());
        framework.keyFrameAniClip = keyFrameAniClip;
        var AnimationCurve = (function () {
            function AnimationCurve() {
                this.keyFrames = [];
            }
            return AnimationCurve;
        }());
        framework.AnimationCurve = AnimationCurve;
        var keyFrame = (function () {
            function keyFrame() {
            }
            return keyFrame;
        }());
        framework.keyFrame = keyFrame;
        var kFAniClipUtil = (function () {
            function kFAniClipUtil() {
            }
            Object.defineProperty(kFAniClipUtil, "typePair", {
                get: function () {
                    if (!kFAniClipUtil._typePair)
                        kFAniClipUtil._typePair = kFAniClipUtil.regType();
                    return kFAniClipUtil._typePair;
                },
                enumerable: true,
                configurable: true
            });
            kFAniClipUtil.isUnityExp = function (tag) {
                if (framework.StringUtil.isNullOrEmptyObject(tag))
                    return false;
                return tag.indexOf("unity") != -1;
            };
            kFAniClipUtil.converUnityType = function (tyep) {
                var result = "";
                if (framework.StringUtil.isNullOrEmptyObject(tyep))
                    return result;
                if (tyep.indexOf("UnityEngine") == -1)
                    return tyep;
                var strs = tyep.split(".");
                if (strs.length < 1 || !strs[strs.length - 1])
                    return result;
                var tempT = strs[strs.length - 1];
                var obj = kFAniClipUtil._typePair[tempT];
                if (obj != null) {
                    result = obj["type"];
                }
                return result;
            };
            kFAniClipUtil.converUnityTypeProperty = function (tyep, propertyName) {
                var result = propertyName;
                if (framework.StringUtil.isNullOrEmptyObject(propertyName))
                    return "";
                if (tyep.indexOf("UnityEngine") != -1) {
                    var strs = tyep.split(".");
                    tyep = strs[strs.length - 1];
                }
                var obj = kFAniClipUtil._typePair[tyep];
                var cgProperty = propertyName;
                if (propertyName.lastIndexOf(".") != -1) {
                    cgProperty = propertyName.substr(0, propertyName.lastIndexOf("."));
                }
                if (obj && obj[kFAniClipUtil.propTag] && obj[kFAniClipUtil.propTag][cgProperty]) {
                    var str = obj[kFAniClipUtil.propTag][cgProperty];
                    result = propertyName.replace(cgProperty, str);
                }
                return result;
            };
            kFAniClipUtil.regType = function () {
                var result = {};
                result["Transform"] = { "type": framework.transform["name"] };
                result["BoxCollider"] = { "type": framework.boxcollider["name"] };
                result["MeshRenderer"] = { "type": framework.meshRenderer["name"] };
                result["MeshFilter"] = { "type": framework.meshFilter["name"] };
                result["SkinnedMeshRenderer"] = { "type": framework.skinnedMeshRenderer["name"] };
                kFAniClipUtil.regProperty(result);
                return result;
            };
            kFAniClipUtil.regProperty = function (obj) {
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalPosition", "localTranslate");
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalScale", "localScale");
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalRotation", "localRotate");
            };
            kFAniClipUtil.assemblyProp = function (obj, Type, prop, replaceProp) {
                if (!obj["Transform"][kFAniClipUtil.propTag])
                    obj["Transform"][kFAniClipUtil.propTag] = {};
                obj["Transform"][kFAniClipUtil.propTag][prop] = replaceProp;
            };
            kFAniClipUtil.propTag = "__prop__";
            kFAniClipUtil._typePair = kFAniClipUtil.regType();
            return kFAniClipUtil;
        }());
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var UniformData = (function () {
            function UniformData(type, value, defaultValue) {
                if (defaultValue === void 0) { defaultValue = null; }
                this.type = type;
                this.value = value;
                this.defaultValue = defaultValue;
            }
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("UniformTypeEnum"),
                __metadata("design:type", Number)
            ], UniformData.prototype, "type", void 0);
            __decorate([
                gd3d.reflect.Field("any"),
                __metadata("design:type", Object)
            ], UniformData.prototype, "value", void 0);
            UniformData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Object, Object])
            ], UniformData);
            return UniformData;
        }());
        framework.UniformData = UniformData;
        var material = (function () {
            function material(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.queue = 0;
                this.statedMapUniforms = {};
                if (!assetName) {
                    assetName = "material_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
                gd3d.io.enumMgr.enumMap["UniformTypeEnum"] = gd3d.render.UniformTypeEnum;
            }
            material_2 = material;
            material.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            material.prototype.getGUID = function () {
                return this.id.getID();
            };
            material.prototype.dispose = function () {
                for (var id in this.statedMapUniforms) {
                    switch (this.defaultMapUniform[id].type) {
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            if (this.statedMapUniforms[id] != null)
                                this.statedMapUniforms[id].unuse(true);
                            break;
                    }
                }
                delete this.statedMapUniforms;
            };
            material.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            material.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            material.prototype.caclByteLength = function () {
                var total = 0;
                if (this.shader) {
                    total += this.shader.caclByteLength();
                }
                for (var k in this.statedMapUniforms) {
                    var type = this.defaultMapUniform[k].type;
                    var value = this.statedMapUniforms[k].value;
                    var defaultValue = this.defaultMapUniform[k].value;
                    switch (type) {
                        case gd3d.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case gd3d.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                return total;
            };
            material.prototype.uploadUnifoms = function (pass, context) {
                gd3d.render.shaderUniform.texindex = 0;
                for (var key in pass.mapuniforms) {
                    var unifom = pass.mapuniforms[key];
                    var func = gd3d.render.shaderUniform.applyuniformFunc[unifom.type];
                    var unifomValue = void 0;
                    if (framework.uniformSetter.autoUniformDic[unifom.name] != null) {
                        var autoFunc = framework.uniformSetter.autoUniformDic[unifom.name];
                        unifomValue = autoFunc(context);
                    }
                    else {
                        if (this.statedMapUniforms[unifom.name] != null) {
                            unifomValue = this.statedMapUniforms[unifom.name];
                        }
                        else if (this.defaultMapUniform[unifom.name]) {
                            unifomValue = this.defaultMapUniform[unifom.name].value;
                        }
                        else {
                            console.error("Uniform don't be setted or have def value. uniform:" + unifom.name + "mat:" + this.getName());
                        }
                    }
                    func(unifom.location, unifomValue);
                }
            };
            material.prototype.setShader = function (shader) {
                this.shader = shader;
                this.defaultMapUniform = shader.defaultMapUniform;
            };
            material.prototype.getLayer = function () {
                return this.shader.layer;
            };
            material.prototype.getQueue = function () {
                return this.queue;
            };
            material.prototype.setQueue = function (queue) {
                this.queue = queue;
            };
            material.prototype.getShader = function () {
                return this.shader;
            };
            material.prototype.setFloat = function (_id, _number) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float) {
                    this.statedMapUniforms[_id] = _number;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setFloatv = function (_id, _numbers) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Floatv) {
                    this.statedMapUniforms[_id] = _numbers;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setVector4 = function (_id, _vector4) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4) {
                    this.statedMapUniforms[_id] = _vector4;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setVector4v = function (_id, _vector4v) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4v) {
                    this.statedMapUniforms[_id] = _vector4v;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setMatrix = function (_id, _matrix) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4x4) {
                    this.statedMapUniforms[_id] = _matrix;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setMatrixv = function (_id, _matrixv) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4x4v) {
                    this.statedMapUniforms[_id] = _matrixv;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setTexture = function (_id, _texture, resname) {
                if (resname === void 0) { resname = ""; }
                if ((this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Texture) || _id == "_LightmapTex") {
                    if (this.statedMapUniforms[_id] != null && (!this.statedMapUniforms[_id].defaultAsset)) {
                        this.statedMapUniforms[_id].unuse();
                    }
                    this.statedMapUniforms[_id] = _texture;
                    if (_texture != null) {
                        if (_texture.getName() == "_color") {
                            _texture;
                        }
                        if (!_texture.defaultAsset) {
                            _texture.use();
                        }
                        var _texelsizeName = _id + "_TexelSize";
                        var _gltexture = _texture.glTexture;
                        if (_gltexture != null && this.defaultMapUniform[_texelsizeName] != null) {
                            this.setVector4(_texelsizeName, new gd3d.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setCubeTexture = function (_id, _texture) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.CubeTexture) {
                    if (this.statedMapUniforms[_id] != null && (!this.statedMapUniforms[_id].defaultAsset)) {
                        this.statedMapUniforms[_id].unuse();
                    }
                    this.statedMapUniforms[_id] = _texture;
                    if (_texture != null) {
                        if (!_texture.defaultAsset) {
                            _texture.use();
                        }
                        var _texelsizeName = _id + "_TexelSize";
                        var _gltexture = _texture.glTexture;
                        if (_gltexture != null) {
                            this.setVector4(_texelsizeName, new gd3d.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.draw = function (context, mesh, sm, basetype, useGLobalLightMap) {
                if (basetype === void 0) { basetype = "base"; }
                if (useGLobalLightMap === void 0) { useGLobalLightMap = true; }
                var drawPasses = this.shader.passes[basetype + context.drawtype];
                if (drawPasses == undefined) {
                    basetype = basetype.indexOf("fog") != -1 ? "base_fog" : "base";
                    drawPasses = this.shader.passes[basetype + context.drawtype];
                    if (drawPasses == undefined) {
                        drawPasses = this.shader.passes["base" + context.drawtype];
                        if (drawPasses == undefined)
                            return;
                    }
                }
                for (var i = 0; i < drawPasses.length; i++) {
                    var pass = drawPasses[i];
                    pass.use(context.webgl);
                    this.uploadUnifoms(pass, context);
                    mesh.glMesh.bind(context.webgl, pass.program, sm.useVertexIndex);
                    framework.DrawCallInfo.inc.add();
                    if (sm.useVertexIndex < 0) {
                        if (sm.line) {
                            mesh.glMesh.drawArrayLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawArrayTris(context.webgl, sm.start, sm.size);
                        }
                    }
                    else {
                        if (sm.line) {
                            mesh.glMesh.drawElementLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawElementTris(context.webgl, sm.start, sm.size);
                        }
                    }
                }
            };
            material.prototype.Parse = function (assetmgr, json, bundleName) {
                if (bundleName === void 0) { bundleName = null; }
                var shaderName = json["shader"];
                var shader = assetmgr.getShader(shaderName);
                if (shader == null) {
                    console.error("shader 为空！shadername：" + shaderName + " bundleName: " + bundleName);
                }
                this.setShader(shader);
                var queue = json["queue"];
                if (queue) {
                    this.queue = queue;
                }
                var mapUniform = json["mapUniform"];
                for (var i in mapUniform) {
                    var jsonChild = mapUniform[i];
                    var _uniformType = jsonChild["type"];
                    if (_uniformType == null)
                        continue;
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            var _value = jsonChild["value"];
                            var _texture = assetmgr.getAssetByName(_value, bundleName);
                            if (_texture == null) {
                                console.error("Material Mapuniform Texture 无效(" + _value + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            }
                            else {
                                this.setTexture(i, _texture, _value);
                            }
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            var _value = jsonChild["value"];
                            this.setFloat(i, parseFloat(_value));
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            var tempValue = jsonChild["value"];
                            try {
                                var values = tempValue.match(framework.RegexpUtil.vector4Regexp);
                                if (values != null) {
                                    var _float4 = new gd3d.math.vector4(parseFloat(values[1]), parseFloat(values[2]), parseFloat(values[3]), parseFloat(values[4]));
                                    this.setVector4(i, _float4);
                                }
                            }
                            catch (e) {
                                console.error("Material Mapuniform float4 无效:value (" + tempValue + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            }
                            break;
                        default:
                            console.error("Material Mapuniform 无效: 未识别类型(" + jsonChild["type"] + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            break;
                    }
                }
            };
            material.prototype.clone = function () {
                var mat = new material_2(this.getName());
                mat.setShader(this.shader);
                for (var i in this.statedMapUniforms) {
                    var _uniformType = this.defaultMapUniform[i].type;
                    var value = this.statedMapUniforms[i];
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                            mat.setTexture(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            mat.setCubeTexture(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            mat.setFloat(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            mat.setVector4(i, value);
                            break;
                        default:
                            break;
                    }
                }
                return mat;
            };
            material.prototype.save = function () {
                var obj = {};
                obj["shader"] = this.shader.getName();
                obj["srcshader"] = "";
                obj["mapUniform"] = {};
                for (var item in this.statedMapUniforms) {
                    var __type = this.defaultMapUniform[item].type;
                    var val = this.statedMapUniforms;
                    var jsonValue = {};
                    jsonValue["type"] = __type;
                    switch (__type) {
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                        case gd3d.render.UniformTypeEnum.Texture:
                            jsonValue["value"] = "" + val[item].name.name;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            jsonValue["value"] = "(" + val[item].x + "," + val[item].y + "," + val[item].z + "," + val[item].w + ")";
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            jsonValue["value"] = val[item];
                            break;
                        default:
                            console.warn("\u65E0\u6CD5\u5B58\u50A8\u672A\u89E3\u6790\u7C7B\u578B:" + __type + "," + item);
                            continue;
                    }
                    obj["mapUniform"][item] = jsonValue;
                }
                return JSON.stringify(obj);
            };
            var material_2;
            material.ClassName = "material";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], material.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("shader"),
                __metadata("design:type", framework.shader)
            ], material.prototype, "shader", void 0);
            material = material_2 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], material);
            return material;
        }());
        framework.material = material;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var mesh = (function () {
            function mesh(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.updateByEffect = false;
                this.submesh = [];
                this.reading = false;
                if (!assetName) {
                    assetName = "mesh_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            mesh_1 = mesh;
            mesh.prototype.getName = function () {
                if (!this.name) {
                    return null;
                }
                return this.name.getText();
            };
            mesh.prototype.getGUID = function () {
                return this.id.getID();
            };
            mesh.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            mesh.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            mesh.prototype.dispose = function () {
                this.glMesh.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                this.data = null;
                delete this.submesh;
            };
            mesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.glMesh.caclByteLength();
                if (this.data) {
                    total += this.data.caclByteLength();
                }
                return total;
            };
            mesh.prototype.readProcess = function (read, data, objVF, vcount, vec10tpose, callback) {
                var _this = this;
                if (this.reading)
                    return;
                var tag = read.readUInt8();
                if (tag == 255) {
                    callback();
                    return;
                }
                if (tag == 1) {
                    if (data.pos == undefined) {
                        data.pos = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Position;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _position = new gd3d.math.vector3();
                        _position.x = read.readSingle();
                        _position.y = read.readSingle();
                        _position.z = read.readSingle();
                        data.pos.push(_position);
                    }
                }
                else if (tag == 2) {
                    if (data.color == undefined) {
                        data.color = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Color;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _color = new gd3d.math.color();
                        _color.a = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.r = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.g = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.b = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        data.color.push(_color);
                    }
                }
                else if (tag == 3) {
                    if (data.normal == undefined) {
                        data.normal = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Normal;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _normal = new gd3d.math.vector3();
                        _normal.x = read.readSingle();
                        _normal.y = read.readSingle();
                        _normal.z = read.readSingle();
                        data.normal.push(_normal);
                    }
                }
                else if (tag == 4) {
                    if (data.uv == undefined) {
                        data.uv = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.UV0;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv.push(uv);
                    }
                }
                else if (tag == 5) {
                    if (data.uv2 == undefined) {
                        data.uv2 = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.UV1;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv2.push(uv);
                    }
                }
                else if (tag == 6) {
                    for (var i = 0; i < vcount; i++) {
                        read.readSingle();
                        read.readSingle();
                    }
                }
                else if (tag == 7) {
                    if (data.tangent == undefined) {
                        data.tangent = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Tangent;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var tangent = new gd3d.math.vector3();
                        var x = read.readSingle();
                        var y = read.readSingle();
                        var z = read.readSingle();
                        var w = read.readSingle();
                        tangent.x = x / w;
                        tangent.y = y / w;
                        tangent.z = z / w;
                        data.tangent.push(tangent);
                    }
                }
                else if (tag == 8) {
                    for (var i = 0; i < vcount; i++) {
                        read.readSingle();
                        read.readSingle();
                    }
                }
                else if (tag == 16) {
                    var tposelen = read.readUInt8();
                    for (var i = 0; i < tposelen; i++) {
                        vec10tpose[i * 10 + 0] = read.readSingle();
                        vec10tpose[i * 10 + 1] = read.readSingle();
                        vec10tpose[i * 10 + 2] = read.readSingle();
                        vec10tpose[i * 10 + 3] = read.readSingle();
                        vec10tpose[i * 10 + 4] = read.readSingle();
                        vec10tpose[i * 10 + 5] = read.readSingle();
                        vec10tpose[i * 10 + 6] = read.readSingle();
                        vec10tpose[i * 10 + 7] = read.readSingle();
                        vec10tpose[i * 10 + 8] = read.readSingle();
                        vec10tpose[i * 10 + 9] = read.readSingle();
                    }
                }
                else if (tag == 17) {
                    if (data.blendIndex == undefined) {
                        data.blendIndex = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.BlendIndex4;
                    }
                    if (data.blendWeight == undefined) {
                        data.blendWeight = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.BlendWeight4;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _boneIndex = new gd3d.render.number4();
                        _boneIndex.v0 = read.readUInt32();
                        _boneIndex.v1 = read.readUInt32();
                        _boneIndex.v2 = read.readUInt32();
                        _boneIndex.v3 = read.readUInt32();
                        var _boneWeight = new gd3d.render.number4();
                        _boneWeight.v0 = read.readSingle();
                        _boneWeight.v1 = read.readSingle();
                        _boneWeight.v2 = read.readSingle();
                        _boneWeight.v3 = read.readSingle();
                        data.blendIndex.push(_boneIndex);
                        data.blendWeight.push(_boneWeight);
                    }
                }
                else {
                    throw "notwrite" + tag;
                }
                this.reading = false;
                setTimeout(function () {
                    _this.readProcess(read, data, objVF, vcount, vec10tpose, function () {
                        callback();
                    });
                });
            };
            mesh.prototype.readFinish = function (read, data, buf, objVF, webgl) {
                var subcount = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < subcount; i++) {
                    var _submeshinfo = new subMeshInfo();
                    var tv = read.readUInt32();
                    var sublen = read.readUInt32();
                    _submeshinfo.start = data.trisindex.length;
                    _submeshinfo.size = sublen;
                    _submeshinfo.matIndex = i;
                    this.submesh.push(_submeshinfo);
                    for (var j = 0; j < sublen; j++) {
                        var index = read.readUInt32();
                        data.trisindex.push(index);
                    }
                }
                buf = null;
                data.originVF = objVF.vf;
                this.data = data;
                this.glMesh = new gd3d.render.glMesh();
                var vertexs = this.data.genVertexDataArray(objVF.vf);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, objVF.vf, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
            };
            mesh.prototype.Parse = function (buf, webgl) {
                var _this = this;
                return new gd3d.threading.gdPromise(function (reslove) {
                    gd3d.threading.thread.Instance.Call("meshDataHandle", buf, function (result) {
                        var objVF = result.objVF;
                        var data = result.meshData;
                        data.originVF = objVF.vf;
                        _this.data = gd3d.render.meshData.cloneByObj(data);
                        _this.submesh = result.subMesh;
                        _this.glMesh = new gd3d.render.glMesh();
                        var vertexs = _this.data.genVertexDataArray(objVF.vf);
                        var indices = _this.data.genIndexDataArray();
                        var __webgl = framework.sceneMgr.app.getAssetMgr().webgl;
                        _this.glMesh.initBuffer(webgl, objVF.vf, _this.data.pos.length);
                        _this.glMesh.uploadVertexData(webgl, vertexs);
                        _this.glMesh.addIndex(webgl, indices.length);
                        _this.glMesh.uploadIndexData(webgl, 0, indices);
                        reslove();
                    });
                });
            };
            mesh.prototype.intersects = function (ray, matrix, outInfo) {
                var ishided = false;
                if (!this.submesh)
                    return ishided;
                var lastDistance = Number.MAX_VALUE;
                for (var i = 0; i < this.submesh.length; i++) {
                    var submesh = this.submesh[i];
                    if (submesh.line) {
                    }
                    else {
                        if (submesh.useVertexIndex < 0) {
                        }
                        else {
                            var t0 = gd3d.math.pool.new_vector3();
                            var t1 = gd3d.math.pool.new_vector3();
                            var t2 = gd3d.math.pool.new_vector3();
                            for (var index = submesh.start; index < submesh.size; index += 3) {
                                var p0 = this.data.pos[this.data.trisindex[index]];
                                var p1 = this.data.pos[this.data.trisindex[index + 1]];
                                var p2 = this.data.pos[this.data.trisindex[index + 2]];
                                gd3d.math.matrixTransformVector3(p0, matrix, t0);
                                gd3d.math.matrixTransformVector3(p1, matrix, t1);
                                gd3d.math.matrixTransformVector3(p2, matrix, t2);
                                var tempinfo = gd3d.math.pool.new_pickInfo();
                                var bool = ray.intersectsTriangle(t0, t1, t2, tempinfo);
                                if (bool) {
                                    if (tempinfo.distance < 0)
                                        continue;
                                    if (lastDistance > tempinfo.distance) {
                                        ishided = true;
                                        outInfo.cloneFrom(tempinfo);
                                        lastDistance = outInfo.distance;
                                        outInfo.faceId = index / 3;
                                        outInfo.subMeshId = i;
                                        var tdir = gd3d.math.pool.new_vector3();
                                        gd3d.math.vec3ScaleByNum(ray.direction, outInfo.distance, tdir);
                                        gd3d.math.vec3Add(ray.origin, tdir, outInfo.hitposition);
                                        gd3d.math.pool.delete_vector3(tdir);
                                    }
                                }
                                gd3d.math.pool.delete_pickInfo(tempinfo);
                            }
                            gd3d.math.pool.delete_vector3(t0);
                            gd3d.math.pool.delete_vector3(t1);
                            gd3d.math.pool.delete_vector3(t2);
                        }
                    }
                }
                return ishided;
            };
            mesh.prototype.clone = function () {
                var _result = new mesh_1(this.getName());
                var vf = this.glMesh.vertexFormat;
                var data = gd3d.render.meshData.cloneByObj(this.data);
                _result.data = data;
                _result.glMesh = new gd3d.render.glMesh();
                var vertexs = _result.data.genVertexDataArray(vf);
                var indices = _result.data.genIndexDataArray();
                _result.glMesh.initBuffer(framework.sceneMgr.app.getAssetMgr().webgl, vf, this.data.pos.length);
                _result.glMesh.uploadVertexData(framework.sceneMgr.app.getAssetMgr().webgl, vertexs);
                _result.glMesh.addIndex(framework.sceneMgr.app.getAssetMgr().webgl, indices.length);
                _result.glMesh.uploadIndexData(framework.sceneMgr.app.getAssetMgr().webgl, 0, indices);
                return _result;
            };
            mesh.prototype.calcVectexMinMax = function (outMin, outMax) {
                if (!outMin || !outMax)
                    return;
                if (!this._cacheMinP || !this._cacheMaxP) {
                    this._cacheMinP = new gd3d.math.vector3();
                    this._cacheMaxP = new gd3d.math.vector3();
                    var meshdata = this.data;
                    gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this._cacheMinP);
                    gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this._cacheMaxP);
                    for (var i = 0; i < meshdata.pos.length; i++) {
                        gd3d.math.vec3Max(meshdata.pos[i], this._cacheMaxP, this._cacheMaxP);
                        gd3d.math.vec3Min(meshdata.pos[i], this._cacheMinP, this._cacheMinP);
                    }
                }
                gd3d.math.vec3Clone(this._cacheMinP, outMin);
                gd3d.math.vec3Clone(this._cacheMaxP, outMax);
            };
            var mesh_1;
            mesh.ClassName = "mesh";
            mesh = mesh_1 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], mesh);
            return mesh;
        }());
        framework.mesh = mesh;
        var subMeshInfo = (function () {
            function subMeshInfo() {
                this.matIndex = 0;
                this.useVertexIndex = 0;
                this.line = false;
                this.start = 0;
                this.size = 0;
            }
            return subMeshInfo;
        }());
        framework.subMeshInfo = subMeshInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pathasset = (function () {
            function pathasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.paths = [];
                this.items = [];
                this.lines = [];
                if (!assetName) {
                    assetName = "path_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            pathasset.prototype.getName = function () {
                return this.name.getText();
            };
            pathasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            pathasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            pathasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            pathasset.prototype.dispose = function () {
                this.paths.length = 0;
            };
            pathasset.prototype.caclByteLength = function () {
                if (this.paths) {
                    var length = this.paths.length;
                    var value = length * 12;
                    return value;
                }
            };
            pathasset.prototype.Parse = function (json) {
                var type = json["type"];
                switch (type) {
                    case "once":
                        this.type = pathtype.once;
                        break;
                    case "loop":
                        this.type = pathtype.loop;
                        break;
                    case "pingpong":
                        this.type = pathtype.pingpong;
                }
                this.instertPointcount = json["insertPointcount"];
                var paths = json["path"];
                for (var key in paths) {
                    var item = new pointitem();
                    var pointnode = paths[key];
                    var pointtype = pointnode["type"];
                    switch (pointtype) {
                        case "VertexPoint":
                            item.type = epointtype.VertexPoint;
                            break;
                        case "ControlPoint":
                            item.type = epointtype.ControlPoint;
                            break;
                    }
                    var pointlocation = pointnode["point"];
                    var arr = pointlocation.split(",");
                    item.point = new gd3d.math.vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                    this.items.push(item);
                }
                this.getpaths();
                this.items.length = 0;
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines[i].length = 0;
                }
                this.lines.length = 0;
            };
            pathasset.prototype.getpaths = function () {
                var line = new Array();
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (i == 0) {
                        line.push(item.point);
                        this.lines.push(line);
                    }
                    else if (i == this.items.length - 1) {
                        if (this.type == pathtype.loop) {
                            if (item.type == epointtype.VertexPoint) {
                                line.push(item.point);
                                line = new Array();
                                line.push(item.point);
                                line.push(this.items[0].point);
                                this.lines.push(line);
                            }
                            else {
                                line.push(item.point);
                                line.push(this.items[0].point);
                            }
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                    else {
                        if (item.type == epointtype.VertexPoint) {
                            line.push(item.point);
                            line = new Array();
                            line.push(item.point);
                            this.lines.push(line);
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                }
                var linecount = this.lines.length;
                var pathindex = 0;
                for (var i = 0; i < linecount; i++) {
                    if (i == linecount - 1) {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / (this.instertPointcount - 1);
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                    else {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / this.instertPointcount;
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                }
            };
            pathasset.prototype.getBeisaierPointAlongCurve = function (points, rate, clearflag) {
                if (clearflag === void 0) { clearflag = false; }
                var length = points.length;
                if (points.length < 2) {
                    console.log("計算貝塞爾需要超過2個點");
                    return;
                }
                if (length == 2) {
                    var out = new gd3d.math.vector3();
                    this.vec3Lerp(points[0], points[1], rate, out);
                    if (clearflag) {
                        points.length = 0;
                    }
                    return out;
                }
                var temptpoints = [];
                for (var i = 0; i < length - 1; i++) {
                    var temp = gd3d.math.pool.new_vector3();
                    this.vec3Lerp(points[i], points[i + 1], rate, temp);
                    temptpoints[i] = temp;
                }
                if (clearflag) {
                    points.length = 0;
                }
                return this.getBeisaierPointAlongCurve(temptpoints, rate, true);
            };
            pathasset.prototype.vec3Lerp = function (start, end, lerp, out) {
                gd3d.math.vec3Subtract(end, start, out);
                gd3d.math.vec3ScaleByNum(out, lerp, out);
                gd3d.math.vec3Add(start, out, out);
            };
            pathasset.ClassName = "pathasset";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], pathasset.prototype, "name", void 0);
            pathasset = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], pathasset);
            return pathasset;
        }());
        framework.pathasset = pathasset;
        var pathtype;
        (function (pathtype) {
            pathtype[pathtype["once"] = 0] = "once";
            pathtype[pathtype["loop"] = 1] = "loop";
            pathtype[pathtype["pingpong"] = 2] = "pingpong";
        })(pathtype = framework.pathtype || (framework.pathtype = {}));
        var epointtype;
        (function (epointtype) {
            epointtype[epointtype["VertexPoint"] = 0] = "VertexPoint";
            epointtype[epointtype["ControlPoint"] = 1] = "ControlPoint";
        })(epointtype = framework.epointtype || (framework.epointtype = {}));
        var pointitem = (function () {
            function pointitem() {
            }
            return pointitem;
        }());
        framework.pointitem = pointitem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var prefab = (function () {
            function prefab(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "prefab_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            prefab.prototype.getName = function () {
                return this.name.getText();
            };
            prefab.prototype.getGUID = function () {
                return this.id.getID();
            };
            prefab.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            prefab.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            prefab.prototype.dispose = function () {
                this.trans.dispose();
                this.jsonstr = null;
            };
            prefab.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            prefab.prototype.getCloneTrans = function () {
                var temp = gd3d.io.cloneObj(this.trans);
                if (temp instanceof framework.transform)
                    return temp;
            };
            prefab.prototype.getCloneTrans2D = function () {
                var temp = gd3d.io.cloneObj(this.trans);
                if (temp instanceof framework.transform2D)
                    return temp;
            };
            prefab.prototype.apply = function (trans) {
                this.trans = trans;
            };
            prefab.prototype.Parse = function (jsonStr, assetmgr) {
                this.jsonstr = jsonStr;
                var jsonObj = JSON.parse(jsonStr);
                var type = jsonObj["type"];
                switch (type) {
                    case "transform":
                        this.trans = new framework.transform;
                        break;
                    case "transform2D":
                        this.trans = new framework.transform2D;
                        break;
                }
                if (type != null)
                    gd3d.io.deSerialize(jsonObj, this.trans, assetmgr, this.assetbundle);
            };
            prefab.ClassName = "prefab";
            prefab = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], prefab);
            return prefab;
        }());
        framework.prefab = prefab;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var rawscene = (function () {
            function rawscene(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "rawscene_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            rawscene.prototype.getName = function () {
                return this.name.getText();
            };
            rawscene.prototype.getGUID = function () {
                return this.id.getID();
            };
            rawscene.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            rawscene.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            rawscene.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            rawscene.prototype.resetLightMap = function (assetmgr) {
                this.lightmaps.length = 0;
                var lightmapCount = this.lightmapData.length;
                for (var i = 0; i < lightmapCount; i++) {
                    if (this.lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        var lightmapName = this.lightmapData[i].name;
                        var lightmap = assetmgr.getAssetByName(lightmapName);
                        if (lightmap)
                            lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
            };
            rawscene.prototype.Parse = function (txt, assetmgr) {
                var _json = JSON.parse(txt);
                this.rootNode = new framework.transform();
                this.rootNode.name = this.getName();
                gd3d.io.deSerialize(_json["rootNode"], this.rootNode, assetmgr, this.assetbundle);
                this.lightmaps = [];
                this.lightmapData = _json["lightmap"];
                var lightmapCount = this.lightmapData.length;
                for (var i = 0; i < lightmapCount; i++) {
                    if (this.lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        var lightmapName = this.lightmapData[i].name;
                        var lightmap = assetmgr.getAssetByName(lightmapName, this.assetbundle);
                        if (lightmap) {
                            lightmap.use();
                            this.lightmaps.push(lightmap);
                        }
                    }
                }
                var fogData = _json["fog"];
                if (fogData != undefined) {
                    this.fog = new Fog();
                    this.fog._Start = fogData["_Start"];
                    this.fog._End = fogData["_End"];
                    var cor = fogData["_Color"];
                    if (typeof (cor) == "string") {
                        var array = cor.split(",");
                        this.fog._Color = new gd3d.math.vector4(parseFloat(array[0]), parseFloat(array[1]), parseFloat(array[2]), parseFloat(array[3]));
                    }
                    else
                        this.fog._Color = cor;
                    this.fog._Density = fogData["_Density"];
                }
                var nav = _json["navmesh"];
                if (nav != undefined && nav.data != null) {
                    this.navMeshJson = nav.data;
                }
            };
            rawscene.prototype.getSceneRoot = function () {
                return gd3d.io.cloneObj(this.rootNode);
            };
            rawscene.prototype.useLightMap = function (scene) {
                scene.lightmaps.length = 0;
                for (var i = 0; i < this.lightmaps.length; i++) {
                    scene.lightmaps.push(this.lightmaps[i]);
                }
            };
            rawscene.prototype.useFog = function (scene) {
                scene.fog = this.fog;
            };
            rawscene.prototype.useNavMesh = function (scene) {
                var loaded = false;
                if (this.navMeshJson == null || this.navMeshJson == "")
                    return loaded;
                framework.NavMeshLoadManager.Instance.loadNavMeshByDate(this.navMeshJson, scene.app, function () {
                    loaded = true;
                });
                return loaded;
            };
            rawscene.prototype.dispose = function () {
                if (this.rootNode) {
                    this.rootNode.dispose();
                }
                for (var key in this.lightmaps) {
                    this.lightmaps[key].unuse(true);
                }
            };
            rawscene.ClassName = "rawscene";
            rawscene = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], rawscene);
            return rawscene;
        }());
        framework.rawscene = rawscene;
        var Fog = (function () {
            function Fog() {
            }
            return Fog;
        }());
        framework.Fog = Fog;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var shader = (function () {
            function shader(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.passes = {};
                this.defaultMapUniform = {};
                this.layer = framework.RenderLayerEnum.Common;
                if (!assetName) {
                    assetName = "shader_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            shader.prototype.getName = function () {
                return this.name.getText();
            };
            shader.prototype.getGUID = function () {
                return this.id.getID();
            };
            shader.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            shader.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            shader.prototype.dispose = function () {
            };
            shader.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            shader.prototype.parse = function (assetmgr, json) {
                this._parseProperties(assetmgr, json.properties);
                if (json.layer) {
                    var layer = json.layer;
                    if (layer == "transparent")
                        this.layer = framework.RenderLayerEnum.Transparent;
                    else if (layer == "overlay")
                        this.layer = framework.RenderLayerEnum.Overlay;
                    else if (layer == "common")
                        this.layer = framework.RenderLayerEnum.Common;
                }
                var passes = json.passes;
                this.passes = {};
                for (var key in passes) {
                    var passbass = passes[key];
                    var curpasses;
                    if (key == "base" || key == "lightmap" || key == "skin" || key == "quad") {
                    }
                    else if (key.indexOf("base_") == 0 || key.indexOf("lightmap_") == 0 || key.indexOf("skin_") == 0) {
                    }
                    else {
                        continue;
                    }
                    this.passes[key] = [];
                    for (var i = 0; i < passbass.length; i++) {
                        this.passes[key].push(this._parsePass(assetmgr, passbass[i], key));
                    }
                }
                if (this.passes["base"] == undefined) {
                    throw new Error("do not have base passgroup.");
                }
                this.fillUnDefUniform(this.passes["base"][0]);
            };
            shader.prototype._parseProperties = function (assetmgr, properties) {
                this.defaultMapUniform = {};
                for (var index in properties) {
                    var property = properties[index];
                    var words = property.match(framework.RegexpUtil.floatRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.rangeRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.vectorRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.textureRegexp);
                    if (words == null) {
                        alert(this.getName() + " property error! info:\n" + property);
                        return;
                    }
                    if (words != null && words.length >= 4) {
                        var key = words[1];
                        var showName = words[2];
                        var type = words[3].toLowerCase();
                        switch (type) {
                            case "float":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float, value: parseFloat(words[4]) };
                                break;
                            case "range":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float, value: parseFloat(words[6]), min: parseFloat(words[4]), max: parseFloat(words[5]) };
                                break;
                            case "vector":
                                var _vector = new gd3d.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float4, value: _vector };
                                break;
                            case "color":
                                var _color = new gd3d.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float4, value: _color, becolor: true };
                                break;
                            case "texture":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Texture, value: assetmgr.getDefaultTexture(words[4]) };
                                break;
                            default:
                                alert(this.getName() + " property error! unknown type : " + type);
                                break;
                        }
                    }
                }
            };
            shader.prototype._parsePass = function (assetmgr, json, type) {
                var pass = new gd3d.render.glDrawPass();
                var vs = json["vs"];
                var fs = json["fs"];
                switch (json["showface"]) {
                    case "cw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CW;
                        break;
                    case "ccw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                        break;
                    default:
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                        break;
                }
                var blendmode = gd3d.render.BlendModeEnum.Close;
                switch (json["zwrite"]) {
                    case "off":
                        pass.state_zwrite = false;
                        break;
                    case "on":
                    default:
                        pass.state_zwrite = true;
                        break;
                }
                pass.state_ztest = true;
                switch (json["ztest"]) {
                    case "greater":
                        pass.state_ztest_method = gd3d.render.webglkit.GREATER;
                        break;
                    case "gequal":
                        pass.state_ztest_method = gd3d.render.webglkit.GEQUAL;
                        break;
                    case "less":
                        pass.state_ztest_method = gd3d.render.webglkit.LESS;
                        break;
                    case "equal":
                        pass.state_ztest_method = gd3d.render.webglkit.EQUAL;
                        break;
                    case "notequal":
                        pass.state_ztest_method = gd3d.render.webglkit.NOTEQUAL;
                        break;
                    case "always":
                    case "off":
                        pass.state_ztest = false;
                        break;
                    case "never":
                        pass.state_ztest_method = gd3d.render.webglkit.NEVER;
                        break;
                    case "lequal":
                    default:
                        pass.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                        break;
                }
                switch (json["blendmode"]) {
                    case "add":
                        blendmode = gd3d.render.BlendModeEnum.Add;
                        break;
                    case "addpremult":
                        blendmode = gd3d.render.BlendModeEnum.Add_PreMultiply;
                        break;
                    case "blend":
                        blendmode = gd3d.render.BlendModeEnum.Blend;
                        break;
                    case "blendpremult":
                        blendmode = gd3d.render.BlendModeEnum.Blend_PreMultiply;
                        break;
                }
                pass.setAlphaBlend(blendmode);
                var program = assetmgr.shaderPool.linkProgrambyPassType(assetmgr.webgl, type, vs, fs);
                pass.setProgram(program);
                if (this.layer == framework.RenderLayerEnum.Overlay) {
                    pass.state_ztest = true;
                    pass.state_zwrite = true;
                    pass.state_ztest_method = gd3d.render.webglkit.ALWAYS;
                }
                return pass;
            };
            shader.prototype.fillUnDefUniform = function (pass) {
                for (var key in pass.mapuniforms) {
                    var item = pass.mapuniforms[key];
                    if (framework.uniformSetter.autoUniformDic[item.name] == null && this.defaultMapUniform[item.name] == null) {
                        switch (item.type) {
                            case gd3d.render.UniformTypeEnum.Float:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float, value: 0 };
                                break;
                            case gd3d.render.UniformTypeEnum.Floatv:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4:
                                if (item.name.indexOf("_ST") >= 0 || item.name.indexOf("_st") >= 0) {
                                    this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4, value: new gd3d.math.vector4(1, 1, 0, 0) };
                                }
                                else {
                                    this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4, value: new gd3d.math.vector4(1, 1, 1, 1) };
                                }
                                break;
                            case gd3d.render.UniformTypeEnum.Float4v:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4x4:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4x4v:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Texture:
                                var tex = framework.sceneMgr.app.getAssetMgr().getDefaultTexture("white");
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Texture, value: tex };
                                break;
                            case gd3d.render.UniformTypeEnum.CubeTexture:
                                var cubetex = framework.sceneMgr.app.getAssetMgr().getDefaultCubeTexture("white");
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.CubeTexture, value: cubetex };
                                break;
                        }
                    }
                }
            };
            shader.ClassName = "shader";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], shader.prototype, "name", void 0);
            shader = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], shader);
            return shader;
        }());
        framework.shader = shader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var sprite = (function () {
            function sprite(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.border = new gd3d.math.border();
                if (!assetName) {
                    assetName = "sprite_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            sprite.prototype.getName = function () {
                return this.name.getText();
            };
            sprite.prototype.getGUID = function () {
                return this.id.getID();
            };
            sprite.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            sprite.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            sprite.prototype.dispose = function () {
                if (this.texture != null) {
                    this.texture.unuse(true);
                }
            };
            sprite.prototype.caclByteLength = function () {
                var total = 0;
                if (this._texture) {
                    total += this._texture.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(sprite.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "urange", {
                get: function () {
                    if (this._urange == null) {
                        this._urange = new gd3d.math.vector2();
                        this._urange.x = this.rect.x / this._texture.glTexture.width;
                        this._urange.y = (this.rect.x + this.rect.w) / this._texture.glTexture.width;
                    }
                    return this._urange;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "vrange", {
                get: function () {
                    if (this._vrange == null) {
                        this._vrange = new gd3d.math.vector2();
                        this._vrange.x = this.rect.y / this._texture.glTexture.height;
                        this._vrange.y = (this.rect.y + this.rect.h) / this._texture.glTexture.height;
                    }
                    return this._vrange;
                },
                enumerable: true,
                configurable: true
            });
            sprite.ClassName = "sprite";
            sprite = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], sprite);
            return sprite;
        }());
        framework.sprite = sprite;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var textasset = (function () {
            function textasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            textasset.prototype.getName = function () {
                return this.name.getText();
            };
            textasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            textasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            textasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            textasset.prototype.dispose = function () {
                this.content == null;
            };
            textasset.prototype.caclByteLength = function () {
                if (this.content) {
                    return gd3d.math.caclStringByteLength(this.content);
                }
            };
            textasset.ClassName = "textasset";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], textasset.prototype, "name", void 0);
            textasset = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], textasset);
            return textasset;
        }());
        framework.textasset = textasset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var texture = (function () {
            function texture(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            texture.prototype.getName = function () {
                return this.name.getText();
            };
            texture.prototype.getGUID = function () {
                return this.id.getID();
            };
            texture.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            texture.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            texture.prototype.dispose = function () {
                if (this && this.glTexture) {
                    this.glTexture.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                }
            };
            texture.prototype.caclByteLength = function () {
                if (this.glTexture) {
                    return this.glTexture.caclByteLength();
                }
            };
            Object.defineProperty(texture.prototype, "realName", {
                get: function () {
                    return this._realName;
                },
                set: function (name) {
                    this._realName = name;
                },
                enumerable: true,
                configurable: true
            });
            texture.ClassName = "texture";
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], texture.prototype, "name", void 0);
            texture = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], texture);
            return texture;
        }());
        framework.texture = texture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AudioEx = (function () {
            function AudioEx() {
                try {
                    var _AudioContext = window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"] || window["msAudioContext"];
                    this.audioContext = new _AudioContext();
                    console.log("audio Context inited");
                }
                catch (e) {
                    console.error("!Your browser does not support AudioContext");
                }
            }
            AudioEx.instance = function () {
                if (AudioEx.g_this == null)
                    AudioEx.g_this = new AudioEx();
                return AudioEx.g_this;
            };
            AudioEx.prototype.clickInit = function () {
                if (!this.isAvailable())
                    return;
                if (this.audioContext != null) {
                    var buffer = this.audioContext.createBuffer(1, 1, 22050);
                    var source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(this.audioContext.destination);
                    source.start();
                }
            };
            AudioEx.prototype.loadAudioBufferFromArrayBuffer = function (ab, fun) {
                this.audioContext.decodeAudioData(ab, function (audiobuffer) {
                    fun(audiobuffer, null);
                });
            };
            AudioEx.prototype.loadAudioBuffer = function (url, fun) {
                var _this = this;
                AudioEx.loadArrayBuffer(url, function (_ab, __err) {
                    if (__err != null)
                        fun(null, __err);
                    else {
                        _this.audioContext.decodeAudioData(_ab, function (audiobuffer) {
                            fun(audiobuffer, null);
                        });
                    }
                });
            };
            AudioEx.prototype.isAvailable = function () {
                return this.audioContext ? true : false;
            };
            AudioEx.prototype.createAudioChannel = function (be3DSound) {
                if (!this.audioContext)
                    return;
                var cc = new AudioChannel();
                cc.source = this.audioContext.createBufferSource();
                cc.gainNode = this.audioContext.createGain();
                cc.source.connect(cc.gainNode);
                if (be3DSound) {
                    cc.pannerNode = this.audioContext.createPanner();
                    cc.gainNode.connect(cc.pannerNode);
                    cc.pannerNode.connect(this.audioContext.destination);
                }
                else {
                    cc.gainNode.connect(this.audioContext.destination);
                }
                cc.gainNode.gain.value = 1;
                return cc;
            };
            AudioEx.loadArrayBuffer = function (url, fun) {
                var req = new XMLHttpRequest();
                req.open("GET", url);
                req.responseType = "arraybuffer";
                req.onreadystatechange = function () {
                    if (req.readyState == 4) {
                        if (req.status == 404)
                            fun(null, new Error("onerr 404"));
                        else
                            fun(req.response, null);
                    }
                };
                req.onerror = function () {
                    fun(null, new Error("onerr in req:"));
                };
                req.send();
            };
            return AudioEx;
        }());
        framework.AudioEx = AudioEx;
        var AudioChannel = (function () {
            function AudioChannel() {
            }
            Object.defineProperty(AudioChannel.prototype, "volume", {
                get: function () {
                    return this.gainNode.gain.value;
                },
                set: function (val) {
                    val = val > 1 ? 1 : val;
                    val = val <= 0 ? 0 : val;
                    this.gainNode.gain.value = val;
                },
                enumerable: true,
                configurable: true
            });
            AudioChannel.prototype.stop = function () {
                if (this.source != null) {
                    this.source.stop();
                    this.source = null;
                }
                this.isplay = false;
            };
            return AudioChannel;
        }());
        framework.AudioChannel = AudioChannel;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var aniplayer = (function () {
            function aniplayer() {
                this.autoplay = true;
                this._playClip = null;
                this.clipnames = {};
                this.bePlay = false;
                this.speed = 1.0;
                this.beCross = false;
                this.beRevert = false;
                this._playTimer = 0;
                this._playFrameid = 0;
                this._playCount = 0;
                this.crossTotalTime = 0;
                this.crossRestTimer = 0;
                this.crossPercentage = 0;
                this.carelist = {};
                this.careBoneMat = {};
                this.inversTpos = {};
                this.startepose = {};
                this._awaitClips = [];
                this._allClipNames = [];
                this.collected = false;
                this.temptMat = gd3d.math.pool.new_matrix();
                this.playEndDic = {};
                this.beActivedEndFrame = false;
                this.endFrame = 0;
                this.beActived = false;
                this.boneCache = {};
            }
            Object.defineProperty(aniplayer.prototype, "PlayFrameID", {
                get: function () {
                    return this._playFrameid;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "currentAniclipName", {
                get: function () {
                    if (this._playClip) {
                        return this._playClip.getName();
                    }
                    else {
                        return null;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "currentAniclip", {
                get: function () {
                    return this._playClip;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "playCount", {
                get: function () { return this._playCount; },
                enumerable: true,
                configurable: true
            });
            aniplayer.prototype.init = function () {
                for (var i = 0; i < this.bones.length; i++) {
                    var _info = this.bones[i];
                    var name_2 = _info.name;
                    var nb = framework.PoseBoneMatrix.create();
                    nb.r = _info.tposeq;
                    nb.t = _info.tposep;
                    nb.invert();
                    this.inversTpos[name_2] = nb;
                    this.startepose[name_2] = this.startPos[i];
                }
                var asbones = this.gameObject.getComponentsInChildren("asbone");
                for (var key in asbones) {
                    var trans = asbones[key].gameObject.transform;
                    this.carelist[trans.name] = trans;
                    this.careBoneMat[trans.name] = framework.PoseBoneMatrix.create();
                    this.careBoneMat[trans.name].r = gd3d.math.pool.new_quaternion();
                    this.careBoneMat[trans.name].t = gd3d.math.pool.new_vector3();
                }
            };
            aniplayer.prototype.addToCareList = function (bone) {
                if (this.carelist[bone.name] != null)
                    return;
                this.carelist[bone.name] = bone;
                this.careBoneMat[bone.name] = framework.PoseBoneMatrix.create();
                this.careBoneMat[bone.name].r = gd3d.math.pool.new_quaternion();
                this.careBoneMat[bone.name].t = gd3d.math.pool.new_vector3();
            };
            aniplayer.prototype.awaitLoadClipNames = function () {
                this.collectClipNames();
                return this._awaitClips;
            };
            aniplayer.prototype.allClipNames = function () {
                this.collectClipNames();
                return this._allClipNames;
            };
            aniplayer.prototype.collectClipNames = function () {
                var _this = this;
                if (this.collected)
                    return;
                if (this.clips) {
                    this.clips.forEach(function (clip) {
                        if (clip) {
                            var cname = clip.getName();
                            _this._allClipNames.push(cname);
                            if (!_this.haveClip(cname)) {
                                _this._awaitClips.push(cname);
                            }
                        }
                    });
                }
                this.collected = true;
            };
            aniplayer.prototype.addClipByNameLoad = function (_assetMgr, resPath, clipName, callback) {
                var _this = this;
                var url = resPath + "/" + clipName;
                _assetMgr.load(url, gd3d.framework.AssetTypeEnum.Aniclip, function (sta) {
                    if (sta.isfinish) {
                        var clip = sta.resstateFirst.res;
                        _this.addClip(clip);
                    }
                    if (callback) {
                        callback(sta, clipName);
                    }
                });
            };
            aniplayer.prototype.addClip = function (clip) {
                if (clip != null) {
                    this.clipnames[clip.getName()] = clip;
                }
            };
            aniplayer.prototype.haveClip = function (name) {
                return this.clipnames[name] != null;
            };
            aniplayer.prototype.getClip = function (name) {
                return this.clipnames[name];
            };
            aniplayer.prototype.start = function () {
                if (this.bones != null) {
                    this.init();
                }
            };
            aniplayer.prototype.onPlay = function () {
            };
            aniplayer.prototype.update = function (delta) {
                if (!this.bePlay)
                    return;
                this.checkFrameId(delta);
                if (!this.bePlay)
                    return;
                if (this.beCross) {
                    this.crossRestTimer -= delta * this.speed;
                    this.crossPercentage = this.crossRestTimer / this.crossTotalTime;
                    if (this.crossRestTimer <= 0) {
                        this.beCross = false;
                    }
                }
                this.curFrame = this._playClip.frames[this._playFrameid];
                if (this._playClip.indexDic.len)
                    for (var bonename in this.carelist) {
                        var trans = this.carelist[bonename];
                        var transMat = this.careBoneMat[bonename];
                        var index = this._playClip.indexDic[bonename];
                        if (index) {
                            if (this.beCross && this.lastFrame) {
                                transMat.lerpInWorldWithData(this.inversTpos[bonename], this.lastFrame[bonename], this.curFrame, index * 7 + 1, 1 - this.crossPercentage);
                            }
                            else {
                                transMat.r.x = this.curFrame[index * 7 + 1];
                                transMat.r.y = this.curFrame[index * 7 + 2];
                                transMat.r.z = this.curFrame[index * 7 + 3];
                                transMat.r.w = this.curFrame[index * 7 + 4];
                                transMat.t.x = this.curFrame[index * 7 + 5];
                                transMat.t.y = this.curFrame[index * 7 + 6];
                                transMat.t.z = this.curFrame[index * 7 + 7];
                            }
                            var fmat = framework.PoseBoneMatrix.sMultiply(transMat, this.inversTpos[bonename]);
                            gd3d.math.matrixMakeTransformRTS(fmat.t, gd3d.math.pool.vector3_one, fmat.r, this.temptMat);
                            gd3d.math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), this.temptMat, this.temptMat);
                            trans.setWorldMatrix(this.temptMat);
                        }
                        else {
                            console.error("Bone: " + bonename + " Not Record in Aniclip(" + this._playClip.getName() + ").");
                        }
                    }
                this.recyclecache();
            };
            aniplayer.prototype.play = function (animName, onPlayEnd, speed, beRevert) {
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                var clip = this.clipnames[animName];
                if (clip == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (this.bePlay) {
                    this.OnClipPlayEnd();
                }
                this.beCross = false;
                this.beActivedEndFrame = false;
                this.playAniclip(clip, onPlayEnd, speed, beRevert);
            };
            aniplayer.prototype.playCross = function (animName, crosstimer, onPlayEnd, speed, beRevert) {
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                var clip = this.clipnames[animName];
                if (clip == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (this.bePlay) {
                    if (crosstimer > 0 && this.curFrame) {
                        this.recordeLastFrameData();
                        this.beCross = true;
                        this.crossTotalTime = crosstimer;
                        this.crossRestTimer = crosstimer;
                    }
                    else {
                        this.beCross = false;
                    }
                    this.OnClipPlayEnd();
                }
                this.beActivedEndFrame = false;
                this.playAniclip(clip, onPlayEnd, speed, beRevert);
            };
            aniplayer.prototype.playToXFrame = function (animName, endframe, crosstimer, onPlayEnd, speed) {
                if (crosstimer === void 0) { crosstimer = 0; }
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                var clip = this.clipnames[animName];
                if (clip == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (this.bePlay) {
                    if (crosstimer > 0 && this.curFrame) {
                        this.recordeLastFrameData();
                        this.beCross = true;
                        this.crossTotalTime = crosstimer;
                        this.crossRestTimer = crosstimer;
                    }
                    else {
                        this.beCross = false;
                    }
                    this.OnClipPlayEnd();
                }
                if (endframe >= 0) {
                    this.beActivedEndFrame = true;
                    this.endFrame = endframe;
                }
                else {
                    this.beActivedEndFrame = false;
                }
                this.playAniclip(clip, onPlayEnd, speed, false);
            };
            aniplayer.prototype.recordeLastFrameData = function () {
                if (this.lastFrame == null)
                    this.lastFrame = {};
                for (var key in this._playClip.bones) {
                    var bonename = this._playClip.bones[key];
                    if (!this.lastFrame[bonename]) {
                        this.lastFrame[bonename] = framework.PoseBoneMatrix.create();
                    }
                    var index = this._playClip.indexDic[bonename];
                    this.lastFrame[bonename].copyFromData(this.curFrame, index * 7 + 1);
                }
            };
            aniplayer.prototype.playAniclip = function (aniclip, onPlayEnd, speed, beRevert) {
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.beActived = true;
                this.bePlay = true;
                this._playTimer = 0;
                this._playFrameid = 0;
                this._playCount = 0;
                this._playClip = aniclip;
                this.playEndDic[aniclip.getName()] = onPlayEnd;
                this.speed = speed;
                this.beRevert = beRevert;
            };
            aniplayer.prototype.stop = function () {
                if (this.bePlay) {
                    this.OnClipPlayEnd();
                }
            };
            aniplayer.prototype.pause = function () {
                if (this.bePlay) {
                    this.bePlay = false;
                }
                else if (!this.bePlay && this._playClip) {
                    this.bePlay = true;
                }
            };
            aniplayer.prototype.isPlay = function () {
                return this.bePlay;
            };
            aniplayer.prototype.isStop = function () {
                return !this.bePlay;
            };
            aniplayer.prototype.remove = function () {
                if (this.clips)
                    this.clips.forEach(function (temp) {
                        if (temp)
                            temp.unuse();
                    });
                for (var key in this.lastFrame) {
                    framework.PoseBoneMatrix.recycle(this.lastFrame[key]);
                }
                for (var key in this.careBoneMat) {
                    framework.PoseBoneMatrix.recycle(this.careBoneMat[key]);
                }
                for (var key in this.boneCache) {
                    framework.PoseBoneMatrix.recycle(this.boneCache[key]);
                }
                this.clips.length = 0;
                this.bones.length = 0;
                this.startPos.length = 0;
                this.startepose = null;
                this._playClip = null;
                this.curFrame = null;
                this.lastFrame = null;
                this.careBoneMat = null;
                this.boneCache = null;
                delete this.inversTpos;
                delete this.carelist;
            };
            aniplayer.prototype.clone = function () {
            };
            aniplayer.prototype.checkFrameId = function (delay) {
                this._playTimer += delay * this.speed;
                this._playFrameid = (this._playClip.fps * this._playTimer) | 0;
                if (this._playClip.loop) {
                    this._playCount = Math.floor(this._playFrameid / this._playClip.frameCount);
                    this._playFrameid %= this._playClip.frameCount;
                }
                else {
                    if (this.beActivedEndFrame && this._playFrameid >= this.endFrame) {
                        this._playFrameid = this.endFrame;
                        this.OnClipPlayEnd();
                    }
                    else if (this._playFrameid > this._playClip.frameCount - 1) {
                        this._playFrameid = this._playClip.frameCount - 1;
                        this.OnClipPlayEnd();
                    }
                }
                if (this.beRevert) {
                    this._playFrameid = this._playClip.frameCount - this._playFrameid - 1;
                }
            };
            aniplayer.prototype.OnClipPlayEnd = function () {
                var Clipame = this._playClip ? this._playClip.getName() : "";
                this._playClip = null;
                this.bePlay = false;
                this.beCross = false;
                var endFunc = this.playEndDic[Clipame];
                if (endFunc) {
                    endFunc();
                }
            };
            aniplayer.prototype.recyclecache = function () {
                for (var key in this.boneCache) {
                    framework.PoseBoneMatrix.recycle(this.boneCache[key]);
                }
                this.boneCache = {};
            };
            aniplayer.prototype.fillPoseData = function (data, bones) {
                if (!this.bePlay) {
                    if (this.beActived)
                        return;
                    for (var i = 0, len = bones.length; i < len; i++) {
                        var bonename = bones[i].name;
                        var boneMat = this.startepose[bonename];
                        data[i * 8 + 0] = boneMat.r.x;
                        data[i * 8 + 1] = boneMat.r.y;
                        data[i * 8 + 2] = boneMat.r.z;
                        data[i * 8 + 3] = boneMat.r.w;
                        data[i * 8 + 4] = boneMat.t.x;
                        data[i * 8 + 5] = boneMat.t.y;
                        data[i * 8 + 6] = boneMat.t.z;
                        data[i * 8 + 7] = 1;
                    }
                    return;
                }
                if (this._playClip.indexDic.len)
                    for (var i = 0, len = bones.length; i < len; i++) {
                        var bonename = bones[i].name;
                        var index = this._playClip.indexDic[bonename];
                        if (index != null) {
                            if (this.beCross && this.lastFrame) {
                                var boneMat = void 0;
                                if (this.careBoneMat[bonename]) {
                                    boneMat = this.careBoneMat[bonename];
                                }
                                else if (this.boneCache[bonename]) {
                                    boneMat = this.boneCache[bonename];
                                }
                                else {
                                    var mat = framework.PoseBoneMatrix.create();
                                    mat.lerpInWorldWithData(this.inversTpos[bonename], this.lastFrame[bonename], this.curFrame, index * 7 + 1, 1 - this.crossPercentage);
                                    this.boneCache[bonename] = mat;
                                }
                                data[i * 8 + 0] = boneMat.r.x;
                                data[i * 8 + 1] = boneMat.r.y;
                                data[i * 8 + 2] = boneMat.r.z;
                                data[i * 8 + 3] = boneMat.r.w;
                                data[i * 8 + 4] = boneMat.t.x;
                                data[i * 8 + 5] = boneMat.t.y;
                                data[i * 8 + 6] = boneMat.t.z;
                                data[i * 8 + 7] = 1;
                            }
                            else {
                                data[i * 8 + 0] = this.curFrame[index * 7 + 1];
                                data[i * 8 + 1] = this.curFrame[index * 7 + 2];
                                data[i * 8 + 2] = this.curFrame[index * 7 + 3];
                                data[i * 8 + 3] = this.curFrame[index * 7 + 4];
                                data[i * 8 + 4] = this.curFrame[index * 7 + 5];
                                data[i * 8 + 5] = this.curFrame[index * 7 + 6];
                                data[i * 8 + 6] = this.curFrame[index * 7 + 7];
                                data[i * 8 + 7] = 1;
                            }
                        }
                        else {
                        }
                    }
            };
            aniplayer.ClassName = "aniplayer";
            __decorate([
                gd3d.reflect.Field("animationClip[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "clips", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], aniplayer.prototype, "autoplay", void 0);
            __decorate([
                gd3d.reflect.Field("tPoseInfo[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "bones", void 0);
            __decorate([
                gd3d.reflect.Field("PoseBoneMatrix[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "startPos", void 0);
            aniplayer = __decorate([
                gd3d.reflect.nodeComponent
            ], aniplayer);
            return aniplayer;
        }());
        framework.aniplayer = aniplayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var tPoseInfo = (function () {
            function tPoseInfo() {
            }
            tPoseInfo.ClassName = "tPoseInfo";
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], tPoseInfo.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], tPoseInfo.prototype, "tposep", void 0);
            __decorate([
                gd3d.reflect.Field("quaternion"),
                __metadata("design:type", gd3d.math.quaternion)
            ], tPoseInfo.prototype, "tposeq", void 0);
            tPoseInfo = __decorate([
                gd3d.reflect.SerializeType
            ], tPoseInfo);
            return tPoseInfo;
        }());
        framework.tPoseInfo = tPoseInfo;
        var PlayStyle;
        (function (PlayStyle) {
            PlayStyle[PlayStyle["NormalPlay"] = 0] = "NormalPlay";
            PlayStyle[PlayStyle["FramePlay"] = 1] = "FramePlay";
            PlayStyle[PlayStyle["PingPang"] = 2] = "PingPang";
        })(PlayStyle = framework.PlayStyle || (framework.PlayStyle = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var asbone = (function () {
            function asbone() {
            }
            asbone.prototype.start = function () {
            };
            asbone.prototype.onPlay = function () {
            };
            asbone.prototype.update = function (delta) {
            };
            asbone.prototype.remove = function () {
            };
            asbone.prototype.clone = function () {
            };
            asbone.ClassName = "asbone";
            asbone = __decorate([
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], asbone);
            return asbone;
        }());
        framework.asbone = asbone;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AudioListener = (function () {
            function AudioListener() {
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            AudioListener.prototype.start = function () {
                this.listener = framework.AudioEx.instance().audioContext.listener;
            };
            AudioListener.prototype.onPlay = function () {
            };
            AudioListener.prototype.update = function (delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ) {
                    this.listener.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            };
            AudioListener.prototype.remove = function () {
            };
            AudioListener.prototype.clone = function () {
            };
            AudioListener.ClassName = "AudioListener";
            AudioListener = __decorate([
                gd3d.reflect.nodeComponent
            ], AudioListener);
            return AudioListener;
        }());
        framework.AudioListener = AudioListener;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AudioPlayer = (function () {
            function AudioPlayer() {
                this.be3DSound = true;
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            AudioPlayer.prototype.play = function (buffer, beLoop, volume, onended) {
                if (beLoop === void 0) { beLoop = false; }
                if (volume === void 0) { volume = 0; }
                if (this.audioChannel != null) {
                    if (this.audioChannel.isplay) {
                        this.stop();
                    }
                    this.audioChannel = null;
                }
                if (!(this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound)))
                    return;
                this.buffer = buffer;
                this.volume = volume;
                var c = this.audioChannel;
                c.source.loop = this.beLoop;
                c.source.buffer = this.buffer;
                c.volume = this.volume;
                c.source.start();
                c.isplay = true;
                if (!this.beLoop) {
                    c.source.onended = function () {
                        c.isplay = false;
                        c.source = null;
                        if (onended != undefined)
                            onended();
                    };
                }
            };
            AudioPlayer.prototype.stop = function () {
                if (this.audioChannel != null) {
                    this.audioChannel.stop();
                }
            };
            Object.defineProperty(AudioPlayer.prototype, "volume", {
                get: function () {
                    return this.audioChannel == null ? -1 : this.audioChannel.volume;
                },
                set: function (val) {
                    this.audioChannel == null ? 0 : this.audioChannel.volume = val;
                },
                enumerable: true,
                configurable: true
            });
            AudioPlayer.prototype.isPlaying = function () {
                return this.audioChannel == undefined ? false : this.audioChannel.isplay;
            };
            AudioPlayer.prototype.start = function () {
                this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound);
            };
            AudioPlayer.prototype.onPlay = function () {
            };
            AudioPlayer.prototype.update = function (delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.audioChannel && (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ)) {
                    this.audioChannel.pannerNode.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            };
            AudioPlayer.prototype.remove = function () {
            };
            AudioPlayer.prototype.clone = function () {
            };
            AudioPlayer.ClassName = "AudioPlayer";
            AudioPlayer = __decorate([
                gd3d.reflect.nodeComponent
            ], AudioPlayer);
            return AudioPlayer;
        }());
        framework.AudioPlayer = AudioPlayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var BeBillboard = (function () {
            function BeBillboard() {
                this.beActive = true;
                this.target = null;
            }
            BeBillboard.prototype.start = function () {
            };
            BeBillboard.prototype.onPlay = function () {
            };
            BeBillboard.prototype.update = function (delta) {
                if (!this.beActive || this.target == null)
                    return;
                this.gameObject.transform.lookat(this.target);
            };
            BeBillboard.prototype.remove = function () {
            };
            BeBillboard.prototype.clone = function () {
            };
            BeBillboard.prototype.setActive = function (active) {
                this.beActive = active;
            };
            BeBillboard.prototype.setTarget = function (trans) {
                this.target = trans;
            };
            BeBillboard.ClassName = "BeBillboard";
            BeBillboard = __decorate([
                gd3d.reflect.nodeComponent
            ], BeBillboard);
            return BeBillboard;
        }());
        framework.BeBillboard = BeBillboard;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var behaviour = (function () {
            function behaviour() {
            }
            behaviour.prototype.start = function () {
            };
            behaviour.prototype.onPlay = function () {
            };
            behaviour.prototype.update = function (delta) {
            };
            behaviour.prototype.remove = function () {
            };
            behaviour.prototype.clone = function () {
            };
            return behaviour;
        }());
        framework.behaviour = behaviour;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var bloomctr = (function () {
            function bloomctr() {
                this._bloomIntensity = 1.4;
                this._bloomThreshold = 0.5;
                this._blurSpread = 3;
                this.tag = "__bloomtag__";
                this._init = false;
            }
            Object.defineProperty(bloomctr.prototype, "bloomThreshold", {
                get: function () { return this._bloomThreshold; },
                set: function (value) {
                    this._bloomThreshold = value;
                    if (!this.material || !this.material_1 || !this.material_2)
                        return;
                    this.material.setFloat("_bloomThreshold", this._bloomThreshold);
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(bloomctr.prototype, "bloomIntensity", {
                get: function () { return this._bloomIntensity; },
                set: function (value) {
                    this._bloomIntensity = value;
                    if (!this.material || !this.material_3)
                        return;
                    this.material_3.setFloat("_bloomIntensity", this._bloomIntensity);
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(bloomctr.prototype, "blurSpread", {
                get: function () { return this._blurSpread; },
                set: function (value) {
                    this._blurSpread = value;
                    if (!this.material_1 || !this.material_2)
                        return;
                    var v4_1 = gd3d.math.pool.new_vector4();
                    var v4_2 = gd3d.math.pool.new_vector4();
                    v4_1.x = value;
                    v4_1.y = 0;
                    v4_2.x = 0;
                    v4_2.y = value;
                    this.material_1.setVector4("_blurSpread", v4_1);
                    this.material_2.setVector4("_blurSpread", v4_2);
                },
                enumerable: true,
                configurable: true
            });
            ;
            bloomctr.prototype.init = function () {
                var sh = this.scene.app.getAssetMgr().getShader("bloom.shader.json");
                if (!sh) {
                    console.warn("bloom.shader.json not find");
                    return;
                }
                var psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material = post0.material;
                this.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", textcolor);
                post0.material.setFloat("_bloomIntensity", 1.2);
                post0.material.setFloat("_bloomThreshold", this._bloomThreshold);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0, 0, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var threTex = new framework.texture("_threshold");
                threTex.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_1 = post0.material;
                this.material_1.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", threTex);
                post0.material.setTexture("_BlurTex", threTex);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(this._blurSpread, 0, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var hBlur = new framework.texture("_blur0");
                hBlur.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_2 = post0.material;
                this.material_2.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", hBlur);
                post0.material.setTexture("_BlurTex", hBlur);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0, this._blurSpread, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var hvBlur = new framework.texture("_blur1");
                hvBlur.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0[this.tag] = true;
                this.material_3 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", hvBlur);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 0.5);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0.5, 0.5, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                this._init = true;
            };
            bloomctr.prototype.start = function () {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            };
            bloomctr.prototype.onPlay = function () {
            };
            bloomctr.prototype.update = function (delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            };
            bloomctr.prototype.remove = function () {
                this._init = false;
                if (this.camera) {
                    var arr_1 = this.camera.postQueues;
                    var dArr = [];
                    for (var i = 0; i < arr_1.length; i++) {
                        var temp = arr_1[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(function (element) {
                        if (element) {
                            var idx = arr_1.indexOf(element);
                            if (idx != -1) {
                                arr_1.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            };
            bloomctr.prototype.clone = function () {
            };
            bloomctr.ClassName = "bloomctr";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], bloomctr.prototype, "bloomThreshold", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], bloomctr.prototype, "bloomIntensity", null);
            bloomctr = __decorate([
                gd3d.reflect.nodeComponent
            ], bloomctr);
            return bloomctr;
        }());
        framework.bloomctr = bloomctr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var helpv3 = new gd3d.math.vector3();
var helpv3_1 = new gd3d.math.vector3();
var helpv3_2 = new gd3d.math.vector3();
var helpv3_3 = new gd3d.math.vector3();
var helpv3_4 = new gd3d.math.vector3();
var helpv3_5 = new gd3d.math.vector3();
var helpv3_6 = new gd3d.math.vector3();
var helpv3_7 = new gd3d.math.vector3();
var helpv2 = new gd3d.math.vector2();
var helpv2_1 = new gd3d.math.vector2();
var helpmtx = new gd3d.math.matrix();
var helpmtx_1 = new gd3d.math.matrix();
var helpmtx_2 = new gd3d.math.matrix();
var helpmtx_3 = new gd3d.math.matrix();
var helprect = new gd3d.math.rect();
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var cameraPostQueue_Depth = (function () {
            function cameraPostQueue_Depth() {
                this.renderTarget = null;
            }
            cameraPostQueue_Depth.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                gd3d.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                camera._renderOnce(scene, context, "_depth");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Depth;
        }());
        framework.cameraPostQueue_Depth = cameraPostQueue_Depth;
        var cameraPostQueue_Quad = (function () {
            function cameraPostQueue_Quad() {
                this.renderTarget = null;
                this.material = new framework.material();
            }
            cameraPostQueue_Quad.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                gd3d.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0.3, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                var mesh = scene.app.getAssetMgr().getDefaultMesh("quad");
                context.drawtype = "";
                mesh.glMesh.bindVboBuffer(context.webgl);
                this.material.draw(context, mesh, mesh.submesh[0], "quad");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Quad;
        }());
        framework.cameraPostQueue_Quad = cameraPostQueue_Quad;
        var cameraPostQueue_Color = (function () {
            function cameraPostQueue_Color() {
                this.renderTarget = null;
            }
            cameraPostQueue_Color.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, false);
                camera._renderOnce(scene, context, "");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Color;
        }());
        framework.cameraPostQueue_Color = cameraPostQueue_Color;
        var camera = (function () {
            function camera() {
                this._near = 0.01;
                this._far = 1000;
                this.CullingMask = framework.CullingMask.everything ^ framework.CullingMask.editor;
                this._contextIdx = -1;
                this.clearOption_Color = true;
                this.clearOption_Depth = true;
                this.backgroundColor = new gd3d.math.color(0.5, 0.8, 1, 1);
                this.viewport = new gd3d.math.rect(0, 0, 1, 1);
                this.renderTarget = null;
                this.order = 0;
                this.overlays = [];
                this.lastCamMtx = new gd3d.math.matrix();
                this.lastCamRect = new gd3d.math.rect();
                this.paraArr = [0, 0, 0];
                this.matView = new gd3d.math.matrix;
                this.matProjP = new gd3d.math.matrix;
                this.matProjO = new gd3d.math.matrix;
                this.matProj = new gd3d.math.matrix;
                this.frameVecs = [];
                this.fov = 60 * Math.PI / 180;
                this.size = 2;
                this._opvalue = 1;
                this.postQueues = [];
                for (var i = 0; i < 8; i++) {
                    this.frameVecs.push(new gd3d.math.vector3());
                }
            }
            camera_1 = camera;
            Object.defineProperty(camera.prototype, "near", {
                get: function () {
                    return this._near;
                },
                set: function (val) {
                    if (this.opvalue > 0) {
                        if (val < 0.01)
                            val = 0.01;
                    }
                    if (val >= this.far)
                        val = this.far - 0.01;
                    this._near = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "far", {
                get: function () {
                    return this._far;
                },
                set: function (val) {
                    if (val <= this.near)
                        val = this.near + 0.01;
                    this._far = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "CurrContextIndex", {
                get: function () { return this._contextIdx; },
                enumerable: true,
                configurable: true
            });
            camera.prototype.markDirty = function () {
            };
            camera.prototype.start = function () {
            };
            camera.prototype.onPlay = function () {
            };
            camera.prototype.update = function (delta) {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (!this.overlays[i].init) {
                        this.overlays[i].start(this);
                        this.overlays[i].init = true;
                    }
                    this.overlays[i].update(delta);
                }
            };
            camera.prototype.addOverLay = function (overLay) {
                this.overlays.push(overLay);
                this.sortOverLays(this.overlays);
            };
            camera.prototype.getOverLays = function () {
                return this.overlays;
            };
            camera.prototype.removeOverLay = function (overLay) {
                if (this.overlays == null)
                    return;
                var index = this.overlays.indexOf(overLay);
                if (index >= 0)
                    this.overlays.splice(index, 1);
                this.sortOverLays(this.overlays);
            };
            camera.prototype.sortOverLays = function (lays) {
                if (!lays || lays.length < 1)
                    return;
                lays.sort(function (a, b) {
                    return a.sortOrder - b.sortOrder;
                });
            };
            camera.prototype.calcViewMatrix = function (matrix) {
                var camworld = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixInverse(camworld, this.matView);
                gd3d.math.matrixClone(this.matView, matrix);
                return;
            };
            camera.prototype.calcViewPortPixel = function (app, viewPortPixel) {
                var w;
                var h;
                if (this.renderTarget == null) {
                    w = app.width;
                    h = app.height;
                }
                else {
                    w = this.renderTarget.width;
                    h = this.renderTarget.height;
                }
                viewPortPixel.x = w * this.viewport.x;
                viewPortPixel.y = h * this.viewport.y;
                viewPortPixel.w = w * this.viewport.w;
                viewPortPixel.h = h * this.viewport.h;
            };
            camera.prototype.calcProjectMatrix = function (asp, matrix) {
                if (this.opvalue > 0)
                    gd3d.math.matrixProject_PerspectiveLH(this.fov, asp, this.near, this.far, this.matProjP);
                if (this.opvalue < 1)
                    gd3d.math.matrixProject_OrthoLH(this.size * asp, this.size, this.near, this.far, this.matProjO);
                if (this.opvalue == 0)
                    gd3d.math.matrixClone(this.matProjO, this.matProj);
                else if (this.opvalue == 1)
                    gd3d.math.matrixClone(this.matProjP, this.matProj);
                else
                    gd3d.math.matrixLerp(this.matProjO, this.matProjP, this.opvalue, this.matProj);
                gd3d.math.matrixClone(this.matProj, matrix);
            };
            camera.prototype.creatRayByScreen = function (screenpos, app, shareRayCache) {
                if (shareRayCache === void 0) { shareRayCache = true; }
                var src1 = helpv3;
                gd3d.math.vec3Set(src1, screenpos.x, screenpos.y, 0);
                var src2 = helpv3_1;
                gd3d.math.vec3Set(src2, screenpos.x, screenpos.y, 1);
                var dest1 = helpv3_2;
                var dest2 = helpv3_3;
                this.calcWorldPosFromScreenPos(app, src1, dest1);
                this.calcWorldPosFromScreenPos(app, src2, dest2);
                var dir = helpv3_4;
                gd3d.math.vec3Subtract(dest2, dest1, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var ray;
                if (shareRayCache) {
                    if (!camera_1._shareRay) {
                        camera_1._shareRay = new gd3d.framework.ray(dest1, dir);
                    }
                    ray = camera_1._shareRay;
                    ray.set(dest1, dir);
                }
                else {
                    ray = new gd3d.framework.ray(dest1, dir);
                }
                return ray;
            };
            camera.prototype.calcWorldPosFromScreenPos = function (app, screenPos, outWorldPos) {
                var vpp = helprect;
                this.calcViewPortPixel(app, vpp);
                var vppos = helpv2;
                vppos.x = screenPos.x / vpp.w * 2 - 1;
                vppos.y = 1 - screenPos.y / vpp.h * 2;
                var matrixView = helpmtx;
                var matrixProject = helpmtx_1;
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = helpmtx_2;
                var matinv = helpmtx_3;
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                gd3d.math.matrixInverse(matrixViewProject, matinv);
                var src1 = helpv3;
                src1.x = vppos.x;
                src1.y = vppos.y;
                src1.z = screenPos.z;
                gd3d.math.matrixTransformVector3(src1, matinv, outWorldPos);
            };
            camera.prototype.calcScreenPosFromWorldPos = function (app, worldPos, outScreenPos) {
                var vpp = helprect;
                this.calcViewPortPixel(app, vpp);
                var matrixView = helpmtx;
                var matrixProject = helpmtx_1;
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = helpmtx_2;
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                var ndcPos = helpv3;
                gd3d.math.matrixTransformVector3(worldPos, matrixViewProject, ndcPos);
                outScreenPos.x = (ndcPos.x + 1) * vpp.w / 2;
                outScreenPos.y = (1 - ndcPos.y) * vpp.h / 2;
            };
            camera.prototype.calcCameraFrame = function (app) {
                var matrix = this.gameObject.transform.getWorldMatrix();
                var _vpp = gd3d.math.pool.new_rect();
                this.calcViewPortPixel(app, _vpp);
                if (gd3d.math.matrixEqual(this.lastCamMtx, matrix) && gd3d.math.rectEqul(this.lastCamRect, _vpp) &&
                    this.paraArr[0] == this.fov && this.paraArr[1] == this.near && this.paraArr[2] == this.far) {
                    return;
                }
                var near_h = this.near * Math.tan(this.fov * 0.5);
                var asp = _vpp.w / _vpp.h;
                var near_w = near_h * asp;
                var nearLT = helpv3;
                var nearLD = helpv3_1;
                var nearRT = helpv3_2;
                var nearRD = helpv3_3;
                gd3d.math.vec3Set(nearLT, -near_w, near_h, this.near);
                gd3d.math.vec3Set(nearLD, -near_w, -near_h, this.near);
                gd3d.math.vec3Set(nearRT, near_w, near_h, this.near);
                gd3d.math.vec3Set(nearRD, near_w, -near_h, this.near);
                var far_h = this.far * Math.tan(this.fov * 0.5);
                var far_w = far_h * asp;
                var farLT = helpv3_4;
                var farLD = helpv3_5;
                var farRT = helpv3_6;
                var farRD = helpv3_7;
                gd3d.math.vec3Set(farLT, -far_w, far_h, this.far);
                gd3d.math.vec3Set(farLD, -far_w, -far_h, this.far);
                gd3d.math.vec3Set(farRT, far_w, far_h, this.far);
                gd3d.math.vec3Set(farRD, far_w, -far_h, this.far);
                gd3d.math.matrixTransformVector3(farLD, matrix, farLD);
                gd3d.math.matrixTransformVector3(nearLD, matrix, nearLD);
                gd3d.math.matrixTransformVector3(farRD, matrix, farRD);
                gd3d.math.matrixTransformVector3(nearRD, matrix, nearRD);
                gd3d.math.matrixTransformVector3(farLT, matrix, farLT);
                gd3d.math.matrixTransformVector3(nearLT, matrix, nearLT);
                gd3d.math.matrixTransformVector3(farRT, matrix, farRT);
                gd3d.math.matrixTransformVector3(nearRT, matrix, nearRT);
                gd3d.math.vec3Clone(farLD, this.frameVecs[0]);
                gd3d.math.vec3Clone(nearLD, this.frameVecs[1]);
                gd3d.math.vec3Clone(farRD, this.frameVecs[2]);
                gd3d.math.vec3Clone(nearRD, this.frameVecs[3]);
                gd3d.math.vec3Clone(farLT, this.frameVecs[4]);
                gd3d.math.vec3Clone(nearLT, this.frameVecs[5]);
                gd3d.math.vec3Clone(farRT, this.frameVecs[6]);
                gd3d.math.vec3Clone(nearRT, this.frameVecs[7]);
                gd3d.math.matrixClone(matrix, this.lastCamMtx);
                gd3d.math.rectClone(_vpp, this.lastCamRect);
                this.paraArr[0] = this.fov;
                this.paraArr[1] = this.near;
                this.paraArr[2] = this.far;
            };
            Object.defineProperty(camera.prototype, "opvalue", {
                get: function () {
                    return this._opvalue;
                },
                set: function (val) {
                    if (val > 0 && this._near < 0.01) {
                        this._near = 0.01;
                        if (this._far <= this._near)
                            this._far = this._near + 0.01;
                    }
                    this._opvalue = val;
                },
                enumerable: true,
                configurable: true
            });
            camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, app, z, out) {
                var vpp = helprect;
                this.calcViewPortPixel(app, vpp);
                var nearpos = helpv3;
                nearpos.z = -this.near;
                nearpos.x = screenPos.x - vpp.w * 0.5;
                nearpos.y = vpp.h * 0.5 - screenPos.y;
                var farpos = helpv3_1;
                farpos.z = -this.far;
                farpos.x = this.far * nearpos.x / this.near;
                farpos.y = this.far * nearpos.y / this.near;
                ;
                var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
                out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
                out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
            };
            camera.prototype.fillRenderer = function (scene) {
                scene.renderList.clear();
                if (scene.app.isFrustumCulling)
                    this.calcCameraFrame(scene.app);
                this._fillRenderer(scene, scene.getRoot());
            };
            camera.prototype._fillRenderer = function (scene, node) {
                if (!node.gameObject.visible || (node.hasRendererComp == false && node.hasRendererCompChild == false))
                    return;
                if (scene.app.isFrustumCulling && !this.testFrustumCulling(scene, node))
                    return;
                if (node.gameObject != null && node.gameObject.renderer != null) {
                    scene.renderList.addRenderer(node.gameObject.renderer);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this._fillRenderer(scene, node.children[i]);
                    }
                }
            };
            camera.prototype.testFrustumCulling = function (scene, node) {
                if (!node.gameObject.getComponent("frustumculling"))
                    return true;
                var spherecol = node.gameObject.getComponent("spherecollider");
                var worldPos = node.getWorldTranslate();
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[1], this.frameVecs[5]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[1], this.frameVecs[3], this.frameVecs[7]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[3], this.frameVecs[2], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[2], this.frameVecs[0], this.frameVecs[4]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[5], this.frameVecs[7], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[2], this.frameVecs[3]))
                    return false;
                return true;
            };
            camera.prototype._targetAndViewport = function (target, scene, context, withoutClear) {
                {
                    var w = void 0;
                    var h = void 0;
                    if (target == null) {
                        w = scene.app.width;
                        h = scene.app.height;
                    }
                    else {
                        w = target.width;
                        h = target.height;
                        target.use(context.webgl);
                    }
                    context.webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
                    context.webgl.depthRange(0, 1);
                    if (withoutClear == false) {
                        if (this.clearOption_Color && this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            gd3d.render.glDrawPass.lastZWrite = true;
                            if (scene.fog) {
                                context.webgl.clearColor(scene.fog._Color.x, scene.fog._Color.y, scene.fog._Color.z, scene.fog._Color.w);
                            }
                            else {
                                context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            }
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            gd3d.render.glDrawPass.lastZWrite = true;
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Color) {
                            if (scene.fog) {
                                context.webgl.clearColor(scene.fog._Color.x, scene.fog._Color.y, scene.fog._Color.z, scene.fog._Color.w);
                            }
                            else {
                                context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            }
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT);
                        }
                        else {
                        }
                    }
                }
            };
            camera.prototype._renderOnce = function (scene, context, drawtype) {
                context.drawtype = drawtype;
                var assetmgr = scene.app.getAssetMgr();
                for (var _i = 0, _a = scene.renderList.renderLayers; _i < _a.length; _i++) {
                    var layer = _a[_i];
                    for (var _b = 0, _c = layer.list; _b < _c.length; _b++) {
                        var item = _c[_b];
                        if (item.gameObject.visible == true && this.CullingMask & (1 << item.renderLayer)) {
                            if (item.gameObject && item.gameObject.visible == true)
                                item.render(context, assetmgr, this);
                        }
                    }
                }
            };
            camera.prototype.renderScene = function (scene, context) {
                this._contextIdx = scene.renderContext.indexOf(context);
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    if (layer.needSort) {
                        if (list.length > 1) {
                            list.sort(function (a, b) {
                                if (a.queue != b.queue) {
                                    return a.queue - b.queue;
                                }
                                else {
                                    var matrixView = context.matrixView;
                                    var az = helpv3;
                                    var bz = helpv3_1;
                                    gd3d.math.matrixTransformVector3(a.gameObject.transform.getWorldTranslate(), matrixView, az);
                                    gd3d.math.matrixTransformVector3(b.gameObject.transform.getWorldTranslate(), matrixView, bz);
                                    return bz.z - az.z;
                                }
                            });
                        }
                    }
                }
                if (this.postQueues.length == 0) {
                    this._targetAndViewport(this.renderTarget, scene, context, false);
                    this._renderOnce(scene, context, "");
                }
                else {
                    for (var _i = 0, _a = this.postQueues; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.render(scene, context, this);
                    }
                    context.webgl.flush();
                }
            };
            camera.prototype.remove = function () {
            };
            camera.prototype.clone = function () {
            };
            var camera_1;
            camera.ClassName = "camera";
            __decorate([
                gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 2),
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "near", null);
            __decorate([
                gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 999),
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "far", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], camera.prototype, "CullingMask", void 0);
            __decorate([
                gd3d.reflect.compCall({ "use": "dirty", "display": "刷新camera" }),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", void 0)
            ], camera.prototype, "markDirty", null);
            __decorate([
                gd3d.reflect.Field("IOverLay[]"),
                __metadata("design:type", Array)
            ], camera.prototype, "overlays", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], camera.prototype, "fov", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], camera.prototype, "size", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "opvalue", null);
            camera = camera_1 = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeCamera,
                __metadata("design:paramtypes", [])
            ], camera);
            return camera;
        }());
        framework.camera = camera;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var canvascontainer = (function () {
            function canvascontainer() {
                this.isCanvasinit = false;
                this._lastMode = canvasRenderMode.ScreenSpaceOverlay;
                this._renderMode = canvasRenderMode.ScreenSpaceOverlay;
            }
            Object.defineProperty(canvascontainer.prototype, "canvas", {
                get: function () {
                    if (this._overlay2d && this._overlay2d.canvas)
                        return this._overlay2d.canvas;
                },
                enumerable: true,
                configurable: true
            });
            canvascontainer.prototype.setOverLay = function (lay) {
                this._overlay2d = lay;
                this.canvasInit();
            };
            canvascontainer.prototype.getOverLay = function () {
                return this._overlay2d;
            };
            Object.defineProperty(canvascontainer.prototype, "sortOrder", {
                get: function () {
                    return this._overlay2d ? this._overlay2d.sortOrder : 0;
                },
                set: function (order) {
                    if (this._overlay2d)
                        this._overlay2d.sortOrder = order;
                },
                enumerable: true,
                configurable: true
            });
            canvascontainer.prototype.canvasInit = function () {
                if (!this.gameObject || !this.gameObject.transform || !this.gameObject.transform.scene)
                    return;
                if (!this._overlay2d || !this._overlay2d.canvas)
                    return;
                this._overlay2d.canvas.scene = this.gameObject.transform.scene;
                this._overlay2d.canvas.assetmgr = this._overlay2d.canvas.scene.app.getAssetMgr();
                this.isCanvasinit = true;
            };
            Object.defineProperty(canvascontainer.prototype, "renderMode", {
                get: function () { return this._renderMode; },
                set: function (mode) {
                    if (this._renderMode == mode)
                        return;
                    this._lastMode = this._renderMode;
                    this._renderMode = mode;
                    this.styleToMode();
                },
                enumerable: true,
                configurable: true
            });
            canvascontainer.prototype.styleToMode = function () {
                switch (this._renderMode) {
                    case canvasRenderMode.ScreenSpaceOverlay:
                        if (!this._overlay2d)
                            return;
                        var scene_2 = this.gameObject.getScene();
                        scene_2.addScreenSpaceOverlay(this._overlay2d);
                        break;
                }
            };
            canvascontainer.prototype.start = function () {
                this.styleToMode();
            };
            canvascontainer.prototype.onPlay = function () {
            };
            canvascontainer.prototype.update = function (delta) {
                if (!this.isCanvasinit)
                    this.canvasInit();
            };
            canvascontainer.prototype.remove = function () {
                if (this.gameObject.getScene())
                    this.gameObject.getScene().removeScreenSpaceOverlay(this._overlay2d);
            };
            canvascontainer.prototype.clone = function () {
            };
            canvascontainer.ClassName = "canvascontainer";
            __decorate([
                gd3d.reflect.Field("reference"),
                __metadata("design:type", framework.overlay2D)
            ], canvascontainer.prototype, "_overlay2d", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], canvascontainer.prototype, "renderMode", null);
            canvascontainer = __decorate([
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], canvascontainer);
            return canvascontainer;
        }());
        framework.canvascontainer = canvascontainer;
        var canvasRenderMode;
        (function (canvasRenderMode) {
            canvasRenderMode[canvasRenderMode["ScreenSpaceOverlay"] = 0] = "ScreenSpaceOverlay";
            canvasRenderMode[canvasRenderMode["ScreenSpaceCamera"] = 1] = "ScreenSpaceCamera";
            canvasRenderMode[canvasRenderMode["WorldSpace"] = 2] = "WorldSpace";
        })(canvasRenderMode = framework.canvasRenderMode || (framework.canvasRenderMode = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var effectSystem = (function () {
            function effectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new gd3d.framework.EffectParser();
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            effectSystem_1 = effectSystem;
            Object.defineProperty(effectSystem.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(effectSystem.prototype, "jsonData", {
                get: function () {
                    return this._textasset;
                },
                set: function (text) {
                    this._textasset = text;
                    this.setJsonDataStr(this.jsonData.content);
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.prototype.setJsonData = function (_jsonData) {
                this._textasset = _jsonData;
                this.setJsonDataStr(this.jsonData.content);
            };
            effectSystem.prototype.setJsonDataStr = function (_jsonStr) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.data = this.parser.Parse(_jsonStr, gd3d.framework.sceneMgr.app.getAssetMgr());
            };
            effectSystem.prototype.updateJsonData = function (_jsonData) {
                this.jsonData = _jsonData;
                this.updateJsonDataStr(this.jsonData.content);
            };
            effectSystem.prototype.updateJsonDataStr = function (_jsonStr) {
                this.remove();
                this.data = this.parser.Parse(_jsonStr, gd3d.framework.sceneMgr.app.getAssetMgr());
                console.warn("开始解析特效");
            };
            Object.defineProperty(effectSystem.prototype, "data", {
                get: function () {
                    return this._data;
                },
                set: function (value) {
                    this._data = value;
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.prototype.init = function () {
                if (this._data) {
                    this.addElements();
                }
            };
            Object.defineProperty(effectSystem.prototype, "totalFrameCount", {
                get: function () {
                    return this.data.life * effectSystem_1.fps;
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.prototype.start = function () {
                this.init();
            };
            effectSystem.prototype.onPlay = function () {
            };
            effectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            };
            effectSystem.prototype._update = function (delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (var i = this.delayElements.length - 1; i >= 0; i--) {
                        var data = this.delayElements[i];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i]);
                            this.delayElements.splice(i, 1);
                        }
                    }
                }
                if (this.particles != undefined) {
                    this.particles.updateForEmission(delta);
                }
                if (this.checkFrameId()) {
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        for (var key in subEffectBatcher.effectElements) {
                            var element = subEffectBatcher.effectElements[key];
                            if (element.delayTime == undefined || element.delayTime <= this.playTimer) {
                                subEffectBatcher.mesh.submesh[0].size = element.endEboIndex;
                            }
                            else {
                                if (subEffectBatcher.mesh.submesh[0].size > element.startEboIndex)
                                    subEffectBatcher.mesh.submesh[0].size = element.startEboIndex;
                            }
                            var frameId = (this.curFrameId - this.getDelayFrameCount(element.delayTime)) % element.loopFrame;
                            frameId = Math.floor(frameId);
                            if (element.active) {
                                element.actionActive = false;
                                this.mergeLerpAttribData(element.curAttrData, element.timelineFrame[frameId]);
                                if (element.actions != undefined) {
                                    element.actionActive = true;
                                    for (var j in element.actions) {
                                        element.actions[j].update(frameId);
                                    }
                                }
                            }
                            element.update();
                            if (element.isCurFrameNeedRefresh(frameId)) {
                                this.updateEffectBatcher(element.effectBatcher, element.curAttrData, element.data.initFrameData, element.startVboIndex);
                            }
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.update(1 / effectSystem_1.fps);
                    }
                }
            };
            effectSystem.prototype.mergeLerpAttribData = function (realUseCurFrameData, curFrameData) {
                if (curFrameData == undefined)
                    return;
                if (realUseCurFrameData == undefined)
                    return;
                for (var key in curFrameData.attrsData) {
                    if (curFrameData.attrsData[key] != undefined && realUseCurFrameData[key] != undefined) {
                        var val = curFrameData.attrsData.getAttribute(key);
                        if (val == null)
                            continue;
                        if (val instanceof gd3d.math.vector3 || val instanceof gd3d.math.vector2 || typeof (val) === 'number') {
                            if (key != "renderModel")
                                realUseCurFrameData[key] = val;
                        }
                    }
                }
            };
            effectSystem.prototype.updateEffectBatcher = function (effectBatcher, curAttrsData, initFrameData, vertexStartIndex) {
                var mesh = curAttrsData.mesh;
                if (mesh == undefined) {
                    mesh = initFrameData.attrsData.mesh;
                }
                if (mesh == undefined)
                    return;
                if (curAttrsData.meshdataVbo == undefined) {
                    curAttrsData.meshdataVbo = mesh.data.genVertexDataArray(this.vf);
                }
                var vertexCount = mesh.data.pos.length;
                var vertexArr = curAttrsData.meshdataVbo;
                var vertexSize = effectBatcher.vertexSize;
                for (var i = 0; i < vertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i * vertexSize + 0];
                        vertex.y = vertexArr[i * vertexSize + 1];
                        vertex.z = vertexArr[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, curAttrsData.matrix, vertex);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = vertexArr[i * vertexSize + 9];
                        var g = vertexArr[i * vertexSize + 10];
                        var b = vertexArr[i * vertexSize + 11];
                        var a = vertexArr[i * vertexSize + 12];
                        if (curAttrsData.color != undefined) {
                            r = curAttrsData.color.x;
                            g = curAttrsData.color.y;
                            b = curAttrsData.color.z;
                        }
                        if (curAttrsData.alpha != undefined)
                            a = a * curAttrsData.alpha;
                        if (curAttrsData.colorRate != undefined) {
                            r *= curAttrsData.colorRate;
                            g *= curAttrsData.colorRate;
                            b *= curAttrsData.colorRate;
                            a *= curAttrsData.colorRate;
                        }
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
                    }
                    {
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * curAttrsData.tilling.x + curAttrsData.uv.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * curAttrsData.tilling.y + curAttrsData.uv.y;
                    }
                }
            };
            effectSystem.prototype.render = function (context, assetmgr, camera) {
                if (!(camera.CullingMask & (1 << this.renderLayer)))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    context.updateModel(this.gameObject.transform);
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        var mesh_2 = subEffectBatcher.mesh;
                        if (subEffectBatcher.state === framework.EffectBatcherState.NotInitedStateType) {
                            mesh_2.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
                            if (mesh_2.glMesh.ebos.length == 0) {
                                mesh_2.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
                            }
                            else {
                                mesh_2.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            }
                            mesh_2.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        else if (subEffectBatcher.state === framework.EffectBatcherState.ResizeCapacityStateType) {
                            mesh_2.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            mesh_2.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            mesh_2.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.glMesh.resetVboSize(context.webgl, subEffectBatcher.curTotalVertexCount * subEffectBatcher.vertexSize);
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        mesh_2.glMesh.uploadVertexData(context.webgl, subEffectBatcher.dataForVbo);
                        if (this.gameObject.getScene().fog) {
                            context.fog = this.gameObject.getScene().fog;
                            subEffectBatcher.mat.draw(context, mesh_2, mesh_2.submesh[0], "base_fog");
                        }
                        else {
                            subEffectBatcher.mat.draw(context, mesh_2, mesh_2.submesh[0], "base");
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.render(context, assetmgr, camera);
                    }
                }
            };
            effectSystem.prototype.clone = function () {
                var effect = new effectSystem_1();
                if (this.jsonData)
                    effect.jsonData = this.jsonData;
                if (this.data)
                    effect.data = this.data.clone();
                effect.autoplay = this.autoplay;
                effect.beLoop = this.beLoop;
                return effect;
            };
            effectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                if (this.state != framework.EffectPlayStateEnum.Pause)
                    this.stop();
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            };
            effectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            effectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            effectSystem.prototype.reset = function (restSinglemesh, resetParticle) {
                if (restSinglemesh === void 0) { restSinglemesh = true; }
                if (resetParticle === void 0) { resetParticle = true; }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
                this.resetparticle();
            };
            effectSystem.prototype.resetSingleMesh = function () {
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined)
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            };
            effectSystem.prototype.resetparticle = function () {
                if (this.particles != undefined)
                    this.particles.dispose();
                for (var name_3 in this.particleElementDic) {
                    var data = this.data.elementDic[name_3];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    if (data.refFrom == undefined) {
                        if (this.particles == undefined) {
                            this.particles = new framework.Particles(this);
                        }
                        this.particles.addEmission(data);
                    }
                    else {
                        this.refElements.push(data);
                    }
                }
            };
            effectSystem.prototype.addElements = function () {
                for (var name_4 in this.data.elementDic) {
                    var data = this.data.elementDic[name_4];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            };
            effectSystem.prototype.addElement = function (data) {
                if (data.type == framework.EffectElementTypeEnum.EmissionType) {
                    if (this.particles == undefined) {
                        this.particles = new framework.Particles(this);
                    }
                    this.particles.addEmission(data);
                    this.particleElementDic[data.name] = data;
                }
                else if (data.type == framework.EffectElementTypeEnum.SingleMeshType) {
                    this.addInitFrame(data);
                }
            };
            effectSystem.prototype.addInitFrame = function (elementData) {
                var element = new framework.EffectElement(elementData);
                element.transform = this.gameObject.transform;
                var _initFrameData = element.data.initFrameData;
                if (_initFrameData == undefined || _initFrameData.attrsData == undefined || _initFrameData.attrsData.mesh == undefined)
                    return;
                var index = -1;
                if (_initFrameData.attrsData.mat != null) {
                    for (var i_2 = 0; i_2 < this.matDataGroups.length; i_2++) {
                        if (framework.EffectMatData.beEqual(this.matDataGroups[i_2], _initFrameData.attrsData.mat)) {
                            index = i_2;
                            break;
                        }
                    }
                }
                var vertexStartIndex = 0;
                var vertexCount = _initFrameData.attrsData.mesh.data.pos.length;
                var indexCount = _initFrameData.attrsData.mesh.data.genIndexDataArray;
                var subEffectBatcher = null;
                if (index >= 0) {
                    subEffectBatcher = this.effectBatchers[index];
                    vertexStartIndex = subEffectBatcher.curTotalVertexCount;
                    subEffectBatcher.curTotalVertexCount += vertexCount;
                    if (subEffectBatcher.state == framework.EffectBatcherState.InitedStateType)
                        subEffectBatcher.state = framework.EffectBatcherState.ResizeCapacityStateType;
                }
                else {
                    subEffectBatcher = new framework.EffectBatcher(this.vf);
                    subEffectBatcher.curTotalVertexCount = vertexCount;
                    subEffectBatcher.mesh = new framework.mesh();
                    subEffectBatcher.mesh.data = new gd3d.render.meshData();
                    subEffectBatcher.mesh.glMesh = new gd3d.render.glMesh();
                    subEffectBatcher.mat = new framework.material();
                    subEffectBatcher.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.useVertexIndex = 0;
                        sm.start = 0;
                        sm.size = 0;
                        sm.line = false;
                        subEffectBatcher.mesh.submesh.push(sm);
                    }
                    vertexStartIndex = 0;
                    index = 0;
                    if (_initFrameData.attrsData.mat.shader == null) {
                        subEffectBatcher.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                        console.error("特效{0}shader为空", elementData.name);
                    }
                    else {
                        subEffectBatcher.mat.setShader(_initFrameData.attrsData.mat.shader);
                    }
                    if (_initFrameData.attrsData.mat.alphaCut != undefined)
                        subEffectBatcher.mat.setFloat("_AlphaCut", _initFrameData.attrsData.mat.alphaCut);
                    if (_initFrameData.attrsData.mat.diffuseTexture != null)
                        subEffectBatcher.mat.setTexture("_MainTex", _initFrameData.attrsData.mat.diffuseTexture);
                    if (_initFrameData.attrsData.mat.alphaTexture != null)
                        subEffectBatcher.mat.setTexture("_AlphaTex", _initFrameData.attrsData.mat.alphaTexture);
                    this.effectBatchers.push(subEffectBatcher);
                    this.matDataGroups.push(_initFrameData.attrsData.mat);
                }
                element.effectBatcher = subEffectBatcher;
                element.startVboIndex = vertexStartIndex;
                element.curAttrData = elementData.initFrameData.attrsData.copyandinit();
                var vertexSize = subEffectBatcher.vertexSize;
                var vertexArr = _initFrameData.attrsData.mesh.data.genVertexDataArray(this.vf);
                element.update();
                subEffectBatcher.effectElements.push(element);
                for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i_3 * vertexSize + 0];
                        vertex.y = vertexArr[i_3 * vertexSize + 1];
                        vertex.z = vertexArr[i_3 * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, element.curAttrData.matrix, vertex);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 0] = vertex.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 1] = vertex.y;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 3] = vertexArr[i_3 * vertexSize + 3];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 4] = vertexArr[i_3 * vertexSize + 4];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 5] = vertexArr[i_3 * vertexSize + 5];
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 6] = vertexArr[i_3 * vertexSize + 6];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 7] = vertexArr[i_3 * vertexSize + 7];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 8] = vertexArr[i_3 * vertexSize + 8];
                    }
                    {
                        var r = gd3d.math.floatClamp(element.curAttrData.color.x, 0, 1);
                        var g = gd3d.math.floatClamp(element.curAttrData.color.y, 0, 1);
                        var b = gd3d.math.floatClamp(element.curAttrData.color.z, 0, 1);
                        var a = gd3d.math.floatClamp(vertexArr[i_3 * vertexSize + 12] * element.curAttrData.alpha, 0, 1);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 9] = r;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 10] = g;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 11] = b;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 12] = a;
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 13] = vertexArr[i_3 * vertexSize + 13] * element.curAttrData.tilling.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 14] = vertexArr[i_3 * vertexSize + 14] * element.curAttrData.tilling.y;
                    }
                }
                var indexArray = _initFrameData.attrsData.mesh.data.genIndexDataArray();
                var _startIndex = subEffectBatcher.indexStartIndex;
                element.startEboIndex = _startIndex;
                subEffectBatcher.indexStartIndex += indexArray.length;
                element.endEboIndex = subEffectBatcher.indexStartIndex;
                for (var i = 0; i < indexArray.length; i++) {
                    subEffectBatcher.dataForEbo[_startIndex + i] = indexArray[i] + vertexStartIndex;
                }
            };
            effectSystem.prototype.setFrameId = function (id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            };
            effectSystem.prototype.getDelayFrameCount = function (delayTime) {
                return delayTime * effectSystem_1.fps;
            };
            effectSystem.prototype.checkFrameId = function () {
                var curid = (effectSystem_1.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            };
            effectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                while (this.effectBatchers.length > 0) {
                    this.effectBatchers[0].dispose();
                    this.effectBatchers.splice(0, 1);
                }
                while (this.matDataGroups.length > 0) {
                    this.matDataGroups.splice(0, 1);
                }
                if (this.particles)
                    this.particles.dispose();
                this.curFrameId = -1;
                this.playTimer = 0;
            };
            Object.defineProperty(effectSystem.prototype, "leftLifeTime", {
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else
                        return 9999999999;
                },
                enumerable: true,
                configurable: true
            });
            var effectSystem_1;
            effectSystem.ClassName = "effectSystem";
            effectSystem.fps = 30;
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], effectSystem.prototype, "autoplay", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], effectSystem.prototype, "beLoop", void 0);
            __decorate([
                gd3d.reflect.Field("textasset"),
                __metadata("design:type", framework.textasset),
                __metadata("design:paramtypes", [framework.textasset])
            ], effectSystem.prototype, "jsonData", null);
            effectSystem = effectSystem_1 = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], effectSystem);
            return effectSystem;
        }());
        framework.effectSystem = effectSystem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var TestEffectSystem = (function () {
            function TestEffectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new gd3d.framework.EffectParser();
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            Object.defineProperty(TestEffectSystem.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            TestEffectSystem.prototype.setJsonData = function (_jsonData) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.jsonData = _jsonData;
                this.data = this.parser.Parse(this.jsonData.content, gd3d.framework.sceneMgr.app.getAssetMgr());
            };
            Object.defineProperty(TestEffectSystem.prototype, "data", {
                get: function () {
                    return this._data;
                },
                set: function (value) {
                    this._data = value;
                },
                enumerable: true,
                configurable: true
            });
            TestEffectSystem.prototype.init = function () {
                if (this._data) {
                    this.addElements();
                }
            };
            Object.defineProperty(TestEffectSystem.prototype, "totalFrameCount", {
                get: function () {
                    return this.data.life * framework.effectSystem.fps;
                },
                enumerable: true,
                configurable: true
            });
            TestEffectSystem.prototype.start = function () {
                this.init();
            };
            TestEffectSystem.prototype.onPlay = function () {
            };
            TestEffectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            };
            TestEffectSystem.prototype._update = function (delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (var i_4 = this.delayElements.length - 1; i_4 >= 0; i_4--) {
                        var data = this.delayElements[i_4];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i_4]);
                            this.delayElements.splice(i_4, 1);
                        }
                    }
                }
                if (this.checkFrameId()) {
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].update(1 / framework.effectSystem.fps);
                        }
                    }
                }
            };
            TestEffectSystem.prototype.render = function (context, assetmgr, camera) {
                if (!(camera.CullingMask & (1 << this.renderLayer)))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play) {
                    context.updateModel(this.gameObject.transform);
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].render(context, assetmgr, camera);
                        }
                    }
                }
            };
            TestEffectSystem.prototype.clone = function () {
                var effect = new framework.effectSystem();
                effect.data = this.data.clone();
                return effect;
            };
            TestEffectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            };
            TestEffectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            TestEffectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            TestEffectSystem.prototype.reset = function (restSinglemesh, resetParticle) {
                if (restSinglemesh === void 0) { restSinglemesh = true; }
                if (resetParticle === void 0) { resetParticle = true; }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
            };
            TestEffectSystem.prototype.resetSingleMesh = function () {
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined)
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            };
            TestEffectSystem.prototype.addElements = function () {
                for (var name_5 in this.data.elementDic) {
                    var data = this.data.elementDic[name_5];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            };
            TestEffectSystem.prototype.addElement = function (data) {
            };
            TestEffectSystem.prototype.addEmissionElement = function (data) {
                if (data === void 0) { data = null; }
                if (this.emissionElement == null) {
                    this.emissionElement = [];
                }
                var emission = new framework.EffectElementEmission(this, data);
                this.emissionElement.push(emission);
            };
            TestEffectSystem.prototype.setFrameId = function (id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            };
            TestEffectSystem.prototype.getDelayFrameCount = function (delayTime) {
                return delayTime * framework.effectSystem.fps;
            };
            TestEffectSystem.prototype.checkFrameId = function () {
                var curid = (framework.effectSystem.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            };
            TestEffectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                for (var key in this.effectBatchers) {
                    this.effectBatchers[key].dispose();
                }
                if (this.particles)
                    this.particles.dispose();
            };
            Object.defineProperty(TestEffectSystem.prototype, "leftLifeTime", {
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else
                        return 9999999999;
                },
                enumerable: true,
                configurable: true
            });
            TestEffectSystem.ClassName = "TestEffectSystem";
            TestEffectSystem.fps = 30;
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], TestEffectSystem.prototype, "autoplay", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], TestEffectSystem.prototype, "beLoop", void 0);
            __decorate([
                gd3d.reflect.Field("textasset"),
                __metadata("design:type", framework.textasset)
            ], TestEffectSystem.prototype, "jsonData", void 0);
            TestEffectSystem = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                gd3d.reflect.selfClone
            ], TestEffectSystem);
            return TestEffectSystem;
        }());
        framework.TestEffectSystem = TestEffectSystem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var frustumculling = (function () {
            function frustumculling() {
            }
            frustumculling.prototype.start = function () {
            };
            frustumculling.prototype.onPlay = function () {
            };
            frustumculling.prototype.update = function (delta) {
            };
            frustumculling.prototype.remove = function () {
            };
            frustumculling.prototype.clone = function () {
            };
            frustumculling.ClassName = "frustumculling";
            frustumculling = __decorate([
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], frustumculling);
            return frustumculling;
        }());
        framework.frustumculling = frustumculling;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var guidpath = (function () {
            function guidpath() {
                this.speed = 1;
                this.isactived = false;
                this.datasafe = false;
                this.folowindex = 0;
                this.isloop = false;
                this.lookforward = false;
                this.loopCount = 1;
                this.adjustDir = false;
            }
            Object.defineProperty(guidpath.prototype, "pathasset", {
                get: function () {
                    return this._pathasset;
                },
                set: function (pathasset) {
                    if (this._pathasset) {
                        this._pathasset.unuse();
                    }
                    this._pathasset = pathasset;
                    if (this._pathasset) {
                        this._pathasset.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            guidpath.prototype.play = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.loopCount = loopCount;
            };
            guidpath.prototype.pause = function () {
                this.isactived = false;
            };
            guidpath.prototype.stop = function () {
                this.isactived = false;
                this.folowindex = 0;
            };
            guidpath.prototype.replay = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.folowindex = 0;
                this.loopCount = loopCount;
            };
            guidpath.prototype.setpathasset = function (pathasset, speed, oncomplete) {
                if (speed === void 0) { speed = 1; }
                if (oncomplete === void 0) { oncomplete = null; }
                this.pathasset = pathasset;
                if (pathasset == null) {
                    console.log(this.gameObject.getName().toString + ":are you sure set the right pathasset（error：null）");
                    return;
                }
                this.paths = pathasset.paths;
                if (this.paths[0] != null) {
                    gd3d.math.vec3Clone(this.paths[0], this.gameObject.transform.localTranslate);
                    this.datasafe = true;
                }
                this.mystrans = this.gameObject.transform;
                this.speed = speed;
                this.oncomplete = oncomplete;
            };
            guidpath.prototype.start = function () {
            };
            guidpath.prototype.onPlay = function () {
            };
            guidpath.prototype.update = function (delta) {
                if (!this.isactived || !this.datasafe)
                    return;
                this.followmove(delta);
            };
            guidpath.prototype.followmove = function (delta) {
                var dist = gd3d.math.vec3Distance(this.mystrans.localTranslate, this.paths[this.folowindex]);
                if (dist < 0.01) {
                    if (this.folowindex < this.paths.length - 1) {
                        var dir = new gd3d.math.vector3();
                        gd3d.math.vec3Clone(this.paths[this.folowindex], this.mystrans.localTranslate);
                        this.folowindex++;
                        this.adjustDir = true;
                    }
                    else {
                        this.folowindex = 0;
                        if (!this.isloop) {
                            this.loopCount--;
                            if (this.loopCount == 0) {
                                this.isactived = false;
                                this.loopCount = 1;
                                if (this.oncomplete) {
                                    this.oncomplete();
                                }
                            }
                        }
                    }
                }
                else {
                    var dir = new gd3d.math.vector3();
                    gd3d.math.vec3Subtract(this.paths[this.folowindex], this.mystrans.localTranslate, dir);
                    if (this.adjustDir) {
                        var targetpos = this.paths[this.folowindex];
                        var localppos = this.mystrans.localTranslate;
                        var quat = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatLookat(localppos, targetpos, quat);
                        gd3d.math.quatClone(quat, this.mystrans.localRotate);
                        gd3d.math.pool.delete_quaternion(quat);
                        this.adjustDir = false;
                    }
                    var distadd = this.speed * delta;
                    if (distadd > dist)
                        distadd = dist;
                    var lerp = distadd / dist;
                    gd3d.math.vec3SLerp(this.mystrans.localTranslate, this.paths[this.folowindex], lerp, this.mystrans.localTranslate);
                    this.mystrans.markDirty();
                }
            };
            guidpath.prototype.remove = function () {
                if (this._pathasset) {
                    this._pathasset.unuse();
                }
            };
            guidpath.prototype.clone = function () {
            };
            guidpath.ClassName = "guidpath";
            guidpath = __decorate([
                gd3d.reflect.nodeComponent
            ], guidpath);
            return guidpath;
        }());
        framework.guidpath = guidpath;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var keyFrameAniPlayer = (function () {
            function keyFrameAniPlayer() {
                this.nowTime = 0;
                this.pathPropertyMap = {};
            }
            Object.defineProperty(keyFrameAniPlayer.prototype, "nowFrame", {
                get: function () {
                    if (!this.nowClip)
                        return 0;
                    return Math.floor(this.nowClip.fps * this.nowTime);
                },
                enumerable: true,
                configurable: true
            });
            ;
            keyFrameAniPlayer.prototype.start = function () {
                this.init();
            };
            keyFrameAniPlayer.prototype.onPlay = function () {
            };
            keyFrameAniPlayer.prototype.update = function (delta) {
                var clip = this.nowClip;
                if (!clip)
                    return;
                if (this.checkPlayEnd(clip)) {
                    this.nowClip = null;
                    this.nowTime = 0;
                    return;
                }
                this.nowTime += delta;
                var playTime = this.nowTime % this.nowClip.time;
                this.displayByTime(clip, playTime);
            };
            keyFrameAniPlayer.prototype.displayByTime = function (clip, playTime) {
                var curves = this.timeFilterCurves(clip, playTime);
                if (!curves || curves.length < 1)
                    return;
                for (var i = 0; i < curves.length; i++) {
                    var tempc = curves[i];
                    this.refrasCurveProperty(tempc, playTime);
                }
            };
            keyFrameAniPlayer.prototype.calcValueByTime = function (curve, playTime) {
                var kfs = curve.keyFrames;
                if (!kfs || kfs.length < 1)
                    return 0;
                if (kfs.length == 1 && kfs[0])
                    return kfs[0].value;
                var leftKf;
                var rightKf;
                for (var i = 0; i < kfs.length; i++) {
                    rightKf = kfs[i];
                    if (kfs[i].time > playTime) {
                        if (i > 0)
                            leftKf = kfs[i - 1];
                        break;
                    }
                }
                return bezierCurveTool.calcValue(leftKf, rightKf, playTime);
            };
            keyFrameAniPlayer.prototype.refrasCurveProperty = function (curve, playTime) {
                if (playTime < 0 || !curve || curve.keyFrames.length < 2 || framework.StringUtil.isNullOrEmptyObject(curve.propertyName))
                    return;
                var key = curve.path + "_" + curve.type;
                var obj = this.pathPropertyMap[key];
                if (!obj)
                    return;
                var sub = obj;
                var strs = curve.propertyName.split(".");
                while (strs.length > 0) {
                    if (strs.length == 1) {
                        sub[strs[0]] = this.calcValueByTime(curve, playTime);
                        if (curve.type == framework.transform["name"]) {
                            if (obj instanceof framework.transform) {
                                obj.markDirty();
                            }
                        }
                        return;
                    }
                    var str = strs.shift();
                    sub = sub[str];
                    if (!sub)
                        return;
                }
            };
            keyFrameAniPlayer.prototype.timeFilterCurves = function (clip, nowTime) {
                if (!clip || clip.curves.length < 1)
                    return;
                var result = [];
                for (var i = 0; i < clip.curves.length; i++) {
                    var curve = clip.curves[i];
                    var kfs = curve.keyFrames;
                    if (kfs.length < 1 || !kfs[kfs.length - 1] || kfs[kfs.length - 1].time < nowTime)
                        continue;
                    result.push(curve);
                }
                return result;
            };
            keyFrameAniPlayer.prototype.checkPlayEnd = function (clip) {
                if (!clip)
                    return true;
                if (clip._wrapMode == framework.WrapMode.Loop || clip._wrapMode == framework.WrapMode.PingPong)
                    return false;
                if (this.nowTime >= clip.time)
                    return true;
            };
            keyFrameAniPlayer.prototype.init = function () {
            };
            keyFrameAniPlayer.prototype.isPlaying = function (ClipName) {
                return (this.nowClip && this.nowClip.getName() == ClipName);
            };
            keyFrameAniPlayer.prototype.playByName = function (ClipName) {
                if (!this.clips || this.clips.length < 1)
                    return;
                for (var i = 0; i < this.clips.length; i++) {
                    var clip = this.clips[i];
                    if (!clip)
                        continue;
                    if (clip.getName() == ClipName) {
                        this.nowClip = clip;
                        this.collectPathPropertyObj(this.nowClip, this.pathPropertyMap);
                    }
                }
            };
            keyFrameAniPlayer.prototype.play = function () {
                if (!this.clips || this.clips.length < 1)
                    return;
                this.nowClip = this.clips[0];
                if (!this.nowClip)
                    return;
                this.collectPathPropertyObj(this.nowClip, this.pathPropertyMap);
            };
            keyFrameAniPlayer.prototype.stop = function () {
                this.nowClip = null;
            };
            keyFrameAniPlayer.prototype.rewind = function () {
                if (!this.nowClip)
                    return;
                this.displayByTime(this.nowClip, 0);
                this.nowTime = 0;
            };
            keyFrameAniPlayer.prototype.collectPropertyObj = function (clip) {
                if (!clip)
                    return;
                for (var i = 0; i < clip.curves.length; i++) {
                    var curve = clip.curves[i];
                    var tran = this.gameObject.transform;
                    if (!framework.StringUtil.isNullOrEmptyObject(curve.path)) {
                        tran = this.pathPropertyMap[curve.path];
                    }
                    var comp = tran;
                    if (curve.type != framework.transform.prototype.name) {
                        comp = tran.gameObject.getComponent(curve.type);
                    }
                    if (!comp)
                        continue;
                }
            };
            keyFrameAniPlayer.prototype.collectPathPropertyObj = function (clip, pathMap) {
                if (!clip || !pathMap)
                    return;
                for (var i = 0; i < clip.curves.length; i++) {
                    var curve = clip.curves[i];
                    var key = "";
                    var tran = this.gameObject.transform;
                    if (!framework.StringUtil.isNullOrEmptyObject(curve.path)) {
                        var strs = curve.path.split("/");
                        for (var j = 0; j < strs.length; j++) {
                            tran = this.serchChild(strs[i], tran);
                            if (!tran)
                                break;
                        }
                        if (!tran)
                            continue;
                    }
                    key = curve.path + "_" + curve.type;
                    var comp = tran;
                    if (curve.type != framework.transform["name"]) {
                        comp = tran.gameObject.getComponent(curve.type);
                    }
                    pathMap[key] = comp;
                }
            };
            keyFrameAniPlayer.prototype.serchChild = function (name, trans) {
                if (!trans || !trans.children || trans.children.length < 1)
                    return;
                for (var i = 0; i < trans.children.length; i++) {
                    var child = trans.children[i];
                    if (child && child.name == name)
                        return child;
                }
            };
            keyFrameAniPlayer.prototype.clone = function () {
            };
            keyFrameAniPlayer.prototype.remove = function () {
            };
            keyFrameAniPlayer.ClassName = "keyFrameAniPlayer";
            __decorate([
                gd3d.reflect.Field("keyFrameAniClip[]"),
                __metadata("design:type", Array)
            ], keyFrameAniPlayer.prototype, "clips", void 0);
            keyFrameAniPlayer = __decorate([
                gd3d.reflect.nodeComponent
            ], keyFrameAniPlayer);
            return keyFrameAniPlayer;
        }());
        framework.keyFrameAniPlayer = keyFrameAniPlayer;
        var bezierCurveTool = (function () {
            function bezierCurveTool() {
            }
            bezierCurveTool.calcValue = function (kf_l, kf_r, playTime) {
                if (kf_l.outTangent == Infinity || kf_r.inTangent == Infinity)
                    return kf_l.value;
                var rate = (playTime - kf_l.time) / (kf_r.time - kf_l.time);
                var v2 = bezierCurveTool.converCalc(kf_l.value, kf_r.value, kf_l.time, kf_r.time, kf_l.inTangent, kf_r.outTangent, rate);
                return v2.y;
            };
            bezierCurveTool.converCalc = function (inV, outV, inTime, outTime, inTangent, outTangent, t) {
                var p0 = gd3d.math.pool.new_vector2(inTime, inV);
                var p1 = gd3d.math.pool.new_vector2();
                var p2 = gd3d.math.pool.new_vector2();
                var p3 = gd3d.math.pool.new_vector2(outTime, outV);
                var dir1 = gd3d.math.pool.new_vector2(inTangent < 0 ? -1 : 1, Math.sqrt(1 + inTangent * inTangent));
                var dir2 = gd3d.math.pool.new_vector2(outTangent < 0 ? -1 : 1, Math.sqrt(1 + outTangent * outTangent));
                gd3d.math.vec2Add(p0, dir1, p1);
                gd3d.math.vec2Add(p3, dir2, p2);
                bezierCurveTool.calcCurve(t, p0, p1, p2, p3, bezierCurveTool.cupV2);
                gd3d.math.pool.delete_vector2Array([p0, p1, p2, p3, dir1, dir2]);
                return bezierCurveTool.cupV2;
            };
            bezierCurveTool.calcCurve = function (t, P0, P1, P2, P3, out) {
                var equation = function (t, val0, val1, val2, val3) {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                out.x = equation(t, P0.x, P1.x, P2.x, P3.x);
                out.y = equation(t, P0.y, P1.y, P2.y, P3.y);
                return out;
            };
            bezierCurveTool.cupV2 = new gd3d.math.vector2();
            return bezierCurveTool;
        }());
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LightTypeEnum;
        (function (LightTypeEnum) {
            LightTypeEnum[LightTypeEnum["Direction"] = 0] = "Direction";
            LightTypeEnum[LightTypeEnum["Point"] = 1] = "Point";
            LightTypeEnum[LightTypeEnum["Spot"] = 2] = "Spot";
        })(LightTypeEnum = framework.LightTypeEnum || (framework.LightTypeEnum = {}));
        var light = (function () {
            function light() {
                this.spotAngelCos = 0.9;
                this.range = 10;
                this.intensity = 1;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
                this.cullingMask = framework.CullingMask.everything;
            }
            light.prototype.start = function () {
            };
            light.prototype.onPlay = function () {
            };
            light.prototype.update = function (delta) {
            };
            light.prototype.remove = function () {
            };
            light.prototype.clone = function () {
            };
            light.ClassName = "light";
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "type", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "range", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "intensity", void 0);
            __decorate([
                gd3d.reflect.Field("color"),
                __metadata("design:type", gd3d.math.color)
            ], light.prototype, "color", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "cullingMask", void 0);
            light = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeLight
            ], light);
            return light;
        }());
        framework.light = light;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var helpMat = null;
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var spherestruct = (function () {
            function spherestruct(_center, _r) {
                this.center = new gd3d.math.vector3();
                this.tempScale = new gd3d.math.vector3();
                this.srcCenter = new gd3d.math.vector3();
                gd3d.math.vec3Clone(_center, this.srcCenter);
                gd3d.math.vec3Clone(_center, this.center);
                this.srcradius = _r;
            }
            spherestruct.prototype.update = function (worldmatrix) {
                gd3d.math.matrixTransformVector3(this.srcCenter, worldmatrix, this.center);
                gd3d.math.matrixGetScale(worldmatrix, this.tempScale);
                if (this.tempScale.x < this.tempScale.y)
                    this.tempScale.x = this.tempScale.y;
                if (this.tempScale.x < this.tempScale.z)
                    this.tempScale.x = this.tempScale.z;
                this.radius = this.srcradius * this.tempScale.x;
            };
            spherestruct.prototype.intersects = function (bound) {
                if (!bound)
                    return false;
                if (bound instanceof spherestruct) {
                    return framework.collision.sphereVsSphere(this, bound);
                }
                else if (bound instanceof framework.obb) {
                    return framework.collision.obbVsSphere(bound, this);
                }
            };
            spherestruct.prototype.computeExtentsByAxis = function (axis, out) {
                var p = gd3d.math.vec3Dot(this.center, axis);
                out.x = p - this.radius;
                out.y = p + this.radius;
            };
            return spherestruct;
        }());
        framework.spherestruct = spherestruct;
        var spherecollider = (function () {
            function spherecollider() {
                this.center = new gd3d.math.vector3();
                this.radius = 0.5;
                this._worldCenter = new gd3d.math.vector3();
                this._colliderVisible = false;
            }
            Object.defineProperty(spherecollider.prototype, "worldCenter", {
                get: function () {
                    gd3d.math.vec3Clone(this.center, this._worldCenter);
                    gd3d.math.matrixTransformVector3(this._worldCenter, this.gameObject.transform.getWorldMatrix(), this._worldCenter);
                    return this._worldCenter;
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.getBound = function () {
                return this.spherestruct;
            };
            Object.defineProperty(spherecollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    return new gd3d.math.matrix();
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            };
            spherecollider.prototype.onPlay = function () {
            };
            spherecollider.prototype.update = function (delta) {
                if (this.spherestruct) {
                    this.spherestruct.update(this.matrix);
                    if (this.subTran && this.subTran.gameObject.components.length > 0) {
                        var r = this.spherestruct.radius;
                        var sc = gd3d.math.pool.new_vector3(r, r, r);
                        this.subTran.setWorldScale(sc);
                        gd3d.math.pool.delete_vector3(sc);
                        this.subTran.setWorldPosition(this.spherestruct.center);
                    }
                }
            };
            Object.defineProperty(spherecollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this._colliderVisible) {
                        if (this.subTran && this.subTran.gameObject.components.length < 1) {
                            this.setMeshRenderer();
                        }
                    }
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.caclPlaneInDir = function (v0, v1, v2) {
                var subv0 = gd3d.math.pool.new_vector3();
                var subv1 = gd3d.math.pool.new_vector3();
                var cro0 = gd3d.math.pool.new_vector3();
                var point = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(v1, v0, subv0);
                gd3d.math.vec3Subtract(v2, v1, subv1);
                gd3d.math.vec3Cross(subv0, subv1, cro0);
                gd3d.math.calPlaneLineIntersectPoint(cro0, v0, cro0, this.worldCenter, point);
                var sublp = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(point, this.worldCenter, sublp);
                var val = gd3d.math.vec3Dot(cro0, sublp);
                gd3d.math.pool.delete_vector3(subv0);
                gd3d.math.pool.delete_vector3(subv1);
                gd3d.math.pool.delete_vector3(cro0);
                if (val <= 0)
                    return true;
                var dis = gd3d.math.vec3Distance(this.worldCenter, point);
                gd3d.math.pool.delete_vector3(point);
                if (dis < this.radius)
                    return true;
                return false;
            };
            spherecollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.spherestruct == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.spherestruct.intersects(_obb);
            };
            spherecollider.prototype.build = function () {
                if (this.center && this.radius) {
                    this.spherestruct = new spherestruct(this.center, this.radius);
                }
                this.buildMesh();
            };
            spherecollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy | framework.HideFlags.NotEditable;
                this.subTran.name = "sphereCollider";
                if (this._colliderVisible) {
                    this.setMeshRenderer();
                }
            };
            spherecollider.prototype.setMeshRenderer = function () {
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.gameObject.getScene().app.getAssetMgr().getDefaultMesh("sphere");
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                renderer.materials = [];
                if (!helpMat) {
                    var ass = this.gameObject.getScene().app.getAssetMgr();
                    helpMat = new framework.material("sphereCMat");
                    helpMat.defaultAsset = true;
                    helpMat.setShader(ass.getShader("shader/materialcolor"));
                    var color = new gd3d.math.vector4(0, 1, 0, 1);
                    helpMat.setVector4("_Color", color);
                    helpMat.setFloat("_Alpha", 0.3);
                }
                renderer.materials[0] = helpMat;
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            };
            spherecollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                return _mesh;
            };
            spherecollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            spherecollider.prototype.clone = function () {
            };
            spherecollider.ClassName = "spherecollider";
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], spherecollider.prototype, "center", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], spherecollider.prototype, "radius", void 0);
            spherecollider = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeSphereCollider
            ], spherecollider);
            return spherecollider;
        }());
        framework.spherecollider = spherecollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var trailRender = (function () {
            function trailRender() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this.width = 1.0;
                this.vertexcount = 24;
                this.active = false;
                this.reInit = false;
                this.extenedOneSide = true;
                this.lookAtCamera = false;
                this.isAlphaGradual = false;
                this.inited = false;
                this.speed = 0.5;
            }
            Object.defineProperty(trailRender.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            trailRender.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.initmesh();
            };
            trailRender.prototype.onPlay = function () {
            };
            trailRender.prototype.update = function (delta) {
                if (!this.active)
                    return;
                if (!this.inited) {
                    this.intidata();
                }
                if (this.reInit) {
                    this.reInitdata();
                    this.reInit = false;
                }
                var targetpos = this.gameObject.transform.getWorldTranslate();
                if (this.lookAtCamera) {
                    this.camerapositon = framework.sceneMgr.app.getScene().mainCamera.gameObject.transform.getWorldTranslate();
                    var camdir = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(this.camerapositon, this.sticks[0].location, camdir);
                    gd3d.math.vec3Normalize(camdir, camdir);
                    var direction = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(targetpos, this.sticks[0].location, direction);
                    gd3d.math.vec3Normalize(direction, direction);
                    gd3d.math.vec3Cross(camdir, direction, this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    gd3d.math.pool.delete_vector3(direction);
                }
                gd3d.math.vec3Clone(targetpos, this.sticks[0].location);
                var length = this.sticks.length;
                for (var i = 1; i < length; i++) {
                    gd3d.math.vec3SLerp(this.sticks[i].location, this.sticks[i - 1].location, this.speed, this.sticks[i].location);
                }
                if (this.lookAtCamera) {
                    for (var i = 1; i < length; i++) {
                        var tocamdir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.camerapositon, this.sticks[i].location, tocamdir);
                        gd3d.math.vec3Normalize(tocamdir, tocamdir);
                        var movedir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.sticks[i - 1].location, this.sticks[i].location, movedir);
                        gd3d.math.vec3Normalize(movedir, movedir);
                        gd3d.math.vec3Cross(tocamdir, movedir, this.sticks[i].updir);
                        gd3d.math.vec3ScaleByNum(this.sticks[i].updir, this.width, this.sticks[i].updir);
                        gd3d.math.pool.delete_vector3(tocamdir);
                    }
                }
                else {
                    this.gameObject.transform.getUpInWorld(this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    for (var i = 1; i < length; i++) {
                        gd3d.math.vec3SLerp(this.sticks[i].updir, this.sticks[i - 1].updir, this.speed, this.sticks[i].updir);
                    }
                }
                this.updateTrailData();
            };
            Object.defineProperty(trailRender.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new gd3d.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this.material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this.material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender.prototype, "color", {
                get: function () {
                    if (this._color == undefined) {
                        this._color = new gd3d.math.color(1, 1, 1, 1);
                    }
                    return this._color;
                },
                set: function (color) {
                    this._color = color;
                },
                enumerable: true,
                configurable: true
            });
            trailRender.prototype.setspeed = function (upspeed) {
                this.speed = upspeed;
            };
            trailRender.prototype.setWidth = function (Width) {
                this.width = Width;
            };
            trailRender.prototype.play = function () {
                this.reInit = true;
                this.active = true;
            };
            trailRender.prototype.stop = function () {
                this.active = false;
            };
            trailRender.prototype.initmesh = function () {
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(this.vertexcount * 9);
                this.dataForEbo = new Uint16Array((this.vertexcount / 2 - 1) * 6);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, this.vertexcount, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            };
            trailRender.prototype.reInitdata = function () {
                if (!this.inited)
                    return;
                length = this.vertexcount / 2;
                for (var i = 0; i < length; i++) {
                    var sti = this.sticks[i];
                    gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), sti.location);
                    this.gameObject.transform.getUpInWorld(sti.updir);
                    gd3d.math.vec3ScaleByNum(sti.updir, this.width, sti.updir);
                }
            };
            trailRender.prototype.intidata = function () {
                this.sticks = [];
                for (var i = 0; i < this.vertexcount / 2; i++) {
                    var ts = new trailStick();
                    this.sticks.push(ts);
                    ts.location = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), ts.location);
                    ts.updir = new gd3d.math.vector3();
                    this.gameObject.transform.getUpInWorld(ts.updir);
                    gd3d.math.vec3ScaleByNum(ts.updir, this.width, ts.updir);
                }
                var length = this.vertexcount / 2;
                var updir = gd3d.math.pool.new_vector3();
                this.gameObject.transform.getUpInWorld(updir);
                gd3d.math.vec3ScaleByNum(updir, this.width, updir);
                var pos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var uppos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Add(pos, updir, uppos);
                var downpos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(pos, updir, downpos);
                for (var i = 0; i < length; i++) {
                    var tempA = this.isAlphaGradual ? (length - i - 1) / length : 1;
                    this.dataForVbo[i * 2 * 9] = uppos.x;
                    this.dataForVbo[i * 2 * 9 + 1] = uppos.y;
                    this.dataForVbo[i * 2 * 9 + 2] = uppos.z;
                    this.dataForVbo[i * 2 * 9 + 3] = this.color.r;
                    this.dataForVbo[i * 2 * 9 + 4] = this.color.g;
                    this.dataForVbo[i * 2 * 9 + 5] = this.color.b;
                    this.dataForVbo[i * 2 * 9 + 6] = this.color.a * tempA;
                    this.dataForVbo[i * 2 * 9 + 7] = i / (length - 1);
                    this.dataForVbo[i * 2 * 9 + 8] = 0;
                    this.dataForVbo[(i * 2 + 1) * 9] = downpos.x;
                    this.dataForVbo[(i * 2 + 1) * 9 + 1] = downpos.y;
                    this.dataForVbo[(i * 2 + 1) * 9 + 2] = downpos.z;
                    this.dataForVbo[(i * 2 + 1) * 9 + 3] = this.color.r;
                    this.dataForVbo[(i * 2 + 1) * 9 + 4] = this.color.g;
                    this.dataForVbo[(i * 2 + 1) * 9 + 5] = this.color.b;
                    this.dataForVbo[(i * 2 + 1) * 9 + 6] = this.color.a * tempA;
                    this.dataForVbo[(i * 2 + 1) * 9 + 7] = i / (length - 1);
                    this.dataForVbo[(i * 2 + 1) * 9 + 8] = 1;
                }
                for (var k = 0; k < length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
                this.mesh.glMesh.uploadVertexData(this.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                gd3d.math.pool.delete_vector3(updir);
                gd3d.math.pool.delete_vector3(pos);
                gd3d.math.pool.delete_vector3(uppos);
                gd3d.math.pool.delete_vector3(downpos);
                this.inited = true;
            };
            trailRender.prototype.updateTrailData = function () {
                var length = this.vertexcount / 2;
                if (this.extenedOneSide) {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
                else {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x - up.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y - up.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z - up.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
            };
            trailRender.prototype.render = function (context, assetmgr, camera) {
                if (!this.active)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (this.gameObject.getScene().fog) {
                    context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            };
            trailRender.prototype.clone = function () {
            };
            trailRender.prototype.remove = function () {
            };
            trailRender.ClassName = "trailRender";
            trailRender = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], trailRender);
            return trailRender;
        }());
        framework.trailRender = trailRender;
        var trailStick = (function () {
            function trailStick() {
            }
            return trailStick;
        }());
        framework.trailStick = trailStick;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var trailRender_recorde = (function () {
            function trailRender_recorde() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this._startWidth = 1;
                this._endWidth = 0;
                this.lifetime = 0.35;
                this.minStickDistance = 0.1;
                this.maxStickCout = 12;
                this.nodes = [];
                this.interpolate = false;
                this.interpNumber = 3;
                this.interpPath = [];
                this.activeMaxpointlimit = false;
                this.notRender = false;
            }
            Object.defineProperty(trailRender_recorde.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new gd3d.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this._material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this._material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "startColor", {
                get: function () {
                    if (this._startColor == undefined) {
                        this._startColor = new gd3d.math.color(1, 1, 1, 1);
                    }
                    return this._startColor;
                },
                set: function (color) {
                    this._startColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "endColor", {
                get: function () {
                    if (this._endColor == undefined) {
                        this._endColor = new gd3d.math.color(this.startColor.r, this.startColor.g, this.startColor.b, 0);
                    }
                    return this._endColor;
                },
                set: function (color) {
                    this._endColor = color;
                },
                enumerable: true,
                configurable: true
            });
            trailRender_recorde.prototype.setWidth = function (startWidth, endWidth) {
                if (endWidth === void 0) { endWidth = 0; }
                this._startWidth = startWidth;
                this._endWidth = endWidth;
            };
            trailRender_recorde.prototype.setMaxpointcontroll = function (value) {
                if (value === void 0) { value = false; }
                this.activeMaxpointlimit = value;
            };
            trailRender_recorde.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                if (this.interpolate) {
                    this.maxStickCout *= this.interpNumber;
                    this.targetPath = this.interpPath;
                }
                else {
                    this.targetPath = this.nodes;
                }
            };
            trailRender_recorde.prototype.onPlay = function () {
            };
            trailRender_recorde.prototype.update = function (delta) {
                var _time = this.app.getTotalTime();
                this.refreshTrailNode(_time);
                this.updateTrailData(_time);
            };
            trailRender_recorde.prototype.remove = function () {
            };
            trailRender_recorde.prototype.refreshTrailNode = function (curTime) {
                while (this.targetPath.length > 0 && curTime > this.targetPath[this.targetPath.length - 1].time + this.lifetime) {
                    this.targetPath.pop();
                }
                var pos = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var length = this.targetPath.length;
                if (length != 0) {
                    if (gd3d.math.vec3Distance(pos, this.targetPath[0].location) < this.minStickDistance)
                        return;
                }
                var updir = new gd3d.math.vector3();
                this.gameObject.transform.getUpInWorld(updir);
                var newNode = new trailNode(pos, updir, curTime);
                this.nodes.unshift(newNode);
                if (this.interpolate) {
                    if (this.nodes.length > 2) {
                        var handle1 = new gd3d.math.vector3();
                        gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[0].location, handle1);
                        gd3d.math.vec3Normalize(handle1, handle1);
                        this.nodes[1].handle = handle1;
                        if (this.nodes[2].handle == undefined) {
                            var handdle = new gd3d.math.vector3();
                            gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[1].location, handdle);
                            gd3d.math.vec3Normalize(handdle, handdle);
                            this.nodes[2].handle = handdle;
                        }
                        var vec3Distance = gd3d.math.vec3Distance(this.nodes[2].location, this.nodes[1].location);
                        for (var i = 0; i < this.interpNumber; i++) {
                            var lerp = (i + 1) / (this.interpNumber + 1);
                            var inter_pos = new gd3d.math.vector3();
                            var tempRhandle = gd3d.math.pool.new_vector3();
                            var tempLhandle = gd3d.math.pool.new_vector3();
                            tempLhandle.x = -this.nodes[2].handle.x;
                            tempLhandle.y = -this.nodes[2].handle.y;
                            tempLhandle.z = -this.nodes[2].handle.z;
                            gd3d.math.vec3ScaleByNum(tempLhandle, vec3Distance / 2, tempLhandle);
                            gd3d.math.vec3Add(tempLhandle, this.nodes[2].location, tempLhandle);
                            gd3d.math.vec3ScaleByNum(this.nodes[1].handle, vec3Distance / 2, tempRhandle);
                            gd3d.math.vec3Add(tempRhandle, this.nodes[1].location, tempRhandle);
                            gd3d.math.GetPointAlongCurve(this.nodes[2].location, tempLhandle, this.nodes[1].location, tempRhandle, (i + 1) / (this.interpNumber + 1), inter_pos);
                            var inter_updir = new gd3d.math.vector3();
                            gd3d.math.vec3SLerp(this.nodes[1].updir, this.nodes[2].updir, lerp, inter_updir);
                            var inter_node = new trailNode(inter_pos, inter_updir, curTime);
                            this.interpPath.splice(1, 0, inter_node);
                            gd3d.math.pool.delete_vector3(tempRhandle);
                            gd3d.math.pool.delete_vector3(tempLhandle);
                        }
                        this.interpPath.unshift(newNode);
                    }
                }
                if (this.activeMaxpointlimit) {
                    while (this.targetPath.length > this.maxStickCout) {
                        this.targetPath.pop();
                    }
                }
            };
            trailRender_recorde.prototype.updateTrailData = function (curTime) {
                if (this.nodes.length < 2) {
                    this.notRender = true;
                    return;
                }
                else {
                    this.notRender = false;
                }
                this.checkBufferSize();
                for (var i = 0; i < this.targetPath.length; i++) {
                    var curNode = this.targetPath[i];
                    var u = i / this.targetPath.length;
                    var timeAlong = (curTime - curNode.time) / this.lifetime;
                    var _updir = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(curNode.updir, _updir);
                    var _width = this._startWidth + (this._endWidth - this._startWidth) * timeAlong;
                    gd3d.math.vec3ScaleByNum(_updir, _width, _updir);
                    var tempPos = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Add(curNode.location, _updir, tempPos);
                    this.dataForVbo[2 * i * 9 + 0] = tempPos.x;
                    this.dataForVbo[2 * i * 9 + 1] = tempPos.y;
                    this.dataForVbo[2 * i * 9 + 2] = tempPos.z;
                    var tempColor = gd3d.math.pool.new_color();
                    gd3d.math.colorLerp(this.startColor, this.endColor, timeAlong, tempColor);
                    this.dataForVbo[2 * i * 9 + 3] = tempColor.r;
                    this.dataForVbo[2 * i * 9 + 4] = tempColor.g;
                    this.dataForVbo[2 * i * 9 + 5] = tempColor.b;
                    this.dataForVbo[2 * i * 9 + 6] = tempColor.a;
                    this.dataForVbo[2 * i * 9 + 7] = u;
                    this.dataForVbo[2 * i * 9 + 8] = 1.0;
                    this.dataForVbo[(2 * i + 1) * 9 + 0] = curNode.location.x;
                    this.dataForVbo[(2 * i + 1) * 9 + 1] = curNode.location.y;
                    this.dataForVbo[(2 * i + 1) * 9 + 2] = curNode.location.z;
                    this.dataForVbo[(2 * i + 1) * 9 + 3] = tempColor.r;
                    this.dataForVbo[(2 * i + 1) * 9 + 4] = tempColor.g;
                    this.dataForVbo[(2 * i + 1) * 9 + 5] = tempColor.b;
                    this.dataForVbo[(2 * i + 1) * 9 + 6] = tempColor.a;
                    var u = i / this.nodes.length;
                    this.dataForVbo[(2 * i + 1) * 9 + 7] = u;
                    this.dataForVbo[(2 * i + 1) * 9 + 8] = 0;
                    gd3d.math.pool.delete_vector3(tempPos);
                    gd3d.math.pool.delete_color(tempColor);
                }
                for (var k = 0; k < this.nodes.length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
            };
            trailRender_recorde.prototype.checkBufferSize = function () {
                var stickNumber = this.targetPath.length;
                if (stickNumber * 2 * 9 > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    this.dataForVbo = new Float32Array(length * 2);
                }
                if ((stickNumber - 1) * 6 > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    this.dataForEbo = new Uint16Array(length * 2);
                }
            };
            trailRender_recorde.prototype.render = function (context, assetmgr, camera) {
                if (this.notRender)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = (this.targetPath.length - 1) * 6;
                if (this.gameObject.getScene().fog) {
                    context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            };
            trailRender_recorde.prototype.clone = function () {
            };
            trailRender_recorde.ClassName = "trailRender_recorde";
            trailRender_recorde = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], trailRender_recorde);
            return trailRender_recorde;
        }());
        framework.trailRender_recorde = trailRender_recorde;
        var trailNode = (function () {
            function trailNode(p, updir, t) {
                this.location = p;
                this.updir = updir;
                this.time = t;
            }
            return trailNode;
        }());
        framework.trailNode = trailNode;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var vignettingCtr = (function () {
            function vignettingCtr() {
                this.tag = "__vignettingtag__";
                this._init = false;
            }
            vignettingCtr.prototype.init = function () {
                var sh = this.scene.app.getAssetMgr().getShader("vignetting.shader.json");
                if (!sh) {
                    console.warn("vignetting.shader.json not find");
                    return;
                }
                var psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                var texsize = 512;
                var blur_post = new gd3d.framework.cameraPostQueue_Quad();
                blur_post.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post.material.setTexture("_MainTex", textcolor);
                blur_post.material.setVector4("sample_offsets", new gd3d.math.vector4(0, 1.0, 0, -1.0));
                blur_post.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post);
                var blur0 = new gd3d.framework.texture("_blur0");
                blur0.glTexture = blur_post.renderTarget;
                var blur_post1 = new gd3d.framework.cameraPostQueue_Quad();
                blur_post1.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post1.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post1.material.setTexture("_MainTex", blur0);
                blur_post1.material.setVector4("sample_offsets", new gd3d.math.vector4(1.0, 0, -1.0, 0));
                blur_post1.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post1);
                var blur = new gd3d.framework.texture("_blur0");
                blur.glTexture = blur_post1.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                this.material_1 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", blur);
                post0.material.setFloat("_Vignetting", 0.3);
                post0.material.setFloat("_Blurred_Corners", 3.0);
                post0.material.setFloat("_Chromatic_Aberration", 3.0);
                this.camera.postQueues.push(post0);
                this._init = true;
            };
            vignettingCtr.prototype.start = function () {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            };
            vignettingCtr.prototype.onPlay = function () {
            };
            vignettingCtr.prototype.update = function (delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            };
            vignettingCtr.prototype.remove = function () {
                this._init = false;
                if (this.camera) {
                    var arr_2 = this.camera.postQueues;
                    var dArr = [];
                    for (var i = 0; i < arr_2.length; i++) {
                        var temp = arr_2[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(function (element) {
                        if (element) {
                            var idx = arr_2.indexOf(element);
                            if (idx != -1) {
                                arr_2.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            };
            vignettingCtr.prototype.clone = function () {
            };
            vignettingCtr.ClassName = "vignettingCtr";
            vignettingCtr = __decorate([
                gd3d.reflect.nodeComponent
            ], vignettingCtr);
            return vignettingCtr;
        }());
        framework.vignettingCtr = vignettingCtr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var f14EffectSystem = (function () {
            function f14EffectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.queue = 10;
                this.fps = 30;
                this.layers = [];
                this.VF = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this._delayTime = 0;
                this.elements = [];
                this.renderBatch = [];
                this.loopCount = 0;
                this.allTime = 0;
                this.renderActive = false;
                this.beref = false;
                this.mvpMat = new gd3d.math.matrix();
                this.totalTime = 0;
                this.totalFrame = 0;
                this.playRate = 1.0;
                this.enabletimeFlow = false;
                this.enableDraw = false;
            }
            Object.defineProperty(f14EffectSystem.prototype, "renderLayer", {
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: true,
                configurable: true
            });
            f14EffectSystem.prototype.start = function () {
                if (this.data && this.data.beloop == true) {
                    this.play();
                }
            };
            f14EffectSystem.prototype.onPlay = function () {
            };
            Object.defineProperty(f14EffectSystem.prototype, "f14eff", {
                get: function () {
                    return this._f14eff;
                },
                set: function (asset) {
                    if (this._f14eff != null) {
                        this._f14eff.unuse();
                    }
                    this._f14eff = asset;
                    this.setData(asset.data);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(f14EffectSystem.prototype, "delay", {
                get: function () {
                    return this._delayTime;
                },
                set: function (deley) {
                    this._delayTime = deley;
                },
                enumerable: true,
                configurable: true
            });
            f14EffectSystem.prototype.setData = function (data) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.data = data;
                for (var i = 0, count = this.data.layers.length; i < count; i++) {
                    var layerdata = this.data.layers[i];
                    this.addF14layer(layerdata.type, layerdata);
                }
                for (var i = 0; i < this.renderBatch.length; i++) {
                    if (this.renderBatch[i].type == framework.F14TypeEnum.SingleMeshType) {
                        this.renderBatch[i].OnEndCollectElement();
                    }
                }
            };
            Object.defineProperty(f14EffectSystem.prototype, "root", {
                get: function () {
                    return this._root || this.gameObject.transform;
                },
                enumerable: true,
                configurable: true
            });
            f14EffectSystem.prototype.update = function (deltaTime) {
                if (this.data == null) {
                    this.renderActive = false;
                    return;
                }
                this.renderActive = true;
                if (this.enabletimeFlow) {
                    this.allTime += deltaTime * this.playRate;
                    this.totalTime = this.allTime - this._delayTime;
                    if (this.totalTime <= 0) {
                        this.renderActive = false;
                        return;
                    }
                    this.totalFrame = this.totalTime * this.fps;
                    if (!this.data.beloop && this.totalFrame > this.data.lifeTime) {
                        this.renderActive = false;
                        this.enabletimeFlow = false;
                        if (this.onFinish) {
                            this.onFinish();
                        }
                        return;
                    }
                    this.restartFrame = this.totalFrame % this.data.lifeTime;
                    this.restartFrame = Math.floor(this.restartFrame);
                    var newLoopCount = Math.floor(this.totalFrame / this.data.lifeTime);
                    if (newLoopCount != this.loopCount) {
                        this.OnEndOnceLoop();
                    }
                    this.loopCount = newLoopCount;
                    if (this.renderCamera == null)
                        return;
                    for (var i = 0; i < this.elements.length; i++) {
                        this.elements[i].update(deltaTime, this.totalFrame, this.fps);
                    }
                }
                else {
                    if (this.totalTime <= 0) {
                        this.renderActive = false;
                        return;
                    }
                    if (!this.data.beloop && this.totalFrame > this.data.lifeTime) {
                        this.renderActive = false;
                        return;
                    }
                }
            };
            f14EffectSystem.prototype.OnEndOnceLoop = function () {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].OnEndOnceLoop();
                }
            };
            Object.defineProperty(f14EffectSystem.prototype, "renderCamera", {
                get: function () {
                    if (this._renderCamera != null) {
                        return this._renderCamera;
                    }
                    else {
                        return gd3d.framework.sceneMgr.app.getScene().mainCamera;
                    }
                },
                enumerable: true,
                configurable: true
            });
            f14EffectSystem.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (Effqueue === void 0) { Effqueue = 0; }
                if (!this.renderActive || !this.enableDraw)
                    return;
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.EffectSystem;
                this._renderCamera = camera;
                var curCount = 0;
                context.updateModel(this.root);
                gd3d.math.matrixClone(context.matrixModelViewProject, this.mvpMat);
                for (var i = 0; i < this.renderBatch.length; i++) {
                    this.renderBatch[i].render(context, assetmgr, camera, Effqueue + curCount);
                    curCount += this.renderBatch[i].getElementCount();
                }
            };
            f14EffectSystem.prototype.addF14layer = function (type, layerdata) {
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14SingleMesh(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    var data = layerdata.elementdata;
                    if (this.layers.length > 1 && this.layers[this.layers.length - 2].type == type) {
                        var batch = this.layers[this.layers.length - 2].batch;
                        if (batch.type == framework.F14TypeEnum.SingleMeshType && batch.canBatch(element)) {
                            batch.addElement(element);
                            layer.batch = batch;
                        }
                        else {
                            var _batch = new framework.F14SingleMeshBath(data.material, this);
                            _batch.addElement(element);
                            layer.batch = _batch;
                            this.renderBatch.push(_batch);
                        }
                    }
                    else if (this.layers.length = 1) {
                        var batch = new framework.F14SingleMeshBath(data.material, this);
                        batch.addElement(element);
                        layer.batch = batch;
                        this.renderBatch.push(batch);
                    }
                    return layer;
                }
                else if (type == framework.F14TypeEnum.particlesType) {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14Emission(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    var batch = new framework.F14EmissionBatch(this, element);
                    layer.batch = batch;
                    this.renderBatch.push(batch);
                    return layer;
                }
                else {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14RefElement(this, layer);
                    var data = layerdata.elementdata;
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    var refbath = new framework.F14RefElementBatch(this, element);
                    this.renderBatch.push(refbath);
                    layer.batch = refbath;
                    return layer;
                }
            };
            f14EffectSystem.prototype.getElementCount = function () {
                var totalcount = 0;
                for (var i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].type == framework.F14TypeEnum.RefType) {
                        totalcount += this.layers[i].batch.getElementCount();
                    }
                    else {
                        totalcount++;
                    }
                }
                return totalcount;
            };
            f14EffectSystem.prototype.play = function (onFinish, PlayRate) {
                if (onFinish === void 0) { onFinish = null; }
                if (PlayRate === void 0) { PlayRate = 1.0; }
                if (this.allTime > 0) {
                    this.reset();
                }
                this.enabletimeFlow = true;
                this.enableDraw = true;
                this.playRate = PlayRate;
                if (onFinish) {
                    this.onFinish = onFinish;
                }
            };
            f14EffectSystem.prototype.stop = function () {
                this.enabletimeFlow = false;
                this.enableDraw = false;
                this.reset();
            };
            f14EffectSystem.prototype.pause = function () {
                this.enableDraw = true;
                this.enabletimeFlow = false;
            };
            f14EffectSystem.prototype.changeColor = function (newcolor) {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].changeColor(newcolor);
                }
            };
            f14EffectSystem.prototype.changeAlpha = function (newAlpha) {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].changeAlpha(newAlpha);
                }
            };
            f14EffectSystem.prototype.reset = function () {
                this.allTime = 0;
                for (var key in this.elements) {
                    this.elements[key].reset();
                }
            };
            f14EffectSystem.prototype.clone = function () {
            };
            f14EffectSystem.prototype.remove = function () {
                this.data = null;
                this._f14eff = null;
                this.webgl = null;
                this._root = null;
                this._renderCamera = null;
                this.gameObject = null;
                for (var key in this.layers) {
                    this.layers[key].dispose();
                }
                for (var key in this.elements) {
                    this.elements[key].dispose();
                }
                for (var key in this.renderBatch) {
                    this.renderBatch[key].dispose();
                }
                delete this.layers;
                delete this.elements;
                delete this.renderBatch;
            };
            f14EffectSystem.ClassName = "f14EffectSystem";
            __decorate([
                gd3d.reflect.Field("f14eff"),
                gd3d.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", framework.f14eff),
                __metadata("design:paramtypes", [framework.f14eff])
            ], f14EffectSystem.prototype, "f14eff", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], f14EffectSystem.prototype, "delay", null);
            f14EffectSystem = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], f14EffectSystem);
            return f14EffectSystem;
        }());
        framework.f14EffectSystem = f14EffectSystem;
        var PlayStateEnum;
        (function (PlayStateEnum) {
            PlayStateEnum[PlayStateEnum["play"] = 0] = "play";
            PlayStateEnum[PlayStateEnum["beReady"] = 1] = "beReady";
            PlayStateEnum[PlayStateEnum["pause"] = 2] = "pause";
        })(PlayStateEnum = framework.PlayStateEnum || (framework.PlayStateEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14TypeEnum;
        (function (F14TypeEnum) {
            F14TypeEnum[F14TypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            F14TypeEnum[F14TypeEnum["particlesType"] = 1] = "particlesType";
            F14TypeEnum[F14TypeEnum["RefType"] = 2] = "RefType";
        })(F14TypeEnum = framework.F14TypeEnum || (framework.F14TypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14Layer = (function () {
            function F14Layer(effect, data) {
                this.active = true;
                this.frameList = [];
                this.frames = {};
                this.Attlines = {};
                this.effect = effect;
                this.data = data;
                this.type = data.type;
                for (var ff in this.data.frames) {
                    var framedata = this.data.frames[ff];
                    this.addFrame(framedata.frameindex, framedata);
                }
            }
            F14Layer.prototype.addFrame = function (index, framedata) {
                if (this.frames[index])
                    return this.frames[index];
                var frame = new F14Frame(this, framedata);
                this.frameList.push(index);
                this.frameList.sort(function (a, b) { return a - b; });
                this.frames[index] = frame;
                return frame;
            };
            F14Layer.prototype.removeFrame = function (frame) {
                if (this.frames[frame]) {
                    delete this.frames[frame];
                    var index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                    delete this.data.frames[frame];
                }
                for (var item in this.Attlines) {
                    this.Attlines[item].remove(frame);
                }
            };
            F14Layer.prototype.dispose = function () {
                this.data = null;
                this.effect = null;
                this.frameList.length = 0;
                this.frames = null;
                this.Attlines = null;
                this.element = null;
                this.batch = null;
            };
            return F14Layer;
        }());
        framework.F14Layer = F14Layer;
        var F14Frame = (function () {
            function F14Frame(layer, data) {
                this.layer = layer;
                this.data = data;
                this.attDic = this.data.singlemeshAttDic;
                for (var key in this.data.singlemeshAttDic) {
                    this.setdata(key, this.data.singlemeshAttDic[key]);
                }
            }
            F14Frame.prototype.setdata = function (name, obj) {
                if (this.layer.Attlines[name] == null) {
                    if (obj instanceof gd3d.math.vector3) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.vec3SLerp, gd3d.math.vec3Clone);
                    }
                    else if (obj instanceof gd3d.math.vector4) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.vec4SLerp, gd3d.math.vec4Clone);
                    }
                    else if (obj instanceof gd3d.math.color) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.colorLerp, gd3d.math.colorClone);
                    }
                }
                this.layer.Attlines[name].addNode(this.data.frameindex, obj);
                this.attDic[name] = obj;
            };
            F14Frame.prototype.removedata = function (name) {
                delete this.attDic[name];
                if (this.layer.Attlines[name]) {
                    this.layer.Attlines[name].remove(this.data.frameindex);
                }
            };
            F14Frame.prototype.getdata = function (name) {
                return this.attDic[name];
            };
            return F14Frame;
        }());
        framework.F14Frame = F14Frame;
        var F14AttTimeLine = (function () {
            function F14AttTimeLine(name, lerpfunc, clonefunc) {
                this.frameList = [];
                this.line = {};
                this.name = name;
                this.lerpFunc = lerpfunc;
                this.cloneFunc = clonefunc;
            }
            F14AttTimeLine.prototype.addNode = function (frame, value) {
                var index = this.frameList.indexOf(frame);
                if (index < 0) {
                    this.frameList.push(frame);
                    this.frameList.sort(function (a, b) { return a - b; });
                }
                this.line[frame] = value;
            };
            F14AttTimeLine.prototype.remove = function (frame) {
                if (this.line[frame]) {
                    delete this.line[frame];
                    var index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                }
            };
            F14AttTimeLine.prototype.getValue = function (frame, basedate, out) {
                if (this.frameList.length == 0) {
                    return;
                }
                if (this.line[frame]) {
                    this.cloneFunc(this.line[frame], out);
                    return;
                }
                if (frame < this.frameList[0]) {
                    var toindex = this.frameList[0];
                    var from = basedate[this.name];
                    var to = this.line[toindex];
                    var lerp = (frame - basedate.firtstFrame) / toindex;
                    this.lerpFunc(from, to, lerp, out);
                }
                else if (frame >= this.frameList[this.frameList.length - 1]) {
                    this.cloneFunc(this.line[this.frameList[this.frameList.length - 1]], out);
                }
                else {
                    for (var i = 0; i < this.frameList.length; i++) {
                        if (this.frameList[i] > frame) {
                            var to = this.frameList[i];
                            var from = this.frameList[i - 1];
                            this.lerpFunc(this.line[from], this.line[to], (frame - from) / (to - from), out);
                            return;
                        }
                    }
                }
            };
            return F14AttTimeLine;
        }());
        framework.F14AttTimeLine = F14AttTimeLine;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14EffectData = (function () {
            function F14EffectData() {
                this.beloop = false;
                this.lifeTime = 100;
                this.layers = [];
            }
            F14EffectData.prototype.parsejson = function (json, assetmgr, assetbundle) {
                this.beloop = json.beloop;
                this.lifeTime = json.lifeTime;
                var jsonlayer = json.layers;
                for (var i = 0, len = jsonlayer.length; i < len; ++i) {
                    var layer = new F14LayerData();
                    layer.parse(jsonlayer[i], assetmgr, assetbundle);
                    this.layers.push(layer);
                }
            };
            return F14EffectData;
        }());
        framework.F14EffectData = F14EffectData;
        var F14LayerData = (function () {
            function F14LayerData() {
                this.Name = "newLayer";
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.frames = {};
            }
            F14LayerData.prototype.parse = function (json, assetmgr, assetbundle) {
                this.Name = json.Name;
                switch (json.type) {
                    case "particlesType":
                        this.type = framework.F14TypeEnum.particlesType;
                        this.elementdata = new framework.F14EmissionBaseData();
                        this.elementdata.parse(json.emissiondata, assetmgr, assetbundle);
                        break;
                    case "SingleMeshType":
                        this.type = framework.F14TypeEnum.SingleMeshType;
                        this.elementdata = new framework.F14SingleMeshBaseData(json.frames[0].frameindex);
                        this.elementdata.parse(json.singlemeshdata, assetmgr, assetbundle);
                        break;
                    case "RefType":
                        this.type = framework.F14TypeEnum.RefType;
                        this.elementdata = new framework.F14RefBaseData();
                        this.elementdata.parse(json.RefData, assetmgr, assetbundle);
                        break;
                    default:
                        console.log("f14Eff parse layerjson error!");
                        return;
                }
                for (var i = 0; i < json.frames.length; i++) {
                    var framejson = json.frames[i];
                    var frameindex = framejson.frameindex;
                    var frameitem = new F14FrameData(frameindex, this.type);
                    this.frames[frameindex] = frameitem;
                    switch (this.type) {
                        case framework.F14TypeEnum.SingleMeshType:
                            for (var k = 0; k < framejson.vec3Atts.length; k++) {
                                var name_6 = framejson.vec3Atts[k].name;
                                var strValue = framejson.vec3Atts[k].value;
                                var v3 = new gd3d.math.vector3();
                                gd3d.math.vec3FormJson(strValue, v3);
                                frameitem.singlemeshAttDic[name_6] = v3;
                            }
                            for (var k = 0; k < framejson.vec4Atts.length; k++) {
                                var name_7 = framejson.vec4Atts[k].name;
                                var strValue = framejson.vec4Atts[k].value;
                                var v4 = new gd3d.math.vector4();
                                gd3d.math.vec4FormJson(strValue, v4);
                                frameitem.singlemeshAttDic[name_7] = v4;
                            }
                            for (var k = 0; k < framejson.colorAtts.length; k++) {
                                var name_8 = framejson.colorAtts[k].name;
                                var strValue = framejson.colorAtts[k].value;
                                var color = new gd3d.math.color();
                                gd3d.math.colorFormJson(strValue, color);
                                frameitem.singlemeshAttDic[name_8] = color;
                            }
                            break;
                        case framework.F14TypeEnum.particlesType:
                            var data = new framework.F14EmissionBaseData();
                            data.parse(framejson.emissionData, assetmgr, assetbundle);
                            frameitem.EmissionData = data;
                    }
                }
            };
            return F14LayerData;
        }());
        framework.F14LayerData = F14LayerData;
        var F14FrameData = (function () {
            function F14FrameData(index, type) {
                this.frameindex = index;
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    this.singlemeshAttDic = {};
                }
                else {
                    this.EmissionData = new framework.F14EmissionBaseData();
                }
            }
            return F14FrameData;
        }());
        framework.F14FrameData = F14FrameData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NumberData = (function () {
            function NumberData(value) {
                if (value === void 0) { value = 0; }
                this.isRandom = false;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
                this._value = value;
            }
            NumberData.prototype.setValue = function (value) {
                this._value = value;
            };
            NumberData.prototype.setRandomValue = function (max, min) {
                this._valueLimitMax = max;
                this._valueLimitMin = min;
                this.isRandom = true;
            };
            NumberData.prototype.getValue = function (reRandom) {
                if (reRandom === void 0) { reRandom = false; }
                if (this.isRandom) {
                    if (reRandom || !this.beInited) {
                        this.key = Math.random();
                        this._value = this.key * (this._valueLimitMax - this._valueLimitMin) + this._valueLimitMin;
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            NumberData.copyto = function (from, to) {
                to.isRandom = from.isRandom;
                to._value = from._value;
                to._valueLimitMin = from._valueLimitMin;
                to._valueLimitMax = from._valueLimitMax;
            };
            NumberData.FormJson = function (json, data) {
                if (json.indexOf("~") < 0) {
                    data.setValue(Number(json));
                }
                else {
                    var arr = json.split("~");
                    data.setRandomValue(Number(arr[1]), Number(arr[0]));
                }
            };
            return NumberData;
        }());
        framework.NumberData = NumberData;
        var Vector3Data = (function () {
            function Vector3Data(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = new NumberData();
                this.y = new NumberData();
                this.z = new NumberData();
                this.x.setValue(x);
                this.y.setValue(y);
                this.z.setValue(z);
            }
            Vector3Data.prototype.getValue = function (reRandom) {
                if (reRandom === void 0) { reRandom = false; }
                var _out = new gd3d.math.vector3();
                _out.x = this.x.getValue(reRandom);
                _out.y = this.y.getValue(reRandom);
                _out.z = this.z.getValue(reRandom);
                return _out;
            };
            Vector3Data.copyto = function (from, to) {
                NumberData.copyto(from.x, to.x);
                NumberData.copyto(from.y, to.y);
                NumberData.copyto(from.z, to.z);
            };
            Vector3Data.FormJson = function (json, data) {
                var arr = json.split(",");
                NumberData.FormJson(arr[0], data.x);
                NumberData.FormJson(arr[1], data.y);
                NumberData.FormJson(arr[2], data.z);
            };
            return Vector3Data;
        }());
        framework.Vector3Data = Vector3Data;
        var NumberKey = (function () {
            function NumberKey(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return NumberKey;
        }());
        framework.NumberKey = NumberKey;
        var Vector3Key = (function () {
            function Vector3Key(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return Vector3Key;
        }());
        framework.Vector3Key = Vector3Key;
        var Vector2Key = (function () {
            function Vector2Key(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return Vector2Key;
        }());
        framework.Vector2Key = Vector2Key;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14Emission = (function () {
            function F14Emission(effect, layer) {
                this.particlelist = [];
                this.deadParticles = [];
                this.frameLife = 0;
                this.TotalTime = 0;
                this.newStartDataTime = 0;
                this.curTime = 0;
                this.beover = false;
                this.numcount = 0;
                this.localMatrix = new gd3d.math.matrix();
                this._worldMatrix = new gd3d.math.matrix();
                this.localrot = new gd3d.math.quaternion();
                this.worldRot = new gd3d.math.quaternion();
                this.lastFrame = 0;
                this.bursts = [];
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                this.currentData = this.baseddata;
                this.newStartDataTime = this.baseddata.delayTime;
                this.initBycurrentdata();
                if (this.currentData.mesh.data) {
                    this.vertexCount = this.currentData.mesh.data.pos.length;
                    this.posArr = this.currentData.mesh.data.pos;
                    this.colorArr = this.currentData.mesh.data.color;
                    this.uvArr = this.currentData.mesh.data.uv;
                    this.dataforebo = this.currentData.mesh.data.genIndexDataArray();
                    this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                    this.dataforvboLen = this.vertexCount * this.vertexLength;
                }
                else {
                    this.vertexCount = 0;
                    this.posArr = [];
                    this.colorArr = [];
                    this.uvArr = [];
                    this.dataforebo = new Uint16Array(0);
                }
            }
            F14Emission.prototype.update = function (deltaTime, frame, fps) {
                this.TotalTime += deltaTime;
                this.refreshByFrameData(fps);
                this.updateLife();
                for (var i = 0; i < this.particlelist.length; i++) {
                    this.particlelist[i].update(deltaTime);
                }
            };
            F14Emission.prototype.refreshByFrameData = function (fps) {
                this.frameLife = Math.floor(this.baseddata.duration * fps);
                if (this.frameLife == 0)
                    this.frameLife = 1;
                var frame = Math.floor(this.TotalTime * fps) % this.frameLife;
                if (frame != this.lastFrame && this.layer.frames[frame]) {
                    if (frame == this.layer.frameList[0]) {
                        this.currentData = this.baseddata;
                    }
                    if (this.layer.frames[frame].data.EmissionData != this.currentData) {
                        this.changeCurrentBaseData(this.layer.frames[frame].data.EmissionData);
                    }
                }
                this.lastFrame = frame;
            };
            F14Emission.prototype.changeCurrentBaseData = function (data) {
                this.currentData = data;
                this.newStartDataTime = this.TotalTime;
                this.numcount = 0;
                this.initBycurrentdata();
            };
            F14Emission.prototype.initBycurrentdata = function () {
                gd3d.math.quatFromEulerAngles(this.currentData.rotEuler.x, this.currentData.rotEuler.y, this.currentData.rotEuler.z, this.localrot);
                gd3d.math.matrixMakeTransformRTS(this.currentData.rotPosition, this.currentData.rotScale, this.localrot, this.localMatrix);
            };
            F14Emission.prototype.getWorldMatrix = function () {
                var mat = this.effect.root.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.localMatrix, this._worldMatrix);
                return this._worldMatrix;
            };
            F14Emission.prototype.getWorldRotation = function () {
                var rot = this.effect.root.getWorldRotate();
                gd3d.math.quatMultiply(rot, this.localrot, this.worldRot);
                return this.worldRot;
            };
            F14Emission.prototype.updateLife = function () {
                if (this.beover)
                    return;
                this.curTime = this.TotalTime - this.baseddata.delayTime;
                if (this.curTime <= 0)
                    return;
                this.updateEmission();
                if (this.curTime > this.baseddata.duration) {
                    if (this.baseddata.beloop) {
                        switch (this.baseddata.loopenum) {
                            case framework.LoopEnum.Restart:
                                this.reInit();
                                break;
                            case framework.LoopEnum.TimeContinue:
                                this.beover = true;
                                break;
                        }
                    }
                    else {
                        this.beover = true;
                    }
                }
            };
            F14Emission.prototype.reInit = function () {
                this.currentData = this.baseddata;
                this.newStartDataTime = this.baseddata.delayTime;
                this.beover = false;
                this.TotalTime = 0;
                this.numcount = 0;
                this.currentData.rateOverTime.getValue(true);
                if (this.settedAlpha != null) {
                    this.currentData.startAlpha = new framework.NumberData(this.baseddata.startAlpha._value * this.settedAlpha);
                }
                this.bursts = [];
            };
            F14Emission.prototype.updateEmission = function () {
                var needCount = Math.floor(this.currentData.rateOverTime.getValue() * (this.TotalTime - this.newStartDataTime));
                var realcount = needCount - this.numcount;
                if (realcount > 0) {
                    this.addParticle(realcount);
                }
                this.numcount += realcount;
                if (this.baseddata.bursts.length > 0) {
                    for (var i = 0; i < this.baseddata.bursts.length; i++) {
                        var index = this.bursts.indexOf(this.baseddata.bursts[i].time);
                        if (index < 0 && this.baseddata.bursts[i].time <= this.TotalTime) {
                            var count = this.baseddata.bursts[i].count.getValue(true);
                            this.baseddata.bursts[i].burst();
                            this.bursts.push(this.baseddata.bursts[i].time);
                            this.addParticle(count);
                        }
                    }
                }
            };
            F14Emission.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var pp = this.deadParticles.pop();
                        pp.initByEmissionData(this.currentData);
                    }
                    else {
                        var pp = new framework.F14Particle(this, this.currentData);
                        this.particlelist.push(pp);
                    }
                }
            };
            F14Emission.prototype.reset = function () {
                this.reInit();
                for (var i = 0; i < this.particlelist.length; i++) {
                    if (this.particlelist[i].actived) {
                        this.particlelist[i].actived = false;
                        this.deadParticles.push(this.particlelist[i]);
                    }
                }
            };
            F14Emission.prototype.changeColor = function (value) {
                this.currentData.startColor = new framework.Vector3Data(value.r, value.g, value.b);
                this.currentData.startAlpha = new framework.NumberData(value.a);
            };
            F14Emission.prototype.changeAlpha = function (value) {
                this.currentData.startAlpha = new framework.NumberData(this.baseddata.startAlpha._value * value);
                this.settedAlpha = value;
            };
            F14Emission.prototype.OnEndOnceLoop = function () {
            };
            F14Emission.prototype.dispose = function () {
                this.effect = null;
                this.baseddata = null;
                this.currentData = null;
                delete this.dataforebo;
                delete this.posArr;
                delete this.colorArr;
                delete this.uvArr;
                delete this.bursts;
                for (var key in this.particlelist) {
                    this.particlelist[key].dispose();
                }
                for (var key in this.deadParticles) {
                    this.deadParticles[key].dispose();
                }
            };
            return F14Emission;
        }());
        framework.F14Emission = F14Emission;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RenderModelEnum;
        (function (RenderModelEnum) {
            RenderModelEnum[RenderModelEnum["None"] = 0] = "None";
            RenderModelEnum[RenderModelEnum["BillBoard"] = 1] = "BillBoard";
            RenderModelEnum[RenderModelEnum["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModelEnum[RenderModelEnum["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModelEnum[RenderModelEnum["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModelEnum[RenderModelEnum["Mesh"] = 5] = "Mesh";
        })(RenderModelEnum = framework.RenderModelEnum || (framework.RenderModelEnum = {}));
        var F14EmissionBaseData = (function () {
            function F14EmissionBaseData() {
                this.loopenum = framework.LoopEnum.Restart;
                this.rotPosition = new gd3d.math.vector3();
                this.rotScale = new gd3d.math.vector3(1, 1, 1);
                this.rotEuler = new gd3d.math.vector3();
                this.rendermodel = RenderModelEnum.Mesh;
                this.beloop = true;
                this.lifeTime = new framework.NumberData(20);
                this.simulateInLocalSpace = true;
                this.startScaleRate = new framework.NumberData(1);
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                this.startColor = new framework.Vector3Data(1, 1, 1);
                this.startAlpha = new framework.NumberData(1);
                this.colorRate = 1;
                this.simulationSpeed = new framework.NumberData(1);
                this.start_tex_st = new gd3d.math.vector4(1, 1, 0, 0);
                this.delayTime = 0;
                this.duration = 10;
                this.rateOverTime = new framework.NumberData(1);
                this.bursts = [];
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.emitFrom = framework.emitfromenum.base;
                this.enableVelocityOverLifetime = false;
                this.moveSpeed = new framework.Vector3Data(0);
                this.enableSizeOverLifetime = false;
                this.sizeNodes = [];
                this.enableRotOverLifeTime = false;
                this.angleSpeed = new framework.NumberData(0);
                this.enableColorOverLifetime = false;
                this.colorNodes = [];
                this.alphaNodes = [];
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
            }
            F14EmissionBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = framework.LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = framework.LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = assetmgr.getAssetByName(json.mesh, assetbundle);
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                gd3d.math.vec3FormJson(json.rotPosition, this.rotPosition);
                gd3d.math.vec3FormJson(json.rotScale, this.rotScale);
                gd3d.math.vec3FormJson(json.rotEuler, this.rotEuler);
                switch (json.rendermodel) {
                    default:
                    case "BillBoard":
                        this.rendermodel = RenderModelEnum.BillBoard;
                        break;
                    case "HorizontalBillBoard":
                        this.rendermodel = RenderModelEnum.HorizontalBillBoard;
                        break;
                    case "Mesh":
                        this.rendermodel = RenderModelEnum.Mesh;
                        break;
                    case "StretchedBillBoard":
                        this.rendermodel = RenderModelEnum.StretchedBillBoard;
                        break;
                    case "VerticalBillBoard":
                        this.rendermodel = RenderModelEnum.VerticalBillBoard;
                        break;
                    case "None":
                        this.rendermodel = RenderModelEnum.None;
                        break;
                }
                this.beloop = json.beloop;
                framework.NumberData.FormJson(json.lifeTime, this.lifeTime);
                this.simulateInLocalSpace = json.simulateInLocalSpace;
                framework.NumberData.FormJson(json.startScaleRate, this.startScaleRate);
                framework.Vector3Data.FormJson(json.startScale, this.startScale);
                framework.Vector3Data.FormJson(json.startEuler, this.startEuler);
                framework.Vector3Data.FormJson(json.startColor, this.startColor);
                framework.NumberData.FormJson(json.startAlpha, this.startAlpha);
                this.colorRate = json.colorRate;
                framework.NumberData.FormJson(json.simulationSpeed, this.simulationSpeed);
                gd3d.math.vec4FormJson(json.start_tex_st, this.start_tex_st);
                this.delayTime = json.delayTime;
                this.duration = json.duration;
                framework.NumberData.FormJson(json.rateOverTime, this.rateOverTime);
                for (var i = 0; i < json.bursts.length; i++) {
                    var item = json.bursts[i];
                    var info = busrtInfo.CreatformJson(item);
                    this.bursts.push(info);
                }
                switch (json.shapeType) {
                    case "NORMAL":
                        this.shapeType = framework.ParticleSystemShape.NORMAL;
                        break;
                    case "BOX":
                        this.shapeType = framework.ParticleSystemShape.BOX;
                        this.width = json.width;
                        this.height = json.height;
                        this.depth = json.depth;
                        break;
                    case "SPHERE":
                        this.shapeType = framework.ParticleSystemShape.SPHERE;
                        this.radius = json.radius;
                        break;
                    case "HEMISPHERE":
                        this.shapeType = framework.ParticleSystemShape.HEMISPHERE;
                        this.radius = json.radius;
                        break;
                    case "CONE":
                        this.shapeType = framework.ParticleSystemShape.CONE;
                        this.height = json.height;
                        this.angle = json.angle;
                        this.radius = json.radius;
                        switch (json.emitFrom) {
                            case "base_":
                                this.emitFrom = framework.emitfromenum.base;
                                break;
                            case "volume":
                                this.emitFrom = framework.emitfromenum.volume;
                                break;
                        }
                        break;
                    case "CIRCLE":
                        this.shapeType = framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "EDGE":
                        this.shapeType = framework.ParticleSystemShape.EDGE;
                        break;
                }
                this.enableVelocityOverLifetime = json.enableVelocityOverLifetime;
                if (this.enableVelocityOverLifetime) {
                    framework.Vector3Data.FormJson(json.moveSpeed, this.moveSpeed);
                }
                this.enableSizeOverLifetime = json.enableSizeOverLifetime;
                if (this.enableSizeOverLifetime) {
                    for (var i = 0; i < json.sizeNodes.length; i++) {
                        var jsonitem = json.sizeNodes[i];
                        var item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.sizeNodes.push(item);
                    }
                }
                this.enableRotOverLifeTime = json.enableRotOverLifeTime;
                if (this.enableRotOverLifeTime) {
                    framework.NumberData.FormJson(json.angleSpeed, this.angleSpeed);
                }
                this.enableColorOverLifetime = json.enableColorOverLifetime;
                if (this.enableColorOverLifetime) {
                    for (var i = 0; i < json.colorNodes.length; i++) {
                        var jsonitem = json.colorNodes[i];
                        var v3 = new gd3d.math.vector3();
                        gd3d.math.vec3FormJson(jsonitem.value, v3);
                        var item = new framework.Vector3Key(jsonitem.key, v3);
                        this.colorNodes.push(item);
                    }
                    for (var i = 0; i < json.alphaNodes.length; i++) {
                        var jsonitem = json.alphaNodes[i];
                        var item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.alphaNodes.push(item);
                    }
                }
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
            };
            F14EmissionBaseData.getRandomDirAndPosByZEmission = function (emission, outDir, outPos) {
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_zero, outPos);
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        var radius = Math.random() * emission.radius;
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        gd3d.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2;
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = gd3d.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            gd3d.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            };
            return F14EmissionBaseData;
        }());
        framework.F14EmissionBaseData = F14EmissionBaseData;
        var busrtInfo = (function () {
            function busrtInfo() {
                this.time = 0;
                this.count = new framework.NumberData(10);
                this._beburst = false;
            }
            busrtInfo.prototype.beburst = function () {
                return this._beburst;
            };
            busrtInfo.prototype.burst = function (bebusrt) {
                if (bebusrt === void 0) { bebusrt = true; }
                this._beburst = bebusrt;
            };
            busrtInfo.CreatformJson = function (json) {
                var info = new busrtInfo();
                info.time = json.time;
                framework.NumberData.FormJson(json.count, info.count);
                return info;
            };
            return busrtInfo;
        }());
        framework.busrtInfo = busrtInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14EmissionBatch = (function () {
            function F14EmissionBatch(effect, element) {
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.emission = element;
                var datamesh = this.emission.baseddata.mesh;
                this.mesh = new framework.mesh();
                this.mat = this.emission.baseddata.material;
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                var maxParticlesCount = this.getMaxParticleCount();
                var particleVertexCount = datamesh.data.pos.length;
                var particleIndexCount = datamesh.data.trisindex.length;
                var totalVertex = maxParticlesCount * particleVertexCount;
                var totalIndex = maxParticlesCount * particleIndexCount;
                this.dataForVbo = new Float32Array(totalVertex * this.vertexLength);
                this.dataForEbo = new Uint16Array(totalIndex);
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertex, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            }
            F14EmissionBatch.prototype.getMaxParticleCount = function () {
                var maxrate;
                var basrat = this.emission.baseddata.rateOverTime;
                maxrate = basrat.isRandom ? basrat._valueLimitMax : basrat._value;
                var liftime = this.emission.baseddata.lifeTime;
                var maxlife = liftime.isRandom ? Math.max(liftime._valueLimitMax, liftime._valueLimitMin) : liftime._value;
                if (!this.emission.baseddata.beloop) {
                    var duration = this.emission.baseddata.duration;
                    if (duration < maxlife) {
                        maxlife = duration;
                    }
                }
                for (var item in this.emission.layer.frameList) {
                    var frame = this.emission.layer.frameList[item];
                    var framerate = this.emission.layer.frames[frame].data.EmissionData.rateOverTime;
                    var rate = framerate.isRandom ? framerate._valueLimitMax : framerate._value;
                    if (rate > maxrate) {
                        maxrate = rate;
                    }
                }
                var burstCount = 0;
                for (var i = 0; i < this.emission.baseddata.bursts.length; i++) {
                    var info = this.emission.baseddata.bursts[i];
                    var Count = info.count.isRandom ? info.count._valueLimitMax : info.count._value;
                    burstCount += Count;
                }
                return Math.floor(maxrate * maxlife + burstCount + 2);
            };
            F14EmissionBatch.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (this.emission.baseddata.simulateInLocalSpace) {
                    gd3d.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                }
                else {
                    context.updateModeTrail();
                }
                this.mat.setQueue(Effqueue);
                this.curIndexCount = 0;
                this.curVertexcount = 0;
                this.curRealVboCount = 0;
                for (var i = 0, len = this.emission.particlelist.length; i < len; i++) {
                    this.emission.particlelist[i].uploadMeshdata();
                }
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
                this.mat.draw(context, this.mesh, this.mesh.submesh[0]);
            };
            F14EmissionBatch.prototype.unRender = function () {
            };
            F14EmissionBatch.prototype.getElementCount = function () {
                return 1;
            };
            F14EmissionBatch.prototype.dispose = function () {
                this.effect = null;
                this.emission = null;
                this.mesh = null;
                this.mat = null;
                delete this.dataForEbo;
                delete this.dataForVbo;
            };
            return F14EmissionBatch;
        }());
        framework.F14EmissionBatch = F14EmissionBatch;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14Particle = (function () {
            function F14Particle(element, data) {
                this.StartPos = new gd3d.math.vector3();
                this.speedDir = new gd3d.math.vector3();
                this.tex_ST = new gd3d.math.vector4();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.startRotation = new gd3d.math.quaternion();
                this.rotAngle = 0;
                this.localMatrix = new gd3d.math.matrix();
                this.localTranslate = new gd3d.math.vector3();
                this.localRotation = new gd3d.math.quaternion();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.color = new gd3d.math.vector3(1, 1, 1);
                this.alpha = 1;
                this.Color = new gd3d.math.color();
                this.life01 = 0;
                this.actived = false;
                this.tempos = gd3d.math.pool.new_vector3();
                this.temcolor = gd3d.math.pool.new_color();
                this.temUv = gd3d.math.pool.new_vector2();
                this.transformVertex = new gd3d.math.matrix();
                this.angleRot = new gd3d.math.quaternion();
                this.worldpos = new gd3d.math.vector3();
                this.tarWorldpos = new gd3d.math.vector3();
                this.worldspeeddir = new gd3d.math.vector3();
                this.lookDir = new gd3d.math.vector3();
                this.temptx = new gd3d.math.vector3();
                this.worldRotation = new gd3d.math.quaternion();
                this.invParWorldRot = new gd3d.math.quaternion();
                this.worldStartPos = new gd3d.math.vector3();
                this.data = data;
                this.element = element;
                this.initByEmissionData(data);
            }
            F14Particle.prototype.getEmissionMatToWorld = function () {
                if (this.data.simulateInLocalSpace) {
                    return this.element.getWorldMatrix();
                }
                else {
                    return this.emissionMatToWorld;
                }
            };
            F14Particle.prototype.getemissionWorldRotation = function () {
                if (this.data.simulateInLocalSpace) {
                    return this.element.getWorldRotation();
                }
                else {
                    return this.emissionWorldRotation;
                }
            };
            F14Particle.prototype.initByEmissionData = function (data) {
                this.actived = true;
                this.curLife = 0;
                this.totalLife = data.lifeTime.getValue(true);
                this.simulateInLocalSpace = data.simulateInLocalSpace;
                this.simulationSpeed = data.simulationSpeed.getValue(true);
                this.startScaleRate = data.startScaleRate.getValue(true);
                this.startScale = data.startScale.getValue(true);
                gd3d.math.vec3ScaleByNum(this.startScale, this.startScaleRate, this.startScale);
                this.Starteuler = data.startEuler.getValue(true);
                this.startColor = data.startColor.getValue(true);
                this.startAlpha = data.startAlpha.getValue(true);
                this.colorRate = data.colorRate;
                this.starTex_ST = data.start_tex_st;
                this.movespeed = data.moveSpeed.getValue(true);
                this.sizeNodes = data.sizeNodes;
                this.eulerSpeed = data.angleSpeed.getValue(true);
                this.colorNodes = data.colorNodes;
                this.alphaNodes = data.alphaNodes;
                this.uvType = data.uvType;
                this.getCurTex_ST(data);
                framework.F14EmissionBaseData.getRandomDirAndPosByZEmission(data, this.speedDir, this.StartPos);
                gd3d.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                this.rotAngle = 0;
                gd3d.math.vec3Clone(this.startScale, this.localScale);
                gd3d.math.vec3Clone(this.startColor, this.color);
                this.alpha = this.startAlpha;
                gd3d.math.vec4Clone(this.starTex_ST, this.tex_ST);
                if (!data.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    gd3d.math.matrixClone(this.element.getWorldMatrix(), this.emissionMatToWorld);
                    gd3d.math.quatClone(this.element.getWorldRotation(), this.emissionWorldRotation);
                }
                if (data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformNormal(this.speedDir, this.emissionMatToWorld, this.worldspeeddir);
                    gd3d.math.vec3Normalize(this.worldspeeddir, this.worldspeeddir);
                    gd3d.math.matrixTransformVector3(this.StartPos, this.emissionMatToWorld, this.worldStartPos);
                }
            };
            F14Particle.prototype.update = function (deltaTime) {
                if (!this.actived)
                    return;
                this.curLife += deltaTime;
                this.life01 = this.curLife / this.totalLife;
                if (this.life01 > 1) {
                    this.actived = false;
                    this.element.deadParticles.push(this);
                    return;
                }
                this.updatePos();
                this.updateSize();
                this.updateEuler();
                this.updateRot();
                this.updateLocalMatrix();
                this.updateColor();
                this.updateUV();
            };
            F14Particle.prototype.uploadMeshdata = function () {
                if (this.actived) {
                    var batch = this.element.layer.batch;
                    for (var i = 0; i < this.element.vertexCount; i++) {
                        gd3d.math.matrixTransformVector3(this.element.posArr[i], this.transformVertex, this.tempos);
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                        if (this.element.colorArr) {
                            gd3d.math.colorMultiply(this.element.colorArr[i], this.Color, this.temcolor);
                        }
                        else {
                            gd3d.math.colorClone(this.Color, this.temcolor);
                        }
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temcolor.r;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temcolor.g;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temcolor.b;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temcolor.a;
                        this.temUv.x = this.element.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                        this.temUv.y = this.element.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                    }
                    for (var i = 0; i < this.element.dataforebo.length; i++) {
                        batch.dataForEbo[i + batch.curIndexCount] = this.element.dataforebo[i] + batch.curVertexcount;
                    }
                    batch.curRealVboCount += this.element.dataforvboLen;
                    batch.curIndexCount += this.element.dataforebo.length;
                    batch.curVertexcount += this.element.vertexCount;
                }
            };
            F14Particle.prototype.updateLocalMatrix = function () {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.data.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.element.localMatrix, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            F14Particle.prototype.updatePos = function () {
                gd3d.math.vec3ScaleByNum(this.speedDir, this.simulationSpeed * this.curLife, this.localTranslate);
                gd3d.math.vec3Add(this.localTranslate, this.StartPos, this.localTranslate);
                if (this.data.enableVelocityOverLifetime) {
                    var moved = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3ScaleByNum(this.movespeed, this.curLife, moved);
                    gd3d.math.vec3Add(this.localTranslate, moved, this.localTranslate);
                    gd3d.math.pool.delete_vector3(moved);
                }
            };
            F14Particle.prototype.updateSize = function () {
                if (this.data.enableSizeOverLifetime && this.sizeNodes.length > 0) {
                    if (this.sizeNodes[0].key > this.life01) {
                        var tar = gd3d.math.numberLerp(1, this.sizeNodes[0].value, this.life01 / this.sizeNodes[0].key);
                        gd3d.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                        return;
                    }
                    for (var i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life01 && this.sizeNodes[i + 1].key >= this.life01) {
                            var tar = gd3d.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life01 - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            gd3d.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                            break;
                        }
                    }
                }
            };
            F14Particle.prototype.updateEuler = function () {
                if (this.data.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            };
            F14Particle.prototype.updateRot = function () {
                if (this.data.rendermodel == framework.RenderModelEnum.Mesh) {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_up, this.rotAngle, this.angleRot);
                    gd3d.math.quatMultiply(this.rotationByEuler, this.angleRot, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.BillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var targetTrans = this.element.effect.renderCamera.gameObject.transform;
                    this.tarWorldpos = targetTrans.getWorldTranslate();
                    targetTrans.getRightInWorld(this.temptx);
                    gd3d.math.vec3ScaleByNum(this.temptx, -1, this.temptx);
                    gd3d.math.vec3Subtract(this.tarWorldpos, this.worldpos, this.lookDir);
                    gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                    gd3d.math.vec3Cross(this.lookDir, this.temptx, this.worldspeeddir);
                    gd3d.math.unitxyzToRotation(this.temptx, this.worldspeeddir, this.lookDir, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.HorizontalBillBoard) {
                    this.worldRotation.x = -0.5;
                    this.worldRotation.y = 0.5;
                    this.worldRotation.z = 0.5;
                    this.worldRotation.w = 0.5;
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.VerticalBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.vec3Clone(campos, this.tarWorldpos);
                    this.tarWorldpos.y = this.worldpos.y;
                    gd3d.math.quatLookat(this.worldpos, this.tarWorldpos, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.vec3Subtract(campos, this.worldpos, this.lookDir);
                    gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                    gd3d.math.vec3Cross(this.worldspeeddir, this.lookDir, this.temptx);
                    gd3d.math.vec3Cross(this.temptx, this.worldspeeddir, this.lookDir);
                    gd3d.math.unitxyzToRotation(this.temptx, this.worldspeeddir, this.lookDir, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                }
            };
            F14Particle.prototype.updateColor = function () {
                if (this.data.enableColorOverLifetime) {
                    if (this.colorNodes.length > 0) {
                        if (this.colorNodes[0].key > this.life01) {
                            gd3d.math.vec3SLerp(this.startColor, this.colorNodes[0].value, this.life01 / this.colorNodes[0].key, this.color);
                        }
                        else {
                            for (var i = 0; i < this.colorNodes.length - 1; i++) {
                                if (this.colorNodes[i].key <= this.life01 && this.colorNodes[i + 1].key >= this.life01) {
                                    gd3d.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life01 - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                    break;
                                }
                            }
                        }
                    }
                    if (this.alphaNodes.length > 0) {
                        if (this.alphaNodes[0].key > this.life01) {
                            this.alpha = gd3d.math.numberLerp(this.startAlpha, this.alphaNodes[0].value, this.life01 / this.alphaNodes[0].key);
                        }
                        else {
                            for (var i = 0; i < this.alphaNodes.length - 1; i++) {
                                if (this.alphaNodes[i].key <= this.life01 && this.alphaNodes[i + 1].key >= this.life01) {
                                    this.alpha = gd3d.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life01 - this.alphaNodes[i].key) / (this.alphaNodes[i + 1].key - this.alphaNodes[i].key));
                                    break;
                                }
                            }
                        }
                    }
                }
                this.Color.r = this.color.x;
                this.Color.g = this.color.y;
                this.Color.b = this.color.z;
                this.Color.a = this.alpha;
            };
            F14Particle.prototype.updateUV = function () {
                this.getCurTex_ST(this.data);
            };
            F14Particle.prototype.getCurTex_ST = function (data) {
                if (!data.enableTexAnimation)
                    return;
                if (data.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.x = 1;
                    this.tex_ST.y = 1;
                    this.tex_ST.z = data.uSpeed * this.curLife;
                    this.tex_ST.w = data.vSpeed * this.curLife;
                }
                else {
                    var index = Math.floor(this.life01 * data.count);
                    if (index >= data.count)
                        index = data.count - 1;
                    gd3d.math.spriteAnimation(data.row, data.column, index, this.tex_ST);
                }
            };
            F14Particle.prototype.dispose = function () {
                this.data = null;
                this.element = null;
                delete this.sizeNodes;
                delete this.colorNodes;
                delete this.alphaNodes;
            };
            return F14Particle;
        }());
        framework.F14Particle = F14Particle;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14RefElementBatch = (function () {
            function F14RefElementBatch(effect, element) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.element = element;
            }
            F14RefElementBatch.prototype.unRender = function () {
            };
            F14RefElementBatch.prototype.getElementCount = function () {
                return this.element.RefEffect.getElementCount();
            };
            F14RefElementBatch.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (this.element.drawActive) {
                    this.element.RefEffect.render(context, assetmgr, camera, Effqueue);
                }
                else {
                }
            };
            F14RefElementBatch.prototype.dispose = function () {
                this.effect = null;
                this.element = null;
            };
            return F14RefElementBatch;
        }());
        framework.F14RefElementBatch = F14RefElementBatch;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14RefBaseData = (function () {
            function F14RefBaseData() {
                this.beLoop = false;
                this.localPos = new gd3d.math.vector3();
                this.localEuler = new gd3d.math.vector3();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
            }
            F14RefBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                this.beLoop = json.beLoop;
                this.refdataName = json.F14EffectData;
                gd3d.math.vec3FormJson(json.localPos, this.localPos);
                gd3d.math.vec3FormJson(json.localEuler, this.localEuler);
                gd3d.math.vec3FormJson(json.localScale, this.localScale);
            };
            return F14RefBaseData;
        }());
        framework.F14RefBaseData = F14RefBaseData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14RefElement = (function () {
            function F14RefElement(effect, layer) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.baseddata = layer.data.elementdata;
                this.layer = layer;
                var f14Dat = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.baseddata.refdataName);
                if (!f14Dat)
                    return;
                this.refreshStartEndFrame();
                this.RefEffect = new framework.f14EffectSystem();
                this.RefEffect._root = new framework.transform();
                this.RefEffect.enableDraw = true;
                this.RefEffect.gameObject = this.RefEffect._root.gameObject;
                var data = layer.data.elementdata;
                gd3d.math.vec3Clone(data.localPos, this.RefEffect._root.localTranslate);
                gd3d.math.vec3Clone(data.localScale, this.RefEffect._root.localScale);
                gd3d.math.quatFromEulerAngles(data.localEuler.x, data.localEuler.y, data.localEuler.z, this.RefEffect._root.localRotate);
                this.RefEffect._root.markDirty();
                this.RefEffect.beref = true;
                this.baseddata.refData = f14Dat.data;
                this.RefEffect.setData(this.baseddata.refData);
            }
            F14RefElement.prototype.reset = function () {
                this.RefEffect.reset();
            };
            F14RefElement.prototype.refreshStartEndFrame = function () {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            };
            F14RefElement.prototype.update = function (deltaTime, frame, fps) {
                if (this.RefEffect && this.RefEffect._root.parent == null) {
                    this.effect.gameObject.transform.addChild(this.RefEffect._root);
                    this.RefEffect._root.markDirty();
                    this.RefEffect._root.updateWorldTran();
                }
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    frame = this.effect.restartFrame;
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    this.RefEffect["playState"] = framework.PlayStateEnum.beReady;
                    return;
                }
                else {
                    this.drawActive = true;
                    this.RefEffect.enabletimeFlow = true;
                }
                this.RefEffect.update(deltaTime);
            };
            F14RefElement.prototype.OnEndOnceLoop = function () {
            };
            F14RefElement.prototype.changeColor = function (value) {
                this.RefEffect.changeColor(value);
            };
            F14RefElement.prototype.changeAlpha = function (value) {
                this.RefEffect.changeAlpha(value);
            };
            F14RefElement.prototype.dispose = function () {
                this.baseddata = null;
                this.RefEffect.remove();
                this.RefEffect = null;
            };
            return F14RefElement;
        }());
        framework.F14RefElement = F14RefElement;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14SingleMesh = (function () {
            function F14SingleMesh(effect, layer) {
                this.position = new gd3d.math.vector3();
                this.scale = new gd3d.math.vector3();
                this.euler = new gd3d.math.vector3();
                this.color = new gd3d.math.color();
                this.tex_ST = new gd3d.math.vector4();
                this.localRotate = new gd3d.math.quaternion();
                this.targetMat = new gd3d.math.matrix();
                this.tempos = gd3d.math.pool.new_vector3();
                this.temColor = gd3d.math.pool.new_color();
                this.temUv = gd3d.math.pool.new_vector2();
                this.eulerRot = new gd3d.math.quaternion();
                this.worldpos = new gd3d.math.vector3();
                this.worldRot = new gd3d.math.quaternion();
                this.inverseRot = new gd3d.math.quaternion();
                this.lookDir = new gd3d.math.vector3();
                this.worldDirx = new gd3d.math.vector3();
                this.worldDiry = new gd3d.math.vector3();
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                gd3d.math.vec3Clone(this.baseddata.position, this.position);
                gd3d.math.vec3Clone(this.baseddata.scale, this.scale);
                gd3d.math.vec3Clone(this.baseddata.euler, this.euler);
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                gd3d.math.colorClone(this.baseddata.color, this.color);
                gd3d.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
                this.refreshStartEndFrame();
                this.posArr = this.baseddata.mesh.data.pos;
                this.colorArr = this.baseddata.mesh.data.color;
                this.uvArr = this.baseddata.mesh.data.uv;
                this.vertexCount = this.posArr.length;
                this.dataforvbo = this.baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                this.dataforebo = this.baseddata.mesh.data.genIndexDataArray();
            }
            F14SingleMesh.prototype.refreshStartEndFrame = function () {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            };
            F14SingleMesh.prototype.update = function (deltaTime, frame, fps) {
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    switch (this.baseddata.loopenum) {
                        case framework.LoopEnum.Restart:
                            frame = this.effect.restartFrame;
                            break;
                        case framework.LoopEnum.TimeContinue:
                            break;
                    }
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    return;
                }
                else {
                    this.drawActive = true;
                }
                for (var item in this.layer.Attlines) {
                    var att = this.layer.Attlines[item];
                    att.getValue(frame, this.baseddata, this[item]);
                }
                if (this.baseddata.enableTexAnimation) {
                    this.refreshCurTex_ST(frame, deltaTime, fps);
                }
                this.updateRotByBillboard();
                this.refreshTargetMatrix();
            };
            F14SingleMesh.prototype.OnEndOnceLoop = function () {
                this.reset();
            };
            F14SingleMesh.prototype.refreshTargetMatrix = function () {
                gd3d.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
            };
            F14SingleMesh.prototype.uploadMeshdata = function () {
                var batch = this.layer.batch;
                for (var i = 0; i < this.vertexCount; i++) {
                    gd3d.math.matrixTransformVector3(this.posArr[i], this.targetMat, this.tempos);
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                    if (this.colorArr) {
                        gd3d.math.colorMultiply(this.colorArr[i], this.color, this.temColor);
                    }
                    else {
                        gd3d.math.colorClone(this.color, this.temColor);
                    }
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temColor.r;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temColor.g;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temColor.b;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temColor.a;
                    this.temUv.x = this.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                    this.temUv.y = this.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                }
                for (var i = 0; i < this.dataforebo.length; i++) {
                    batch.dataForEbo[i + batch.curIndexCount] = this.dataforebo[i] + batch.curVertexcount;
                }
                batch.curRealVboCount += this.dataforvbo.length;
                batch.curIndexCount += this.dataforebo.length;
                batch.curVertexcount += this.vertexCount;
            };
            F14SingleMesh.prototype.refreshCurTex_ST = function (curframe, detalTime, fps) {
                if (this.baseddata.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z += this.baseddata.uSpeed * detalTime;
                    this.tex_ST.w += this.baseddata.vSpeed * detalTime;
                }
                else if (this.baseddata.uvType == framework.UVTypeEnum.UVSprite) {
                    var lerp = (curframe - this.startFrame) / (this.endFrame + 1 - this.startFrame);
                    var spritindex = Math.floor(lerp * this.baseddata.count);
                    gd3d.math.spriteAnimation(this.baseddata.row, this.baseddata.column, spritindex, this.tex_ST);
                }
            };
            F14SingleMesh.prototype.updateRotByBillboard = function () {
                if (this.baseddata.beBillboard) {
                    if (this.baseddata.bindAxis == framework.BindAxis.NONE) {
                        var mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.quatLookat(this.worldpos, targetpos, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                        gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.euler.z, this.eulerRot);
                        gd3d.math.quatMultiply(this.localRotate, this.eulerRot, this.localRotate);
                    }
                    else if (this.baseddata.bindAxis == framework.BindAxis.X) {
                        var mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                        gd3d.math.matrixMakeTransformRTS(this.baseddata.position, this.baseddata.scale, this.localRotate, this.targetMat);
                        gd3d.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.targetMat, this.worldDirx);
                        gd3d.math.vec3Normalize(this.worldDirx, this.worldDirx);
                        gd3d.math.vec3Cross(this.lookDir, this.worldDirx, this.worldDiry);
                        gd3d.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        gd3d.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                    else {
                        var mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                        gd3d.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
                        gd3d.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.targetMat, this.worldDiry);
                        gd3d.math.vec3Normalize(this.worldDiry, this.worldDiry);
                        gd3d.math.vec3Cross(this.worldDiry, this.lookDir, this.worldDirx);
                        gd3d.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        gd3d.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                }
                else {
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                }
            };
            F14SingleMesh.prototype.reset = function () {
                gd3d.math.vec3Clone(this.baseddata.position, this.position);
                gd3d.math.vec3Clone(this.baseddata.scale, this.scale);
                gd3d.math.vec3Clone(this.baseddata.euler, this.euler);
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                gd3d.math.colorClone(this.baseddata.color, this.color);
                gd3d.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
            };
            F14SingleMesh.prototype.changeColor = function (value) {
                this.color = value;
            };
            F14SingleMesh.prototype.changeAlpha = function (value) {
                this.settedAlpha = value;
            };
            F14SingleMesh.prototype.dispose = function () {
                this.layer = null;
                this.RenderBatch = null;
                this.baseddata = null;
                this.effect = null;
                delete this.posArr;
                delete this.colorArr;
                delete this.uvArr;
                delete this.dataforvbo;
                delete this.dataforebo;
            };
            return F14SingleMesh;
        }());
        framework.F14SingleMesh = F14SingleMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14SingleMeshBath = (function () {
            function F14SingleMeshBath(mat, effect) {
                this.meshlist = [];
                this.activemeshlist = [];
                this.mesh = new framework.mesh();
                this.indices = [];
                this.vertices = [];
                this.colors = [];
                this.uv = [];
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.noBatch = false;
                this.mat = new gd3d.math.matrix();
                this.defST = new gd3d.math.vector4(1, 1, 0, 0);
                this.temptColorv4 = new gd3d.math.vector4();
                this.uploadData = false;
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.ElementMat = mat;
            }
            F14SingleMeshBath.prototype.OnEndCollectElement = function () {
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                if (this.meshlist.length == 1) {
                    this.noBatch = true;
                    this.mesh.glMesh = new gd3d.render.glMesh();
                    this.dataForVbo = this.meshlist[0].baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                    this.dataForEbo = this.meshlist[0].baseddata.mesh.data.genIndexDataArray();
                    this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, this.meshlist[0].baseddata.mesh.data.pos.length, gd3d.render.MeshTypeEnum.Static);
                    this.mesh.glMesh.uploadVertexData(this.effect.webgl, this.dataForVbo);
                    this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                    this.mesh.glMesh.uploadIndexData(this.effect.webgl, 0, this.dataForEbo);
                    this.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.useVertexIndex = 0;
                        sm.start = 0;
                        sm.size = this.dataForEbo.length;
                        sm.line = false;
                        this.mesh.submesh.push(sm);
                    }
                    return;
                }
                var totalVertexCount = 0;
                var toltalIndexCount = 0;
                for (var i = 0, len = this.meshlist.length; i < len; i++) {
                    totalVertexCount += this.meshlist[i].baseddata.mesh.data.pos.length;
                    toltalIndexCount += this.meshlist[i].baseddata.mesh.data.trisindex.length;
                }
                this.dataForVbo = new Float32Array(totalVertexCount * this.vertexLength);
                this.dataForEbo = new Uint16Array(toltalIndexCount);
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertexCount, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            };
            F14SingleMeshBath.prototype.reInit = function (mat, effect) {
                this.effect = effect;
                this.ElementMat = mat;
                this.meshlist.length = 0;
            };
            F14SingleMeshBath.prototype.addElement = function (mesh, insert) {
                if (insert === void 0) { insert = false; }
                this.meshlist.push(mesh);
                mesh.layer.batch = this;
            };
            F14SingleMeshBath.prototype.canBatch = function (mesh) {
                if (this.ElementMat != mesh.baseddata.material) {
                    return false;
                }
                if (this.ElementMat.getShader().getName().indexOf("mask") > 0) {
                    return false;
                }
                return true;
            };
            F14SingleMeshBath.prototype.getElementCount = function () {
                return this.meshlist.length;
            };
            F14SingleMeshBath.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (this.meshlist.length == 0)
                    return;
                this.activemeshlist.length = 0;
                for (var i = 0, len = this.meshlist.length; i < len; i++) {
                    if (this.meshlist[i].drawActive) {
                        this.activemeshlist.push(this.meshlist[i]);
                    }
                }
                if (this.activemeshlist.length < 1)
                    return;
                this.ElementMat.setQueue(Effqueue);
                if (this.noBatch) {
                    gd3d.math.matrixMultiply(this.effect.mvpMat, this.activemeshlist[0].targetMat, context.matrixModelViewProject);
                    var singlemesh = this.activemeshlist[0].baseddata.mesh;
                    if (singlemesh.updateByEffect == false) {
                        var newglmesh = new gd3d.render.glMesh();
                        newglmesh.initBuffer(this.effect.webgl, this.effect.VF, singlemesh.data.pos.length, gd3d.render.MeshTypeEnum.Static);
                        newglmesh.uploadVertexData(this.effect.webgl, this.activemeshlist[0].dataforvbo);
                        newglmesh.ebos = singlemesh.glMesh.ebos;
                        newglmesh.indexCounts = singlemesh.glMesh.indexCounts;
                        singlemesh.glMesh = newglmesh;
                        singlemesh.submesh[0].size = this.activemeshlist[0].dataforebo.length;
                        singlemesh.updateByEffect = true;
                    }
                    this.temptColorv4.x = this.activemeshlist[0].color.r;
                    this.temptColorv4.y = this.activemeshlist[0].color.g;
                    this.temptColorv4.z = this.activemeshlist[0].color.b;
                    this.temptColorv4.w = this.activemeshlist[0].color.a * (this.activemeshlist[0].settedAlpha || 1.0);
                    this.ElementMat.setVector4("_Main_Color", this.temptColorv4);
                    this.ElementMat.setVector4("_Main_Tex_ST", this.activemeshlist[0].tex_ST);
                    singlemesh.glMesh.bindVboBuffer(context.webgl);
                    this.ElementMat.draw(context, singlemesh, singlemesh.submesh[0]);
                }
                else {
                    gd3d.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                    this.curIndexCount = 0;
                    this.curVertexcount = 0;
                    this.curRealVboCount = 0;
                    for (var i = 0, len = this.activemeshlist.length; i < len; i++) {
                        this.activemeshlist[i].uploadMeshdata();
                    }
                    this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                    this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                    this.mesh.submesh[0].size = this.curIndexCount;
                    this.ElementMat.setVector4("_Main_Color", new gd3d.math.vector4(1, 1, 1, 1));
                    this.ElementMat.setVector4("_Main_Tex_ST", new gd3d.math.vector4(1, 1, 0, 0));
                    this.ElementMat.draw(context, this.mesh, this.mesh.submesh[0]);
                }
            };
            F14SingleMeshBath.prototype.unRender = function () {
            };
            F14SingleMeshBath.prototype.dispose = function () {
                this.effect = null;
                this.ElementMat = null;
                delete this.meshlist;
                delete this.activemeshlist;
                this.mesh.dispose();
                delete this.mesh;
                delete this.indices;
                delete this.vertices;
                delete this.colors;
                delete this.uv;
                delete this.dataForEbo;
                delete this.dataForVbo;
            };
            return F14SingleMeshBath;
        }());
        framework.F14SingleMeshBath = F14SingleMeshBath;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LoopEnum;
        (function (LoopEnum) {
            LoopEnum[LoopEnum["Restart"] = 0] = "Restart";
            LoopEnum[LoopEnum["TimeContinue"] = 1] = "TimeContinue";
        })(LoopEnum = framework.LoopEnum || (framework.LoopEnum = {}));
        var BindAxis;
        (function (BindAxis) {
            BindAxis[BindAxis["X"] = 0] = "X";
            BindAxis[BindAxis["Y"] = 1] = "Y";
            BindAxis[BindAxis["NONE"] = 2] = "NONE";
        })(BindAxis = framework.BindAxis || (framework.BindAxis = {}));
        var F14SingleMeshBaseData = (function () {
            function F14SingleMeshBaseData(firstFrame) {
                this.loopenum = LoopEnum.Restart;
                this.position = new gd3d.math.vector3();
                this.scale = new gd3d.math.vector3(1, 1, 1);
                this.euler = new gd3d.math.vector3();
                this.color = new gd3d.math.color(1, 1, 1, 1);
                this.tex_ST = new gd3d.math.vector4();
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                this.beBillboard = false;
                this.bindAxis = BindAxis.NONE;
                this.firtstFrame = 0;
                this.firtstFrame = firstFrame;
                this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                this.material = gd3d.framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
            }
            F14SingleMeshBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = assetmgr.getAssetByName(json.mesh, assetbundle);
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                gd3d.math.vec3FormJson(json.position, this.position);
                gd3d.math.vec3FormJson(json.scale, this.scale);
                gd3d.math.vec3FormJson(json.euler, this.euler);
                gd3d.math.colorFormJson(json.color, this.color);
                gd3d.math.vec4FormJson(json.tex_ST, this.tex_ST);
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
                if (json.beBillboard != null) {
                    this.beBillboard = json.beBillboard;
                    switch (json.bindAxis) {
                        case "NONE":
                            this.bindAxis = BindAxis.NONE;
                            break;
                        case "X":
                            this.bindAxis = BindAxis.X;
                            break;
                        case "Y":
                            this.bindAxis = BindAxis.Y;
                            break;
                    }
                }
            };
            return F14SingleMeshBaseData;
        }());
        framework.F14SingleMeshBaseData = F14SingleMeshBaseData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var starCamCtr = (function () {
            function starCamCtr() {
                this.moveDuration = 1;
                this.minSpeed = 5;
                this.relativelocation = new gd3d.math.vector3(0, 6, 0);
                this.relativeEuler = new gd3d.math.vector3(90, 0, 0);
                this.relativeRot = new gd3d.math.quaternion();
                this.starteCamRot = new gd3d.math.quaternion();
                this.targetCamPos = new gd3d.math.vector3();
                this.targetCamRot = new gd3d.math.quaternion();
                this.movedir = new gd3d.math.vector3();
                this.active = false;
                this.moveDis = new gd3d.math.vector3();
            }
            starCamCtr.prototype.start = function () {
            };
            starCamCtr.prototype.onPlay = function () {
            };
            starCamCtr.prototype.update = function (delta) {
                if (!this.active)
                    return;
                var pos = this.gameObject.transform.localTranslate;
                var rot = this.gameObject.transform.localRotate;
                var distanc = gd3d.math.vec3Distance(pos, this.targetCamPos);
                var movedis = this.moveSpeed * delta;
                if (distanc > movedis) {
                    gd3d.math.vec3ScaleByNum(this.movedir, movedis, this.moveDis);
                    gd3d.math.vec3Add(pos, this.moveDis, this.gameObject.transform.localTranslate);
                    gd3d.math.quatLerp(this.starteCamRot, this.targetCamRot, this.gameObject.transform.localRotate, (this.distance - distanc) / this.distance);
                    this.gameObject.transform.markDirty();
                    this.gameObject.transform.updateWorldTran();
                }
                else {
                    this.active = false;
                }
            };
            starCamCtr.prototype.remove = function () {
            };
            starCamCtr.prototype.clone = function () {
            };
            starCamCtr.prototype.moveTo = function (to) {
                gd3d.math.quatClone(this.gameObject.transform.localRotate, this.starteCamRot);
                gd3d.math.quatFromEulerAngles(this.relativeEuler.x, this.relativeEuler.y, this.relativeEuler.z, this.relativeRot);
                gd3d.math.quatTransformVector(to.localRotate, this.relativelocation, this.targetCamPos);
                gd3d.math.vec3Add(to.localTranslate, this.targetCamPos, this.targetCamPos);
                gd3d.math.quatMultiply(to.localRotate, this.relativeRot, this.targetCamRot);
                var distanc = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(this.targetCamPos, this.gameObject.transform.localTranslate, distanc);
                gd3d.math.vec3Normalize(distanc, this.movedir);
                this.distance = gd3d.math.vec3Length(distanc);
                this.moveSpeed = this.distance / this.moveDuration;
                gd3d.math.pool.delete_vector3(distanc);
                this.active = true;
            };
            starCamCtr.ClassName = "starCamCtr";
            starCamCtr = __decorate([
                gd3d.reflect.nodeComponent
            ], starCamCtr);
            return starCamCtr;
        }());
        framework.starCamCtr = starCamCtr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var AEvent = (function () {
        function AEvent() {
            this.events = {};
        }
        AEvent.prototype.On = function (event, func, thisArg) {
            var arr = this.events[event];
            var FT;
            if (!arr) {
                arr = this.events[event] = [];
            }
            else {
                for (var _i = 0, arr_3 = arr; _i < arr_3.length; _i++) {
                    var ft = arr_3[_i];
                    if (ft.func == func) {
                        FT = ft;
                        break;
                    }
                }
            }
            if (!FT)
                arr.push({ func: func, thisArgs: [thisArg] });
            else {
                var idx = FT.thisArgs.lastIndexOf(thisArg);
                if (idx == -1)
                    FT.thisArgs.push(thisArg);
            }
        };
        AEvent.prototype.Emit = function (event) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var arr = this.events[event];
            if (!arr)
                return;
            for (var _a = 0, arr_4 = arr; _a < arr_4.length; _a++) {
                var FT = arr_4[_a];
                for (var _b = 0, _c = FT.thisArgs; _b < _c.length; _b++) {
                    var thisArg = _c[_b];
                    FT.func.apply(thisArg, args);
                }
            }
        };
        AEvent.prototype.RemoveListener = function (event, func, thisArg) {
            var arr = this.events[event];
            if (!arr)
                return;
            for (var i = 0, len = arr.length; i < len; ++i) {
                if (func == arr[i].func) {
                    var idx = arr[i].thisArgs.lastIndexOf(thisArg);
                    if (idx != -1) {
                        arr[i].thisArgs.splice(idx, 1);
                        if (arr[i].thisArgs.length < 1)
                            arr.splice(i, 1);
                        if (arr.length < 1)
                            delete this.events[event];
                        break;
                    }
                }
            }
        };
        AEvent.prototype.RemoveListenerAll = function () {
            this.events = {};
        };
        AEvent.prototype.listenerCount = function (event) {
            return this.events[event] ? this.events[event].length : 0;
        };
        return AEvent;
    }());
    gd3d.AEvent = AEvent;
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var event;
    (function (event) {
        var UIEventEnum;
        (function (UIEventEnum) {
            UIEventEnum[UIEventEnum["PointerDown"] = 0] = "PointerDown";
            UIEventEnum[UIEventEnum["PointerUp"] = 1] = "PointerUp";
            UIEventEnum[UIEventEnum["PointerClick"] = 2] = "PointerClick";
            UIEventEnum[UIEventEnum["PointerDoubleClick"] = 3] = "PointerDoubleClick";
            UIEventEnum[UIEventEnum["PointerEnter"] = 4] = "PointerEnter";
            UIEventEnum[UIEventEnum["PointerExit"] = 5] = "PointerExit";
        })(UIEventEnum = event.UIEventEnum || (event.UIEventEnum = {}));
        var PointEventEnum;
        (function (PointEventEnum) {
            PointEventEnum[PointEventEnum["PointDown"] = 0] = "PointDown";
            PointEventEnum[PointEventEnum["PointHold"] = 1] = "PointHold";
            PointEventEnum[PointEventEnum["PointUp"] = 2] = "PointUp";
            PointEventEnum[PointEventEnum["PointMove"] = 3] = "PointMove";
            PointEventEnum[PointEventEnum["PointClick"] = 4] = "PointClick";
            PointEventEnum[PointEventEnum["MouseWheel"] = 5] = "MouseWheel";
        })(PointEventEnum = event.PointEventEnum || (event.PointEventEnum = {}));
        var KeyEventEnum;
        (function (KeyEventEnum) {
            KeyEventEnum[KeyEventEnum["KeyDown"] = 0] = "KeyDown";
            KeyEventEnum[KeyEventEnum["KeyUp"] = 1] = "KeyUp";
        })(KeyEventEnum = event.KeyEventEnum || (event.KeyEventEnum = {}));
        var KeyCode;
        (function (KeyCode) {
            KeyCode[KeyCode["Numpad4"] = 100] = "Numpad4";
            KeyCode[KeyCode["Numpad5"] = 101] = "Numpad5";
            KeyCode[KeyCode["Numpad6"] = 102] = "Numpad6";
            KeyCode[KeyCode["Numpad7"] = 103] = "Numpad7";
            KeyCode[KeyCode["Numpad8"] = 104] = "Numpad8";
            KeyCode[KeyCode["Numpad9"] = 105] = "Numpad9";
            KeyCode[KeyCode["NumpadMultiply"] = 106] = "NumpadMultiply";
            KeyCode[KeyCode["NumpadAdd"] = 107] = "NumpadAdd";
            KeyCode[KeyCode["NumpadSubtract"] = 109] = "NumpadSubtract";
            KeyCode[KeyCode["NumpadDecimal"] = 110] = "NumpadDecimal";
            KeyCode[KeyCode["NumpadDivide"] = 111] = "NumpadDivide";
            KeyCode[KeyCode["F1"] = 112] = "F1";
            KeyCode[KeyCode["F2"] = 113] = "F2";
            KeyCode[KeyCode["F3"] = 114] = "F3";
            KeyCode[KeyCode["F4"] = 115] = "F4";
            KeyCode[KeyCode["F5"] = 116] = "F5";
            KeyCode[KeyCode["F6"] = 117] = "F6";
            KeyCode[KeyCode["F7"] = 118] = "F7";
            KeyCode[KeyCode["F8"] = 119] = "F8";
            KeyCode[KeyCode["F9"] = 120] = "F9";
            KeyCode[KeyCode["F10"] = 121] = "F10";
            KeyCode[KeyCode["F11"] = 122] = "F11";
            KeyCode[KeyCode["F12"] = 123] = "F12";
            KeyCode[KeyCode["Enter"] = 13] = "Enter";
            KeyCode[KeyCode["NumLock"] = 144] = "NumLock";
            KeyCode[KeyCode["ScrollLock"] = 145] = "ScrollLock";
            KeyCode[KeyCode["ShiftLeft"] = 16] = "ShiftLeft";
            KeyCode[KeyCode["ControlRight"] = 17] = "ControlRight";
            KeyCode[KeyCode["AltRight"] = 18] = "AltRight";
            KeyCode[KeyCode["Semicolon"] = 186] = "Semicolon";
            KeyCode[KeyCode["Comma"] = 188] = "Comma";
            KeyCode[KeyCode["Pause"] = 19] = "Pause";
            KeyCode[KeyCode["Period"] = 190] = "Period";
            KeyCode[KeyCode["Slash"] = 191] = "Slash";
            KeyCode[KeyCode["CapsLock"] = 20] = "CapsLock";
            KeyCode[KeyCode["BracketLeft"] = 219] = "BracketLeft";
            KeyCode[KeyCode["Backslash"] = 220] = "Backslash";
            KeyCode[KeyCode["BracketRight"] = 221] = "BracketRight";
            KeyCode[KeyCode["Quote"] = 222] = "Quote";
            KeyCode[KeyCode["Escape"] = 27] = "Escape";
            KeyCode[KeyCode["Space"] = 32] = "Space";
            KeyCode[KeyCode["PageUp"] = 33] = "PageUp";
            KeyCode[KeyCode["PageDown"] = 34] = "PageDown";
            KeyCode[KeyCode["End"] = 35] = "End";
            KeyCode[KeyCode["Home"] = 36] = "Home";
            KeyCode[KeyCode["ArrowLeft"] = 37] = "ArrowLeft";
            KeyCode[KeyCode["ArrowUp"] = 38] = "ArrowUp";
            KeyCode[KeyCode["ArrowRight"] = 39] = "ArrowRight";
            KeyCode[KeyCode["ArrowDown"] = 40] = "ArrowDown";
            KeyCode[KeyCode["Insert"] = 45] = "Insert";
            KeyCode[KeyCode["Delete"] = 46] = "Delete";
            KeyCode[KeyCode["Digit1"] = 49] = "Digit1";
            KeyCode[KeyCode["Digit2"] = 50] = "Digit2";
            KeyCode[KeyCode["Digit3"] = 51] = "Digit3";
            KeyCode[KeyCode["Digit4"] = 52] = "Digit4";
            KeyCode[KeyCode["KeyA"] = 65] = "KeyA";
            KeyCode[KeyCode["KeyB"] = 66] = "KeyB";
            KeyCode[KeyCode["KeyC"] = 67] = "KeyC";
            KeyCode[KeyCode["KeyD"] = 68] = "KeyD";
            KeyCode[KeyCode["KeyE"] = 69] = "KeyE";
            KeyCode[KeyCode["KeyF"] = 70] = "KeyF";
            KeyCode[KeyCode["KeyG"] = 71] = "KeyG";
            KeyCode[KeyCode["KeyH"] = 72] = "KeyH";
            KeyCode[KeyCode["KeyI"] = 73] = "KeyI";
            KeyCode[KeyCode["KeyJ"] = 74] = "KeyJ";
            KeyCode[KeyCode["KeyK"] = 75] = "KeyK";
            KeyCode[KeyCode["KeyL"] = 76] = "KeyL";
            KeyCode[KeyCode["KeyM"] = 77] = "KeyM";
            KeyCode[KeyCode["KeyN"] = 78] = "KeyN";
            KeyCode[KeyCode["KeyO"] = 79] = "KeyO";
            KeyCode[KeyCode["KeyP"] = 80] = "KeyP";
            KeyCode[KeyCode["KeyQ"] = 81] = "KeyQ";
            KeyCode[KeyCode["KeyR"] = 82] = "KeyR";
            KeyCode[KeyCode["KeyS"] = 83] = "KeyS";
            KeyCode[KeyCode["KeyT"] = 84] = "KeyT";
            KeyCode[KeyCode["KeyU"] = 85] = "KeyU";
            KeyCode[KeyCode["KeyV"] = 86] = "KeyV";
            KeyCode[KeyCode["KeyW"] = 87] = "KeyW";
            KeyCode[KeyCode["KeyX"] = 88] = "KeyX";
            KeyCode[KeyCode["KeyY"] = 89] = "KeyY";
            KeyCode[KeyCode["Tab"] = 9] = "Tab";
            KeyCode[KeyCode["KeyZ"] = 90] = "KeyZ";
            KeyCode[KeyCode["MetaLeft"] = 91] = "MetaLeft";
            KeyCode[KeyCode["ContextMenu"] = 93] = "ContextMenu";
            KeyCode[KeyCode["Numpad0"] = 96] = "Numpad0";
            KeyCode[KeyCode["Numpad1"] = 97] = "Numpad1";
            KeyCode[KeyCode["Numpad2"] = 98] = "Numpad2";
            KeyCode[KeyCode["Numpad3"] = 99] = "Numpad3";
        })(KeyCode = event.KeyCode || (event.KeyCode = {}));
    })(event = gd3d.event || (gd3d.event = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var event;
    (function (event_1) {
        var InputEvent = (function (_super) {
            __extends(InputEvent, _super);
            function InputEvent() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            InputEvent.prototype.OnEnum_key = function (event, func, thisArg) {
                this.On(event_1.KeyEventEnum[event], func, thisArg);
            };
            InputEvent.prototype.EmitEnum_key = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                _super.prototype.Emit.call(this, event_1.KeyEventEnum[event], args);
            };
            InputEvent.prototype.OnEnum_point = function (event, func, thisArg) {
                this.On(event_1.PointEventEnum[event], func, thisArg);
            };
            InputEvent.prototype.EmitEnum_point = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                _super.prototype.Emit.call(this, event_1.PointEventEnum[event], args);
            };
            return InputEvent;
        }(gd3d.AEvent));
        event_1.InputEvent = InputEvent;
    })(event = gd3d.event || (gd3d.event = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var event;
    (function (event_2) {
        var UIEvent = (function (_super) {
            __extends(UIEvent, _super);
            function UIEvent() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            UIEvent.prototype.OnEnum = function (event, func, thisArg) {
                this.On(event_2.UIEventEnum[event], func, thisArg);
            };
            UIEvent.prototype.EmitEnum = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                _super.prototype.Emit.call(this, event_2.UIEventEnum[event], args);
            };
            return UIEvent;
        }(gd3d.AEvent));
        event_2.UIEvent = UIEvent;
    })(event = gd3d.event || (gd3d.event = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PointEvent = (function () {
            function PointEvent() {
            }
            return PointEvent;
        }());
        framework.PointEvent = PointEvent;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pointinfo = (function () {
            function pointinfo() {
                this.touch = false;
            }
            return pointinfo;
        }());
        framework.pointinfo = pointinfo;
        var inputMgr = (function () {
            function inputMgr(app) {
                this._element = null;
                this._buttons = [false, false, false];
                this._lastbuttons = [false, false, false];
                this.eventer = new gd3d.event.InputEvent();
                this.inputlast = null;
                this.keyboardMap = {};
                this.handlers = [];
                this._wheel = 0;
                this._point = new pointinfo();
                this._touches = {};
                this.rMtr_90 = new gd3d.math.matrix3x2();
                this.rMtr_n90 = new gd3d.math.matrix3x2();
                this.moveTolerance = 2;
                this.lastTouch = false;
                this.hasPointDown = false;
                this.hasPointUP = false;
                this.hasPointMove = false;
                this.downPoint = new gd3d.math.vector2();
                this.lastPoint = new gd3d.math.vector2();
                this.keyDownCode = -1;
                this.keyUpCode = -1;
                this.hasWheel = false;
                this.lastWheel = 0;
                this._contextMenu = function (ev) { ev.preventDefault(); };
                this.tempV2_0 = new gd3d.math.vector2();
                this.tempV2_1 = new gd3d.math.vector2();
                this.devicePixelRatio = window.devicePixelRatio || 1;
                this.app = app;
                gd3d.math.matrix3x2MakeRotate(Math.PI * 90 / 180, this.rMtr_90);
                gd3d.math.matrix3x2MakeRotate(Math.PI * -90 / 180, this.rMtr_n90);
                this.handlers.push(["touchstart", this._touchstart.bind(this)]);
                this.handlers.push(["touchmove", this._touchmove.bind(this)]);
                this.handlers.push(["touchend", this._touchend.bind(this)]);
                this.handlers.push(["touchcancel", this._touchcancel.bind(this)]);
                this.handlers.push(["mousedown", this._mousedown.bind(this)]);
                this.handlers.push(["mouseup", this._mouseup.bind(this)]);
                this.handlers.push(["mousemove", this._mousemove.bind(this)]);
                this.handlers.push(["mousewheel", this._mousewheel.bind(this)]);
                this.handlers.push(["DOMMouseScroll", this._mousewheel.bind(this)]);
                this.handlers.push(["keydown", this._keydown.bind(this)]);
                this.handlers.push(["keyup", this._keyup.bind(this)]);
                this.handlers.push(["blur", this._blur.bind(this)]);
                this.attach(app.webgl.canvas);
                this.disableContextMenu();
            }
            Object.defineProperty(inputMgr.prototype, "wheel", {
                get: function () { return this._wheel; },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(inputMgr.prototype, "point", {
                get: function () { return this._point; },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(inputMgr.prototype, "touches", {
                get: function () { return this._touches; },
                enumerable: true,
                configurable: true
            });
            ;
            inputMgr.prototype.attach = function (element) {
                var _this = this;
                if (this._element) {
                    this.detach();
                }
                this._element = element;
                this.handlers.forEach(function (handler) {
                    if (handler)
                        _this._element.addEventListener(handler[0], handler[1], false);
                });
            };
            inputMgr.prototype.detach = function () {
                var _this = this;
                if (!this._element)
                    return;
                this.handlers.forEach(function (handler) {
                    if (handler)
                        _this._element.removeEventListener(handler[0], handler[1], false);
                });
                this._element = null;
            };
            inputMgr.prototype._mousedown = function (ev) {
                this.CalcuPoint(ev.offsetX, ev.offsetY, this._point);
                this._buttons[ev.button] = true;
                this._point.touch = true;
            };
            inputMgr.prototype._mouseup = function (ev) {
                this._buttons[ev.button] = false;
                this._point.touch = false;
            };
            inputMgr.prototype._mousemove = function (ev) {
                this.CalcuPoint(ev.offsetX, ev.offsetY, this._point);
            };
            inputMgr.prototype._mousewheel = function (ev) {
                this.hasWheel = true;
                if (ev.detail) {
                    this.lastWheel = -1 * ev.detail;
                }
                else if (ev["wheelDelta"]) {
                    this.lastWheel = ev["wheelDelta"] / 120;
                }
                else if (ev.DOM_DELTA_PIXEL) {
                    this.lastWheel = ev.DOM_DELTA_PIXEL / 120;
                }
                else {
                    this.lastWheel = 0;
                }
            };
            inputMgr.prototype.tryAddTouchP = function (id) {
                if (!this._touches[id]) {
                    this._touches[id] = new pointinfo();
                    this._touches[id].id = id;
                }
            };
            inputMgr.prototype.syncPointByTouches = function () {
                var count = 0;
                var xs = 0;
                var ys = 0;
                for (var key in this._touches) {
                    if (this._touches[key].touch == true) {
                        xs += this._touches[key].x;
                        ys += this._touches[key].y;
                        count++;
                    }
                }
                this._point.x = xs / count;
                this._point.y = ys / count;
            };
            inputMgr.prototype._touchstart = function (ev) {
                this._point.touch = true;
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var touch = ev.changedTouches[i];
                    var id = touch.identifier;
                    this.tryAddTouchP(id);
                    this._touches[id].touch = true;
                    this.CalcuPoint(touch.clientX, touch.clientY, this._touches[id]);
                }
                this.syncPointByTouches();
            };
            inputMgr.prototype._touchmove = function (ev) {
                this._point.touch = true;
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var touch = ev.changedTouches[i];
                    var id = touch.identifier;
                    this.tryAddTouchP(id);
                    this._touches[id].touch = true;
                    this.CalcuPoint(touch.clientX, touch.clientY, this._touches[id]);
                }
                this.syncPointByTouches();
            };
            inputMgr.prototype._touchend = function (ev) {
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var touch = ev.changedTouches[i];
                    var id = touch.identifier;
                    this.tryAddTouchP(id);
                    this._touches[id].touch = false;
                }
                for (var key in this._touches) {
                    if (this._touches[key].touch == true)
                        return;
                }
                this._point.touch = false;
            };
            inputMgr.prototype._touchcancel = function (ev) {
                this._touchend(ev);
            };
            inputMgr.prototype._keydown = function (ev) {
                this.keyboardMap[ev.keyCode] = true;
                this.keyDownCode = ev.keyCode;
            };
            inputMgr.prototype._keyup = function (ev) {
                delete this.keyboardMap[ev.keyCode];
                this.keyUpCode = ev.keyCode;
            };
            inputMgr.prototype._blur = function (ev) {
                this._point.touch = false;
            };
            inputMgr.prototype.update = function (delta) {
                this._lastbuttons[0] = this._buttons[0];
                this._lastbuttons[1] = this._buttons[1];
                this._lastbuttons[2] = this._buttons[2];
                this._wheel = 0;
                this.mouseWheelCk();
                this.pointCk();
                this.keyCodeCk();
            };
            inputMgr.prototype.pointCk = function () {
                var pt = this._point;
                if (this.lastPoint.x != pt.x || this.lastPoint.y != pt.y) {
                    this.eventer.EmitEnum_point(gd3d.event.PointEventEnum.PointMove, pt.x, pt.y);
                }
                if (!this.lastTouch && pt.touch) {
                    this.hasPointDown = true;
                    this.downPoint.x = pt.x;
                    this.downPoint.y = pt.y;
                    this.eventer.EmitEnum_point(gd3d.event.PointEventEnum.PointDown, pt.x, pt.y);
                }
                else if (this.lastTouch && !pt.touch) {
                    this.hasPointUP = true;
                    this.eventer.EmitEnum_point(gd3d.event.PointEventEnum.PointUp, pt.x, pt.y);
                }
                else if (this.lastTouch && pt.touch) {
                    this.eventer.EmitEnum_point(gd3d.event.PointEventEnum.PointHold, pt.x, pt.y);
                }
                if (this.hasPointUP && this.hasPointDown) {
                    var isMoveTolerance = (Math.abs(this.downPoint.x - pt.x) > this.moveTolerance || Math.abs(this.downPoint.y - pt.y) > this.moveTolerance);
                    if (!isMoveTolerance) {
                        this.hasPointDown = this.hasPointUP = false;
                        this.eventer.EmitEnum_point(gd3d.event.PointEventEnum.PointClick, pt.x, pt.y);
                    }
                }
                if (!pt.touch) {
                    this.hasPointDown = false;
                }
                this.lastTouch = pt.touch;
                this.lastPoint.x = pt.x;
                this.lastPoint.y = pt.y;
            };
            inputMgr.prototype.keyCodeCk = function () {
                if (this.keyDownCode != -1)
                    this.eventer.EmitEnum_key(gd3d.event.KeyEventEnum.KeyDown, this.keyDownCode);
                if (this.keyUpCode != -1)
                    this.eventer.EmitEnum_key(gd3d.event.KeyEventEnum.KeyUp, this.keyUpCode);
                this.keyDownCode = this.keyUpCode = -1;
            };
            inputMgr.prototype.mouseWheelCk = function () {
                if (this.hasWheel) {
                    this._wheel = this.lastWheel;
                    this.eventer.EmitEnum_point(gd3d.event.PointEventEnum.MouseWheel, null);
                }
                this.hasWheel = false;
                this.lastWheel = 0;
            };
            inputMgr.prototype.isPressed = function (button) {
                return this._buttons[button];
            };
            inputMgr.prototype.wasPressed = function (button) {
                return (this._buttons[button] && !this._lastbuttons[button]);
            };
            inputMgr.prototype.disableContextMenu = function () {
                if (!this._element)
                    return;
                this._element.addEventListener("contextmenu", this._contextMenu);
            };
            inputMgr.prototype.enableContextMenu = function () {
                if (!this._element)
                    return;
                this._element.removeEventListener("contextmenu", this._contextMenu);
            };
            inputMgr.prototype.addPointListener = function (eventEnum, func, thisArg) {
                this.eventer.OnEnum_point(eventEnum, func, thisArg);
            };
            inputMgr.prototype.removePointListener = function (eventEnum, func, thisArg) {
                this.eventer.RemoveListener(gd3d.event.PointEventEnum[eventEnum], func, thisArg);
            };
            inputMgr.prototype.addKeyListener = function (eventEnum, func, thisArg) {
                this.eventer.OnEnum_key(eventEnum, func, thisArg);
            };
            inputMgr.prototype.removeKeyListener = function (eventEnum, func, thisArg) {
                this.eventer.RemoveListener(gd3d.event.KeyEventEnum[eventEnum], func, thisArg);
            };
            inputMgr.prototype.anyKey = function () {
                if (this._point.touch)
                    return true;
                for (var key in this.keyboardMap) {
                    if (this.keyboardMap.hasOwnProperty(key)) {
                        var element = this.keyboardMap[key];
                        if (element == true)
                            return true;
                    }
                }
                return false;
            };
            inputMgr.prototype.GetKeyDown = function (value) {
                if (typeof (value) === "number") {
                    if (this.keyboardMap[value] != null)
                        return this.keyboardMap[value];
                }
                else if (typeof (value) === "string") {
                    var id = gd3d.event.KeyCode[value];
                    if (id != null && this.keyboardMap[id] != null)
                        return this.keyboardMap[id];
                }
                return false;
            };
            inputMgr.prototype.GetKeyUP = function (value) {
                if (typeof (value) === "number") {
                    return !this.keyboardMap[value];
                }
                else if (typeof (value) === "string") {
                    var id = gd3d.event.KeyCode[value];
                    if (id != null)
                        return !this.keyboardMap[id];
                }
                return false;
            };
            inputMgr.prototype.KeyDownCount = function () {
                var count = 0;
                for (var key in this.keyboardMap) {
                    if (this.keyboardMap.hasOwnProperty(key)) {
                        if (this.keyboardMap[key] === true)
                            count++;
                    }
                }
                return count;
            };
            inputMgr.prototype.CalcuPoint = function (clientX, clientY, out) {
                if (!out || !this.app || isNaN(clientX) || isNaN(clientY))
                    return;
                this.tempV2_0.x = clientX * this.devicePixelRatio / this.app.scaleFromPandding;
                this.tempV2_0.y = clientY * this.devicePixelRatio / this.app.scaleFromPandding;
                gd3d.math.vec2Clone(this.tempV2_0, this.tempV2_1);
                if (this.app.shouldRotate) {
                    switch (this.app.orientation) {
                        case gd3d.framework.OrientationMode.PORTRAIT:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            out.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            out.y = this.tempV2_1.y;
                            break;
                        case gd3d.framework.OrientationMode.LANDSCAPE:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_n90, this.tempV2_0, this.tempV2_1);
                            out.x = this.tempV2_1.x;
                            out.y = this.tempV2_1.y + this.app.webgl.canvas.height;
                            break;
                        case gd3d.framework.OrientationMode.LANDSCAPE_FLIPPED:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            out.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            out.y = this.tempV2_1.y;
                            break;
                    }
                }
                else {
                    out.x = this.tempV2_0.x;
                    out.y = this.tempV2_0.y;
                }
            };
            return inputMgr;
        }());
        framework.inputMgr = inputMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var converter = (function () {
            function converter() {
            }
            converter.getApplyFun = function (value) {
                return Array.prototype.concat.apply([], value);
            };
            converter.ULongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setUint32(0, uint1, true);
                converter.dataView.setUint32(4, uint2, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            };
            converter.LongToArray = function (value, t, offset) {
                if (t === void 0) { t = null; }
                if (offset === void 0) { offset = 0; }
                var target = t;
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setInt32(0, uint1, true);
                converter.dataView.setInt32(4, uint2, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            };
            converter.Float64ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat64(0, value, false);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            };
            converter.Float32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            };
            converter.Int32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            };
            converter.Int16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt16(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 2));
            };
            converter.Uint32toArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            };
            converter.Uint16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setUint16(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 2));
            };
            converter.StringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0, len = str.length; i < len; ++i) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return new Uint8Array(bstr);
            };
            converter.ArrayToLong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                var n1 = converter.dataView.getInt32(0, true);
                converter.dataBuffer.set(buf.subarray(offset + 4, offset + 8));
                var n2 = converter.dataView.getInt32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToULong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                var n1 = converter.dataView.getUint32(0, true);
                converter.dataBuffer.set(buf.subarray(offset + 4, offset + 8));
                var n2 = converter.dataView.getUint32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToFloat64 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 8));
                return converter.dataView.getFloat64(0, true);
            };
            converter.ArrayToFloat32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getFloat32(0, true);
            };
            converter.ArrayToInt32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getInt32(0, true);
            };
            converter.ArrayToUint32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getUint32(0, true);
            };
            converter.ArrayToInt16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 2));
                return converter.dataView.getInt16(0, true);
            };
            converter.ArrayToUint16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 2));
                return converter.dataView.getUint16(0, true);
            };
            converter.ArrayToInt8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                return buf[offset];
            };
            converter.ArrayToString = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                var ret = [];
                for (var i = 0; i < buf.length; i++) {
                    var cc = buf[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = buf[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        console.warn("InvalidCharacterError");
                        return "";
                    }
                    else {
                        ret.push(String.fromCharCode(buf[i]));
                    }
                }
                return ret.join('');
            };
            converter.dataBuffer = new Uint8Array(8);
            converter.dataView = new DataView(converter.dataBuffer.buffer);
            return converter;
        }());
        io.converter = converter;
        var binTool = (function () {
            function binTool(size) {
                if (size === void 0) { size = undefined; }
                this.r_offset = 0;
                this.w_offset = 0;
                this.buffer = memoryPool.Insance.newUint8Array();
            }
            binTool.prototype.ckl = function () {
                if (this.r_offset > this.w_offset)
                    throw Error("[binTool] 内存读取失败 请检查当前输入的内存");
            };
            binTool.prototype.readSingle = function () {
                this.ckl();
                var ret = converter.ArrayToFloat32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readLong = function () {
                this.ckl();
                var ret = converter.ArrayToLong(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            };
            binTool.prototype.readULong = function () {
                this.ckl();
                var ret = converter.ArrayToULong(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            };
            binTool.prototype.readDouble = function () {
                this.ckl();
                var ret = converter.ArrayToFloat64(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            };
            binTool.prototype.readInt8 = function () {
                this.ckl();
                var ret = this.buffer[this.r_offset];
                this.r_offset += 1;
                return ret;
            };
            binTool.prototype.readUInt8 = function () {
                this.ckl();
                var ret = this.buffer[this.r_offset];
                this.r_offset += 1;
                return ret;
            };
            binTool.prototype.readInt16 = function () {
                this.ckl();
                var ret = converter.ArrayToInt16(this.buffer, this.r_offset);
                this.r_offset += 2;
                return ret;
            };
            binTool.prototype.readUInt16 = function () {
                this.ckl();
                var ret = converter.ArrayToUint16(this.buffer, this.r_offset);
                this.r_offset += 2;
                return ret;
            };
            binTool.prototype.readInt32 = function () {
                this.ckl();
                var ret = converter.ArrayToInt32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readUInt32 = function () {
                this.ckl();
                var ret = converter.ArrayToUint32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readBoolean = function () {
                this.ckl();
                var ret = this.buffer[this.r_offset] != 0;
                this.r_offset += 1;
                return ret;
            };
            binTool.prototype.readByte = function () {
                return this.readUInt8();
            };
            binTool.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binTool.prototype.readUnsignedInt = function () {
                this.ckl();
                var ret = converter.ArrayToUint32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readFloat = function () {
                return this.readSingle();
            };
            binTool.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binTool.prototype.readShort = function () {
                return this.readInt16();
            };
            binTool.prototype.readInt = function () {
                return this.readInt32();
            };
            binTool.prototype.readBytes = function (length) {
                this.ckl();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return array;
            };
            binTool.prototype.readStringUtf8 = function () {
                this.ckl();
                var length = this.readInt8();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            };
            binTool.prototype.readUTFBytes = function () {
                this.ckl();
                var length = this.readUInt16();
                return this.readUTFByLen(length);
            };
            binTool.prototype.readUTFByLen = function (length) {
                this.ckl();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringUtf8FixLength = function (length) {
                this.ckl();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringAnsi = function () {
                this.ckl();
                var slen = this.readUInt8();
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this.readByte());
                }
                return bs;
            };
            binTool.prototype.getLength = function () {
                return this.w_offset;
            };
            binTool.prototype.getBytesAvailable = function () {
                return this.w_offset;
            };
            Object.defineProperty(binTool.prototype, "length", {
                get: function () {
                    return this.w_offset;
                },
                enumerable: true,
                configurable: true
            });
            binTool.prototype.writeInt8 = function (num) {
                this.write(num);
            };
            binTool.prototype.writeUInt8 = function (num) {
                this.write(num);
            };
            binTool.prototype.writeInt16 = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeUInt16 = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeInt32 = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            binTool.prototype.writeUInt32 = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeSingle = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeLong = function (num) {
                this.write(converter.LongToArray(num));
            };
            binTool.prototype.writeULong = function (num) {
                this.write(converter.ULongToArray(num));
            };
            binTool.prototype.writeDouble = function (num) {
                this.write(converter.Float64ToArray(num));
            };
            binTool.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.writeUInt8(slen);
                for (var i = 0; i < slen; i++)
                    this.writeUInt8(str.charCodeAt(i));
            };
            binTool.prototype.writeStringUtf8 = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.write(bstr);
            };
            binTool.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.write(bstr);
            };
            binTool.prototype.writeByte = function (num) {
                this.write(num);
            };
            binTool.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUnsignedShort = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeUnsignedInt = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeFloat = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeUTFBytes = function (str) {
                this.write(converter.StringToUtf8Array(str));
            };
            binTool.prototype.writeSymbolByte = function (num) {
                this.write(num);
            };
            binTool.prototype.writeShort = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeInt = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            binTool.prototype.write = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                var arrLenName = "";
                if (array["byteLength"] != undefined) {
                    arrLenName = "byteLength";
                }
                else if (array["length"] != undefined) {
                    arrLenName = "length";
                }
                if (arrLenName != "") {
                    var needSize = array[arrLenName] + this.w_offset;
                    if (this.buffer.byteLength > needSize)
                        this.buffer.set(array, this.w_offset);
                    else {
                        var tnum = this.buffer.byteLength;
                        while (tnum < needSize) {
                            tnum *= 2;
                        }
                        var buf = new Uint8Array(tnum);
                        buf.set(this.buffer);
                        buf.set(array, this.w_offset);
                        this.buffer = buf;
                    }
                    this.w_offset += array.byteLength;
                }
                else {
                    this.buffer[this.w_offset] = array;
                    this.w_offset += 1;
                }
            };
            binTool.prototype.dispose = function () {
                if (this.buffer.byteLength == 1024)
                    memoryPool.Insance.deleteUint8Array(this.buffer);
                this.buffer = null;
            };
            binTool.prototype.getBuffer = function () {
                return new Uint8Array(this.buffer.subarray(0, this.w_offset));
            };
            binTool.prototype.getUint8Array = function () {
                return new Uint8Array(this.buffer.subarray(0, this.w_offset));
            };
            return binTool;
        }());
        io.binTool = binTool;
        var memoryPool = (function () {
            function memoryPool() {
                this.pool = new Array();
            }
            Object.defineProperty(memoryPool, "Insance", {
                get: function () {
                    if (!this.instnace)
                        this.instnace = new memoryPool();
                    return memoryPool.instnace;
                },
                enumerable: true,
                configurable: true
            });
            ;
            memoryPool.prototype.newUint8Array = function () {
                if (this.pool.length > 0)
                    return this.pool.shift();
                return new Uint8Array(1024);
            };
            memoryPool.prototype.deleteUint8Array = function (array) {
                this.pool.push(array);
            };
            return memoryPool;
        }());
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            io.referenceInfo.oldmap = {};
            clonedObj = _cloneObj(instanceObj, clonedObj);
            io.referenceInfo.oldmap[instanceObj["insId"].getInsID()] = clonedObj;
            fillCloneReference(instanceObj, clonedObj);
            return clonedObj;
        }
        io.cloneObj = cloneObj;
        function fillCloneReference(instanceObj, clonedObj) {
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io.fillCloneReference = fillCloneReference;
        function fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    fillCloneReferenceType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                fillCloneReferenceType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                    }
                    if (clonedObj["waitDelArray"]) {
                        var children = clonedObj[key];
                        for (var _i = 0, _a = clonedObj["waitDelArray"]; _i < _a.length; _i++) {
                            var index = _a[_i];
                            children.splice(index, 1);
                        }
                        delete clonedObj["waitDelArray"];
                    }
                }
            }
        }
        io.fillCloneReferenceTypeOrArray = fillCloneReferenceTypeOrArray;
        function fillCloneReferenceType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_1 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    var instance = void 0;
                    if ((isArray_1 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_1 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].gameObject.getComponent(type);
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].getComponent(type);
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid];
                        }
                    }
                    if (isreference) {
                        if (isArray_1) {
                            clonedObj.push(instance);
                        }
                        else {
                            clonedObj[key] = instance;
                        }
                    }
                    else {
                        if (clonedObj[key])
                            fillCloneReference(instanceObj[key], clonedObj[key]);
                        else {
                            if (!clonedParent["waitDelArray"])
                                clonedParent["waitDelArray"] = [];
                            clonedParent["waitDelArray"].push(parseInt(key));
                        }
                    }
                }
            }
        }
        io.fillCloneReferenceType = fillCloneReferenceType;
        function _cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            if (clonedObj == undefined) {
                var insid = -1;
                clonedObj = gd3d.reflect.createInstance(instanceObj, null);
                if (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"]) {
                    insid = instanceObj["gameObject"]["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]) {
                    insid = instanceObj["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["typename"] == "transform" || instanceObj["__gdmeta__"]["class"]["typename"] == "transform2D") {
                    insid = instanceObj["insId"].getInsID();
                    io.referenceInfo.oldmap[insid] = clonedObj;
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        clonedObj[key] = instanceObj[key];
                        break;
                    default:
                        cloneOtherTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io._cloneObj = _cloneObj;
        function cloneOtherTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    cloneOtherType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_2 = instanceObj[key] instanceof Array;
                    if (isArray_2)
                        clonedObj[key] = [];
                    else
                        clonedObj[key] = {};
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                cloneOtherType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (field);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (isArray_2) {
                                            clonedObj[key].push(field);
                                        }
                                        else {
                                            clonedObj[key][newkey] = field;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.cloneOtherTypeOrArray = cloneOtherTypeOrArray;
        function cloneOtherType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_3 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    if (instanceObj[key].use) {
                        instanceObj[key].use();
                    }
                    if (isArray_3) {
                        clonedObj.push(instanceObj[key]);
                    }
                    else {
                        clonedObj[key] = instanceObj[key];
                    }
                }
                else {
                    var isreference = false;
                    if ((isArray_3 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_3 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"] || type == "transform" || type == "transform2D") {
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_3) {
                        }
                        else {
                        }
                    }
                    else {
                        var _clonedObj = void 0;
                        if (_meta["class"]["custom"]["selfclone"]) {
                            _clonedObj = instanceObj[key].clone();
                        }
                        else {
                            _clonedObj = _cloneObj(instanceObj[key], clonedObj[key]);
                        }
                        if (_clonedObj != null) {
                            if (isArray_3) {
                                if (type == "nodeComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "gameObject") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else if (type == "C2DComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform2D" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else {
                                    clonedObj.push(_clonedObj);
                                }
                            }
                            else {
                                clonedObj[key] = _clonedObj;
                            }
                        }
                        else if (isArray_3) {
                            clonedObj.push(null);
                        }
                    }
                }
            }
        }
        io.cloneOtherType = cloneOtherType;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function stringToBlob(content) {
            var u8 = new Uint8Array(stringToUtf8Array(content));
            var blob = new Blob([u8]);
            return blob;
        }
        io.stringToBlob = stringToBlob;
        function stringToUtf8Array(str) {
            var bstr = [];
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                var cc = c.charCodeAt(0);
                if (cc > 0xFFFF) {
                    throw new Error("InvalidCharacterError");
                }
                if (cc > 0x80) {
                    if (cc < 0x07FF) {
                        var c1 = (cc >>> 6) | 0xC0;
                        var c2 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2);
                    }
                    else {
                        var c1 = (cc >>> 12) | 0xE0;
                        var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                        var c3 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2, c3);
                    }
                }
                else {
                    bstr.push(cc);
                }
            }
            return bstr;
        }
        io.stringToUtf8Array = stringToUtf8Array;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var SaveAssetType;
        (function (SaveAssetType) {
            SaveAssetType[SaveAssetType["FullUrl"] = 0] = "FullUrl";
            SaveAssetType[SaveAssetType["NameAndContent"] = 1] = "NameAndContent";
            SaveAssetType[SaveAssetType["DefaultAssets"] = 2] = "DefaultAssets";
        })(SaveAssetType = io.SaveAssetType || (io.SaveAssetType = {}));
        var SerializeDependent = (function () {
            function SerializeDependent() {
            }
            SerializeDependent.GetAssetContent = function (asset) {
                var data = {};
                if (asset instanceof gd3d.framework.material) {
                    var t = asset.getName();
                    var names = t.split(".");
                    if (t.lastIndexOf('.mat.json') == -1) {
                        return { "name": names[0] + ".mat.json", "value": asset.save(), "type": SaveAssetType.NameAndContent };
                    }
                    return { "name": t, "value": asset.save(), "type": SaveAssetType.NameAndContent };
                }
            };
            SerializeDependent.GetAssetUrl = function (asset, assetMgr) {
                if (!assetMgr || !asset)
                    return;
                var url = assetMgr.getAssetUrl(asset);
                if (url && !(asset instanceof gd3d.framework.material)) {
                    SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                    if ((asset instanceof gd3d.framework.f14eff)) {
                        var assets = asset.getDependents();
                        var note_1 = {};
                        assets.forEach(function (asset) {
                            if (asset) {
                                var url_1 = assetMgr.getAssetUrl(asset);
                                if (url_1) {
                                    if (!note_1[url_1]) {
                                        SerializeDependent.resourseDatas.push({ "url": url_1, "type": SaveAssetType.FullUrl });
                                        if (asset instanceof gd3d.framework.texture && asset.realName && asset.realName != "") {
                                            asset;
                                            var idx = url_1.lastIndexOf("/");
                                            if (idx != -1) {
                                                var haed = url_1.substring(0, idx + 1);
                                                SerializeDependent.resourseDatas.push({ "url": haed + asset.realName, "type": SaveAssetType.FullUrl });
                                            }
                                        }
                                    }
                                    note_1[url_1] = true;
                                }
                            }
                        });
                    }
                }
                else
                    SerializeDependent.resourseDatas.push(SerializeDependent.GetAssetContent(asset));
                if (asset instanceof gd3d.framework.material) {
                    var ass = asset;
                    for (var newKey in ass.statedMapUniforms) {
                        if (!ass.statedMapUniforms[newKey])
                            continue;
                        if (ass.defaultMapUniform[newKey].type != gd3d.render.UniformTypeEnum.Texture)
                            continue;
                        var _texture = ass.statedMapUniforms[newKey];
                        if (!_texture)
                            continue;
                        url = assetMgr.getAssetUrl(_texture);
                        if (url)
                            SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                        else {
                            if (_texture.defaultAsset == true)
                                continue;
                            var content = SerializeDependent.GetAssetContent(_texture);
                            if (content)
                                SerializeDependent.resourseDatas.push(content);
                            continue;
                        }
                        if (url.indexOf(".imgdesc.json") < 0)
                            continue;
                        if (!_texture.realName)
                            continue;
                        url = url.replace(_texture.getName(), _texture.realName);
                        SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                    }
                }
            };
            SerializeDependent.resourseDatas = [];
            return SerializeDependent;
        }());
        io.SerializeDependent = SerializeDependent;
        function SerializeForInspector(obj) {
            var str = JSON.stringify(serializeObjForInspector(obj, false));
            return str;
        }
        io.SerializeForInspector = SerializeForInspector;
        function serializeObjForInspector(instanceObj, beComponent, serializedObj) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform" && instanceObj["gameObject"]) {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.HideInInspector)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = {};
            }
            for (var key in instanceObj["__gdmeta__"]) {
                if (key == "children")
                    continue;
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new inspectorValueInfo(instanceObj[key], valueType);
                        if (t["custom"]["FieldUIStyle"])
                            info.UIStyle = t["custom"]["FieldUIStyle"];
                        if (t["custom"]["defvalue"])
                            info.defvalue = t["custom"]["defvalue"];
                        if (t["custom"]["min"])
                            info.min = t["custom"]["min"];
                        if (t["custom"]["max"])
                            info.max = t["custom"]["max"];
                        serializedObj[key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObjForInspector = serializeObjForInspector;
        function serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent) {
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_4 = instanceObj[key] instanceof Array;
                    if (isArray_4)
                        serializedObj[key] = new inspectorValueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new inspectorValueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                            continue;
                        }
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherTypeForInspector(instanceObj[key], serializedObj[key]["value"], newkey, beComponent, instanceObj);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (boolInNull(serializedObj[key]["value"])) {
                                            continue;
                                        }
                                        var info_1 = new inspectorValueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray_4) {
                                            serializedObj[key]["value"].push(info_1);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info_1;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var isArray_5 = instanceObj instanceof Array;
                if (instanceObj["__gdmeta__"]) {
                    if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"]) {
                        var custom = instanceObj["__gdmeta__"][key]["custom"];
                        if (custom["valueType"]) {
                            var info = new inspectorValueInfo(null, custom["valueType"]);
                            if (custom["FieldUIStyle"])
                                info.UIStyle = custom["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom["defvalue"];
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                            if (isArray_5) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArrayForInspector = serializeOtherTypeOrArrayForInspector;
        function serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent, arrayInst) {
            if (arrayInst === void 0) { arrayInst = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_6 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAssetInspector(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        var info = new inspectorValueInfo(_assetName, type);
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_6 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_6 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        beComponent = true;
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (!referenceInfo.isRegType(type)) {
                            return;
                        }
                    }
                    if (isreference) {
                        var info = new inspectorValueInfo(insid, type, "reference");
                        if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                            var custom = instanceObj["__gdmeta__"][key]["custom"];
                            info.UIStyle = instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom;
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                        }
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                    else {
                        if (!referenceInfo.isRegType(type) && beComponent)
                            return;
                        var _serializeObj = serializeObjForInspector(instanceObj[key], beComponent, serializedObj[key]);
                        if (_serializeObj != null) {
                            var info = new inspectorValueInfo(_serializeObj, type);
                            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                                var custom = instanceObj["__gdmeta__"][key]["custom"];
                                info.UIStyle = custom["FieldUIStyle"];
                                if (custom["defvalue"])
                                    info.defvalue = custom;
                                if (custom["min"])
                                    info.min = custom["min"];
                                if (custom["max"])
                                    info.max = custom["max"];
                            }
                            if (isArray_6) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeForInspector = serializeOtherTypeForInspector;
        function Serialize(obj, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            return JSON.stringify(serializeObj(obj, null, assetMgr));
        }
        io.Serialize = Serialize;
        function serializeObj(instanceObj, serializedObj, assetMgr) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = new valueInfo({}, _type);
                if (instanceObj["insId"] != undefined) {
                    serializedObj["insid"] = instanceObj["insId"].getInsID();
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t == null) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new valueInfo(instanceObj[key], valueType);
                        serializedObj["value"][key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArray(instanceObj, serializedObj["value"], key, assetMgr);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObj = serializeObj;
        function serializeOtherTypeOrArray(instanceObj, serializedObj, key, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherType(instanceObj, serializedObj, key, null, assetMgr);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_7 = instanceObj[key] instanceof Array;
                    if (isArray_7)
                        serializedObj[key] = new valueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new valueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] && instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherType(instanceObj[key], serializedObj[key]["value"], newkey, instanceObj, assetMgr);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                                    continue;
                                }
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        var info = new valueInfo(instanceObj[key][newkey], baseType);
                                        if (serializedObj[key]["value"]) {
                                            if (isArray_7) {
                                                serializedObj[key]["value"].push(info);
                                            }
                                            else {
                                                serializedObj[key]["value"][newkey] = info;
                                            }
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArray = serializeOtherTypeOrArray;
        function serializeOtherType(instanceObj, serializedObj, key, arrayInst, assetMgr) {
            if (arrayInst === void 0) { arrayInst = null; }
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj || boolInNull(serializedObj))) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_8 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        else {
                            if (assetMgr) {
                                SerializeDependent.GetAssetUrl(instanceObj[key], assetMgr);
                            }
                        }
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(_assetName, type));
                        }
                        else {
                            serializedObj[key] = new valueInfo(_assetName, type);
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_8 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_8 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            if (instanceObj[key] && instanceObj[key]["gameObject"])
                                insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            if (instanceObj[key] && instanceObj[key]["transform"])
                                insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            if (instanceObj[key])
                                insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(insid, type, "reference"));
                        }
                        else {
                            serializedObj[key] = new valueInfo(insid, type, "reference");
                        }
                    }
                    else {
                        var _serializeObj = serializeObj(instanceObj[key], serializedObj[key], assetMgr);
                        if (_serializeObj != null) {
                            if (isArray_8) {
                                serializedObj.push(_serializeObj);
                            }
                            else {
                                serializedObj[key] = _serializeObj;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherType = serializeOtherType;
        function deSerialize(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            referenceInfo.oldmap = {};
            deSerializeObj(serializedObj["value"], instanceObj, assetMgr, bundlename);
            var insid = serializedObj["insid"];
            if (!insid) {
            }
            else
                referenceInfo.oldmap[insid] = instanceObj;
            fillReference(serializedObj["value"], instanceObj);
        }
        io.deSerialize = deSerialize;
        function fillReference(serializedObj, instanceObj) {
            if (boolInNull(instanceObj) || boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        dofillReferenceOrArray(serializedObj, instanceObj, key);
                        break;
                }
            }
        }
        io.fillReference = fillReference;
        function dofillReferenceOrArray(serializedObj, instanceObj, key) {
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        if (boolInNull(arrayObj[newkey])) {
                            continue;
                        }
                        var baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                break;
                            default:
                                dofillReference(serializedObj[key]["value"], instanceObj[key], newkey);
                                break;
                        }
                    }
                }
                else {
                    dofillReference(serializedObj, instanceObj, key);
                }
            }
        }
        io.dofillReferenceOrArray = dofillReferenceOrArray;
        function dofillReference(serializedObj, instanceObj, key) {
            if (boolInNull(instanceObj) || boolInNull(serializedObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
            }
            else {
                if (serializedObj[key].parse == "reference") {
                    var instance = referenceInfo.oldmap[serializedObj[key].value];
                    if (type == "transform" || type == "transform2D") {
                    }
                    else {
                        if (instance instanceof gd3d.framework.transform2D) {
                            instance = instance.getComponent(type);
                        }
                        else if (instance instanceof gd3d.framework.transform) {
                            instance = instance.gameObject.getComponent(type);
                        }
                    }
                    if (_isArray) {
                        instanceObj.push(instance);
                    }
                    else {
                        instanceObj[key] = instance;
                    }
                }
                else {
                    if (!instanceObj[key])
                        return console.warn(serializedObj[key].value.comp.type + " \u586B\u5145\u503C\u5931\u8D25");
                    fillReference(serializedObj[key].value, instanceObj[key]);
                }
            }
        }
        io.dofillReference = dofillReference;
        function deSerializeObj(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (instanceObj == undefined) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        if (serializedObj[key] == undefined || valueType != serializedObj[key].type) {
                            continue;
                        }
                        else {
                            instanceObj[key] = serializedObj[key].value;
                        }
                        break;
                    default:
                        deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename);
                        break;
                }
            }
        }
        io.deSerializeObj = deSerializeObj;
        function deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (type == null) {
                    throw new Error("必须传入一个实例，用来赋值");
                }
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        var baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (baseType != serializedObj[key]["value"][newkey].type) {
                                    throw new Error("反序列化失败，类型不匹配：" + baseType + " as " + serializedObj[key]["value"][newkey].type);
                                }
                                if (_isArray) {
                                    instanceObj[key].push(serializedObj[key]["value"][newkey].value);
                                }
                                else {
                                    instanceObj[key][newkey] = serializedObj[key]["value"][newkey].value;
                                }
                                break;
                            default:
                                if (baseType == "nodeComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "gameObject") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    if (_nodeComponent[0].comp)
                                        instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                                    var _transforms = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms[0]);
                                }
                                else if (baseType == "C2DComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    if (_nodeComponent[0].comp)
                                        instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform2D" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _transforms2D = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms2D, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms2D[0]);
                                }
                                else {
                                    deSerializeOtherType(serializedObj[key]["value"], instanceObj[key], newkey, assetMgr, bundlename);
                                }
                                break;
                        }
                    }
                }
                else {
                    deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename);
                }
            }
        }
        io.deSerializeOtherTypeOrArray = deSerializeOtherTypeOrArray;
        function deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj) || boolInNull(instanceObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
                var assetName = serializedObj[key].value;
                var _asset = void 0;
                if (assetName.indexOf("SystemDefaultAsset-") >= 0) {
                    assetName = assetName.replace("SystemDefaultAsset-", "");
                    if (type == "mesh") {
                        assetName = assetName.replace(".mesh.bin", "");
                        _asset = assetMgr.getDefaultMesh(assetName);
                    }
                    else if (type == "texture") {
                        _asset = assetMgr.getDefaultTexture(assetName);
                    }
                }
                else {
                    _asset = assetMgr.getAssetByName(assetName, bundlename);
                }
                if (_asset == null && type == "animationClip") {
                    _asset = assetMgr.getAssetByName(assetName);
                    if (!_asset) {
                        _asset = new gd3d.framework.animationClip(assetName);
                        _asset.use();
                    }
                }
                {
                    if (instanceObj instanceof Array) {
                        instanceObj.push(_asset);
                    }
                    else {
                        instanceObj[key] = _asset;
                    }
                }
            }
            else {
                if (serializedObj[key].parse == "reference") {
                }
                else {
                    var _newInstance = void 0;
                    var componentType = gd3d.gd3d_reflect_root["__gdmeta__"][type];
                    if (!componentType) {
                        console.warn(instanceObj);
                        console.warn(type);
                        return console.warn("\u65E0\u6CD5\u627E\u5230\u7EC4\u4EF6:" + gd3d.gd3d_reflect_root["__gdmeta__"][type]);
                    }
                    if (type == "gameObject" && key == "gameObject" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                        _newInstance = instanceObj.gameObject;
                    }
                    else if (type == "transform2D" && key == "rootNode" && gd3d.reflect.getClassName(instanceObj) == "canvas") {
                        _newInstance = gd3d.reflect.createInstance(componentType, null);
                        instanceObj.rootNode = _newInstance;
                        _newInstance.canvas = instanceObj;
                    }
                    else {
                        _newInstance = gd3d.reflect.createInstance(componentType, null);
                        if (_isArray)
                            instanceObj.push(_newInstance);
                        else {
                            instanceObj[key] = _newInstance;
                            _newInstance = instanceObj[key];
                        }
                    }
                    deSerializeObj(serializedObj[key].value, _newInstance, assetMgr, bundlename);
                    var insid = serializedObj[key].insid;
                    if (!insid) {
                    }
                    else
                        referenceInfo.oldmap[insid] = _newInstance;
                }
            }
        }
        io.deSerializeOtherType = deSerializeOtherType;
        function isArray(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0) {
                return true;
            }
            return false;
        }
        io.isArray = isArray;
        function isArrayOrDic(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0 || type.indexOf("dic") >= 0) {
                return true;
            }
            return false;
        }
        io.isArrayOrDic = isArrayOrDic;
        function isAsset(type) {
            if (type == "mesh" || type == "texture" || type == "shader" ||
                type == "material" || type == "animationClip" || type == "atlas" || type == "keyFrameAniClip" ||
                type == "font" || type == "prefab" || type == "sprite" || type == "textasset" || type == "f14eff")
                return true;
            return false;
        }
        io.isAsset = isAsset;
        function isAssetInspector(type) {
            if (type == "prefab")
                return true;
        }
        io.isAssetInspector = isAssetInspector;
        var valueInfo = (function () {
            function valueInfo(value, type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                if (isAsset(type)) {
                    _parse = "nameonly";
                    if (type == "material") {
                        if (value.lastIndexOf(".mat.json") < 0)
                            value += ".mat.json";
                    }
                }
                this.value = value;
                this.type = type;
                this.parse = _parse;
            }
            return valueInfo;
        }());
        var inspectorValueInfo = (function () {
            function inspectorValueInfo(_value, _type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                this.value = _value;
                this.type = _type;
                if (isAssetInspector(_type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
            return inspectorValueInfo;
        }());
        var referenceInfo = (function () {
            function referenceInfo() {
            }
            referenceInfo.regDefaultType = function () {
                referenceInfo.regType("vector4");
                referenceInfo.regType("color");
                referenceInfo.regType("border");
                referenceInfo.regType("quaternion");
                referenceInfo.regType("material");
                referenceInfo.regType("gameObject");
                referenceInfo.regType("transform2D");
                referenceInfo.regType("shader");
                referenceInfo.regType("atlas");
                referenceInfo.regType("font");
                referenceInfo.regType("sprite");
                referenceInfo.regType("texture");
                referenceInfo.regType("mesh");
                referenceInfo.regType("animationclip");
                referenceInfo.regType("keyFrameAniClip");
                referenceInfo.regType("constText");
                referenceInfo.regType("UniformData");
                referenceInfo.regType("f14eff");
            };
            referenceInfo.regType = function (type) {
                referenceInfo.regtypelist.push(type);
            };
            referenceInfo.isRegType = function (type) {
                return this.regtypelist.indexOf(type) >= 0;
            };
            referenceInfo.oldmap = {};
            referenceInfo.regtypelist = [];
            return referenceInfo;
        }());
        io.referenceInfo = referenceInfo;
        var enumMgr = (function () {
            function enumMgr() {
            }
            enumMgr.enumMap = {};
            return enumMgr;
        }());
        io.enumMgr = enumMgr;
        function boolInNull(obj) {
            if (obj == null || obj == undefined) {
                return true;
            }
            return false;
        }
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var binReader = (function () {
            function binReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            binReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binReader.prototype.peek = function () {
                return this._seek;
            };
            binReader.prototype.length = function () {
                return this._data.byteLength;
            };
            binReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            binReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            binReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            binReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            binReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            binReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            binReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            binReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            Object.defineProperty(binReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            binReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            binReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            binReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            binReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            binReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            binReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return binReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            binReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binReader.prototype.readShort = function () {
                return this.readInt16();
            };
            binReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return binReader;
        }());
        io.binReader = binReader;
        var binWriter = (function () {
            function binWriter() {
                {
                    var buf = new ArrayBuffer(1024);
                    this._length = 0;
                }
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            binWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            binWriter.prototype.getLength = function () {
                return length;
            };
            binWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            binWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binWriter.prototype.peek = function () {
                return this._seek;
            };
            binWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            binWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            binWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            binWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            binWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            binWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(binWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            binWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            binWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            binWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            binWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            binWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            binWriter.prototype.writeUTFBytes = function (str) {
                var strArray = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            binWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            binWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            binWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return binWriter;
        }());
        io.binWriter = binWriter;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function colorSet_White(out) {
            out.r = 1;
            out.g = 1;
            out.b = 1;
            out.a = 1;
        }
        math.colorSet_White = colorSet_White;
        function colorSet_Black(out) {
            out.r = 0;
            out.g = 0;
            out.b = 0;
            out.a = 1;
        }
        math.colorSet_Black = colorSet_Black;
        function colorSet_Gray(out) {
            out.r = 0.5;
            out.g = 0.5;
            out.b = 0.5;
            out.a = 1;
        }
        math.colorSet_Gray = colorSet_Gray;
        function colorMultiply(srca, srcb, out) {
            out.r = srca.r * srcb.r;
            out.g = srca.g * srcb.g;
            out.b = srca.b * srcb.b;
            out.a = srca.a * srcb.a;
        }
        math.colorMultiply = colorMultiply;
        function scaleToRef(src, scale, out) {
            out.r = src.r * scale;
            out.g = src.g * scale;
            out.b = src.b * scale;
            out.a = src.a * scale;
        }
        math.scaleToRef = scaleToRef;
        function colorClone(src, out) {
            out.rawData[0] = src.rawData[0];
            out.rawData[1] = src.rawData[1];
            out.rawData[2] = src.rawData[2];
            out.rawData[3] = src.rawData[3];
        }
        math.colorClone = colorClone;
        function colorLerp(srca, srcb, t, out) {
            out.a = t * (srcb.a - srca.a) + srca.a;
            out.r = t * (srcb.r - srca.r) + srca.r;
            out.g = t * (srcb.g - srca.g) + srca.g;
            out.b = t * (srcb.b - srca.b) + srca.b;
        }
        math.colorLerp = colorLerp;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
            var vp1 = planeVector.x;
            var vp2 = planeVector.y;
            var vp3 = planeVector.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = lineVector.x;
            var v2 = lineVector.y;
            var v3 = lineVector.z;
            var m1 = linePoint.x;
            var m2 = linePoint.y;
            var m3 = linePoint.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                out = null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                out.x = m1 + v1 * t;
                out.y = m2 + v2 * t;
                out.z = m3 + v3 * t;
            }
        }
        math.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
        function isContain(p1, p2, p3, p4, mp) {
            if (Multiply(mp, p1, p2) * Multiply(mp, p4, p3) <= 0 && Multiply(mp, p4, p1) * Multiply(mp, p3, p2) <= 0)
                return true;
            return false;
        }
        math.isContain = isContain;
        function Multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        math.Multiply = Multiply;
        function getPointByTwoline(index, p2, dir2, outpoint) {
            var matrix = new gd3d.math.matrix();
            var dir1;
            if (index == 1) {
                dir1 = new gd3d.math.vector3(1, 0, 0);
                matrix.rawData[0] = 1;
            }
            else if (index == 2) {
                dir1 = new gd3d.math.vector3(0, 1, 0);
                matrix.rawData[0] = 0;
                matrix.rawData[1] = 1;
            }
            else if (index == 3) {
                dir1 = new gd3d.math.vector3(0, 0, 1);
                matrix.rawData[0] = 0;
                matrix.rawData[2] = 1;
            }
            var dirBt = new gd3d.math.vector3();
            gd3d.math.vec3Cross(dir1, dir2, dirBt);
            matrix.rawData[4] = dirBt.x;
            matrix.rawData[5] = dirBt.y;
            matrix.rawData[6] = dirBt.z;
            matrix.rawData[8] = -dir2.x;
            matrix.rawData[9] = -dir2.y;
            matrix.rawData[10] = -dir2.z;
            gd3d.math.matrixInverse(matrix, matrix);
            var outnode = new gd3d.math.vector3();
            gd3d.math.matrixTransformVector3(p2, matrix, outnode);
            if (index == 1) {
                outpoint = new gd3d.math.vector3(outnode.x, 0, 0);
            }
            else if (index == 2) {
                outpoint = new gd3d.math.vector3(0, outnode.y, 0);
            }
            else if (index == 3) {
                outpoint = new gd3d.math.vector3(0, 0, outnode.z);
            }
        }
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function matrixGetTranslation(src, out) {
            out.rawData[0] = src.rawData[12];
            out.rawData[1] = src.rawData[13];
            out.rawData[2] = src.rawData[14];
        }
        math.matrixGetTranslation = matrixGetTranslation;
        function matrixTranspose(src, out) {
            out.rawData[1] = src.rawData[4];
            out.rawData[2] = src.rawData[8];
            out.rawData[3] = src.rawData[12];
            out.rawData[4] = src.rawData[1];
            out.rawData[6] = src.rawData[9];
            out.rawData[7] = src.rawData[13];
            out.rawData[8] = src.rawData[2];
            out.rawData[9] = src.rawData[6];
            out.rawData[11] = src.rawData[14];
            out.rawData[12] = src.rawData[3];
            out.rawData[13] = src.rawData[7];
            out.rawData[14] = src.rawData[11];
        }
        math.matrixTranspose = matrixTranspose;
        function matrixDecompose(src, scale, rotation, translation) {
            translation.rawData.set(src.rawData.subarray(12, 15));
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = math.pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale.x;
            mat.rawData[1] = src.rawData[1] / scale.x;
            mat.rawData[2] = src.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale.y;
            mat.rawData[5] = src.rawData[5] / scale.y;
            mat.rawData[6] = src.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale.z;
            mat.rawData[9] = src.rawData[9] / scale.z;
            mat.rawData[10] = src.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, rotation);
            math.pool.delete_matrix(mat);
            return true;
        }
        math.matrixDecompose = matrixDecompose;
        var angelref = (function () {
            function angelref() {
            }
            return angelref;
        }());
        math.angelref = angelref;
        function matrix3x2Decompose(src, scale, rotation, translation) {
            translation.x = src.rawData[4];
            translation.y = src.rawData[5];
            scale.x = Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1]);
            scale.y = Math.sqrt(src.rawData[2] * src.rawData[2] + src.rawData[3] * src.rawData[3]);
            if (scale.x === 0 || scale.y === 0) {
                rotation.v = 0;
                return false;
            }
            var sx = src.rawData[0] / scale.x;
            var r1 = Math.acos(sx);
            var sxs = src.rawData[1] / scale.x;
            var r2 = Math.asin(sxs);
            if (sxs < 0) {
                r1 = 2 * Math.PI - r1;
            }
            rotation.v = r1;
            return true;
        }
        math.matrix3x2Decompose = matrix3x2Decompose;
        function matrixGetRotation(src, result) {
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            var scale_x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            var scale_y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            var scale_z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            var mat = math.pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale_x;
            mat.rawData[1] = src.rawData[1] / scale_x;
            mat.rawData[2] = src.rawData[2] / scale_x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale_y;
            mat.rawData[5] = src.rawData[5] / scale_y;
            mat.rawData[6] = src.rawData[6] / scale_y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale_z;
            mat.rawData[9] = src.rawData[9] / scale_z;
            mat.rawData[10] = src.rawData[10] / scale_z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, result);
            math.pool.delete_matrix(mat);
        }
        math.matrixGetRotation = matrixGetRotation;
        function matrix2Quaternion(matrix, result) {
            var data = matrix.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                result.w = 0.25 / s;
                result.x = (m32 - m23) * s;
                result.y = (m13 - m31) * s;
                result.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                result.w = (m32 - m23) / s;
                result.x = 0.25 * s;
                result.y = (m12 + m21) / s;
                result.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                result.w = (m13 - m31) / s;
                result.x = (m12 + m21) / s;
                result.y = 0.25 * s;
                result.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                result.w = (m21 - m12) / s;
                result.x = (m13 + m31) / s;
                result.y = (m23 + m32) / s;
                result.z = 0.25 * s;
            }
        }
        math.matrix2Quaternion = matrix2Quaternion;
        function unitxyzToRotation(xAxis, yAxis, zAxis, out) {
            var m11 = xAxis.x, m12 = yAxis.x, m13 = zAxis.x;
            var m21 = xAxis.y, m22 = yAxis.y, m23 = zAxis.y;
            var m31 = xAxis.z, m32 = yAxis.z, m33 = zAxis.z;
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                out.w = 0.25 / s;
                out.x = (m32 - m23) * s;
                out.y = (m13 - m31) * s;
                out.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                out.w = (m32 - m23) / s;
                out.x = 0.25 * s;
                out.y = (m12 + m21) / s;
                out.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                out.w = (m13 - m31) / s;
                out.x = (m12 + m21) / s;
                out.y = 0.25 * s;
                out.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                out.w = (m21 - m12) / s;
                out.x = (m13 + m31) / s;
                out.y = (m23 + m32) / s;
                out.z = 0.25 * s;
            }
        }
        math.unitxyzToRotation = unitxyzToRotation;
        function matrixClone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrixClone = matrixClone;
        function matrix3x2Clone(src, out) {
            for (var i = 0; i < 6; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrix3x2Clone = matrix3x2Clone;
        function matrixMakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = 1;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = 1;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeIdentity = matrixMakeIdentity;
        function matrix3x2MakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 1;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeIdentity = matrix3x2MakeIdentity;
        function matrixInverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            out.rawData[0] = l23 * l27;
            out.rawData[4] = l24 * l27;
            out.rawData[8] = l25 * l27;
            out.rawData[12] = l26 * l27;
            out.rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            out.rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            out.rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            out.rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            out.rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            out.rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            out.rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            out.rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            out.rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            out.rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            out.rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            out.rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
        }
        math.matrixInverse = matrixInverse;
        function matrix3x2Inverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l5 = src.rawData[2];
            var l6 = src.rawData[3];
            var l13 = src.rawData[4];
            var l14 = src.rawData[5];
            var l26 = -(((l5 * -l14) - (l6 * -l13)));
            var l27 = 1.0 / ((((l1 * l6) + (l2 * -l5))));
            out.rawData[0] = l6 * l27;
            out.rawData[2] = -l5 * l27;
            out.rawData[4] = l26 * l27;
            out.rawData[1] = -(((l2))) * l27;
            out.rawData[3] = (((l1))) * l27;
            out.rawData[5] = (((l1 * -l14) - (l2 * -l13))) * l27;
        }
        math.matrix3x2Inverse = matrix3x2Inverse;
        function matrixMakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix();
            matrixMakeScale(scale.x, scale.y, scale.z, matS);
            var matR = gd3d.math.pool.new_matrix();
            math.quatToMatrix(rot, matR);
            matrixMultiply(matR, matS, out);
            out.rawData[12] = pos.x;
            out.rawData[13] = pos.y;
            out.rawData[14] = pos.z;
            out.rawData[15] = 1;
            gd3d.math.pool.delete_matrix(matS);
            gd3d.math.pool.delete_matrix(matR);
        }
        math.matrixMakeTransformRTS = matrixMakeTransformRTS;
        function matrix3x2MakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeScale(scale.x, scale.y, matS);
            var matR = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeRotate(rot, matR);
            matrix3x2Multiply(matR, matS, out);
            out.rawData[4] = pos.x;
            out.rawData[5] = pos.y;
            gd3d.math.pool.delete_matrix3x2(matS);
            gd3d.math.pool.delete_matrix3x2(matR);
        }
        math.matrix3x2MakeTransformRTS = matrix3x2MakeTransformRTS;
        function matrixMakeTranslate(x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeTranslate = matrixMakeTranslate;
        function matrix3x2MakeTranslate(x, y, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 1.0;
            out.rawData[4] = x;
            out.rawData[5] = y;
        }
        math.matrix3x2MakeTranslate = matrix3x2MakeTranslate;
        function matrixGetScale(src, scale) {
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.rawData[0] = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.rawData[1] = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.rawData[2] = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
        }
        math.matrixGetScale = matrixGetScale;
        function matrixMakeScale(xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeScale = matrixMakeScale;
        function matrix3x2TransformVector2(mat, inp, out) {
            var x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2] + mat.rawData[4];
            var y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3] + mat.rawData[5];
            out.x = x;
            out.y = y;
        }
        math.matrix3x2TransformVector2 = matrix3x2TransformVector2;
        function matrix3x2TransformNormal(mat, inp, out) {
            var x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2];
            var y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3];
            out.x = x;
            out.y = y;
        }
        math.matrix3x2TransformNormal = matrix3x2TransformNormal;
        function matrix3x2MakeScale(xScale, yScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = yScale;
            out.rawData[4] = 0.0;
            out.rawData[5] = 0.0;
        }
        math.matrix3x2MakeScale = matrix3x2MakeScale;
        function matrixMakeRotateAxisAngle(axis, angle, out) {
            var x = axis.x, y = axis.y, z = axis.z;
            var length = Math.sqrt(x * x + y * y + z * z);
            if (!length)
                return;
            if (length !== 1) {
                length = 1 / length;
                x *= length;
                y *= length;
                z *= length;
            }
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1.0 - c;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            out.rawData[0] = b00;
            out.rawData[1] = b01;
            out.rawData[2] = b02;
            out.rawData[3] = 0;
            out.rawData[4] = b10;
            out.rawData[5] = b11;
            out.rawData[6] = b12;
            out.rawData[7] = 0;
            out.rawData[8] = b20;
            out.rawData[9] = b21;
            out.rawData[10] = b22;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeRotateAxisAngle = matrixMakeRotateAxisAngle;
        function matrix3x2MakeRotate(angle, out) {
            var x = 0, y = 0, z = 1;
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            out.rawData[0] = c;
            out.rawData[1] = s;
            out.rawData[2] = -s;
            out.rawData[3] = c;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeRotate = matrix3x2MakeRotate;
        function matrixMultiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        }
        math.matrixMultiply = matrixMultiply;
        function matrix3x2Multiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = 0;
            var a10 = lhs.rawData[2], a11 = lhs.rawData[3], a12 = 0;
            var a30 = lhs.rawData[4], a31 = lhs.rawData[5], a32 = 1;
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b3 = 0;
            var temp_0 = b0 * a00 + b1 * a10 + b3 * a30;
            var temp_1 = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[2];
            b1 = rhs.rawData[3];
            b3 = 0;
            var temp_2 = b0 * a00 + b1 * a10 + b3 * a30;
            var temp_3 = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b3 = 1;
            var temp_4 = b0 * a00 + b1 * a10 + b3 * a30;
            var temp_5 = b0 * a01 + b1 * a11 + b3 * a31;
            out.rawData[0] = temp_0;
            out.rawData[1] = temp_1;
            out.rawData[2] = temp_2;
            out.rawData[3] = temp_3;
            out.rawData[4] = temp_4;
            out.rawData[5] = temp_5;
        }
        math.matrix3x2Multiply = matrix3x2Multiply;
        function matrix3x2Equal(mtx1, mtx2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            for (var i = 0; i < 6; i++) {
                if (Math.abs(mtx1.rawData[i] - mtx2.rawData[i]) > threshold) {
                    return false;
                }
            }
            return true;
        }
        math.matrix3x2Equal = matrix3x2Equal;
        function matrixProject_PerspectiveLH(fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = -zfar / (znear - zfar);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = (znear * zfar) / (znear - zfar);
        }
        math.matrixProject_PerspectiveLH = matrixProject_PerspectiveLH;
        function matrixProject_OrthoLH(width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (zfar + znear) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
        }
        math.matrixProject_OrthoLH = matrixProject_OrthoLH;
        function matrixLookatLH(forward, up, out) {
            var z = math.pool.new_vector3(-forward.x, -forward.y, -forward.z);
            math.vec3Normalize(z, z);
            var y = math.pool.new_vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = math.pool.new_vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            math.vec3Clone(math.pool.vector3_zero, y);
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
            math.pool.delete_vector3(x);
            math.pool.delete_vector3(y);
            math.pool.delete_vector3(z);
        }
        math.matrixLookatLH = matrixLookatLH;
        function matrixViewLookatLH(eye, forward, up, out) {
            var z = math.pool.new_vector3(forward.x, forward.y, forward.z);
            math.vec3Normalize(z, z);
            var y = math.pool.new_vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = math.pool.new_vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            math.vec3Clone(math.pool.vector3_zero, y);
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            var ex = -math.vec3Dot(x, eye);
            var ey = -math.vec3Dot(y, eye);
            var ez = -math.vec3Dot(z, eye);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = ex;
            out.rawData[13] = ey;
            out.rawData[14] = ez;
            out.rawData[15] = 1;
            math.pool.delete_vector3(x);
            math.pool.delete_vector3(y);
            math.pool.delete_vector3(z);
        }
        math.matrixViewLookatLH = matrixViewLookatLH;
        function matrixLerp(left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
        }
        math.matrixLerp = matrixLerp;
        function matrixTransformVector3(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]) + transformation.rawData[12];
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]) + transformation.rawData[13];
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]) + transformation.rawData[14];
            var w = (vector.x * transformation.rawData[3]) + (vector.y * transformation.rawData[7]) + (vector.z * transformation.rawData[11]) + transformation.rawData[15];
            result.rawData[0] = x / w;
            result.rawData[1] = y / w;
            result.rawData[2] = z / w;
        }
        math.matrixTransformVector3 = matrixTransformVector3;
        function matrixTransformVector4(src, mtx, out) {
            var x = (src.rawData[0] * mtx.rawData[0]) + (src.rawData[1] * mtx.rawData[4]) + (src.rawData[2] * mtx.rawData[8]) + (src.rawData[3] * mtx.rawData[12]);
            var y = (src.rawData[0] * mtx.rawData[1]) + (src.rawData[1] * mtx.rawData[5]) + (src.rawData[2] * mtx.rawData[9]) + (src.rawData[3] * mtx.rawData[13]);
            var z = (src.rawData[0] * mtx.rawData[2]) + (src.rawData[1] * mtx.rawData[6]) + (src.rawData[2] * mtx.rawData[10]) + (src.rawData[3] * mtx.rawData[14]);
            var w = (src.rawData[0] * mtx.rawData[3]) + (src.rawData[1] * mtx.rawData[7]) + (src.rawData[2] * mtx.rawData[11]) + (src.rawData[3] * mtx.rawData[15]);
            out.rawData[0] = x;
            out.rawData[1] = y;
            out.rawData[2] = z;
            out.rawData[3] = w;
        }
        math.matrixTransformVector4 = matrixTransformVector4;
        function matrixTransformNormal(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]);
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]);
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]);
            result.rawData[0] = x;
            result.rawData[1] = y;
            result.rawData[2] = z;
        }
        math.matrixTransformNormal = matrixTransformNormal;
        function matrixGetVector3ByOffset(src, offset, result) {
            result.rawData[0] = src.rawData[offset];
            result.rawData[1] = src.rawData[offset + 1];
            result.rawData[2] = src.rawData[offset + 2];
        }
        math.matrixGetVector3ByOffset = matrixGetVector3ByOffset;
        function matrixReset(mat) {
            mat.rawData[0] = 1;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 1;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 1;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixReset = matrixReset;
        function matrixZero(mat) {
            mat.rawData[0] = 0;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 0;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 0;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixZero = matrixZero;
        function matrixScaleByNum(value, mat) {
            mat.rawData[0] *= value;
            mat.rawData[1] *= value;
            mat.rawData[2] *= value;
            mat.rawData[3] *= value;
            mat.rawData[4] *= value;
            mat.rawData[5] *= value;
            mat.rawData[6] *= value;
            mat.rawData[7] *= value;
            mat.rawData[8] *= value;
            mat.rawData[9] *= value;
            mat.rawData[10] *= value;
            mat.rawData[11] *= value;
            mat.rawData[12] *= value;
            mat.rawData[13] *= value;
            mat.rawData[14] *= value;
            mat.rawData[15] *= value;
        }
        math.matrixScaleByNum = matrixScaleByNum;
        function matrixAdd(left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
        }
        math.matrixAdd = matrixAdd;
        function matrixEqual(mtx1, mtx2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            for (var i = 0; i < 16; i++) {
                if (Math.abs(mtx1.rawData[i] - mtx2.rawData[i]) > threshold) {
                    return false;
                }
            }
            return true;
        }
        math.matrixEqual = matrixEqual;
        function matrixIsIdentity(mtx) {
            var m = mtx.rawData;
            var _isIdentity = (m[0] === 1.0 && m[1] === 0.0 && m[2] === 0.0 && m[3] === 0.0 &&
                m[4] === 0.0 && m[5] === 1.0 && m[6] === 0.0 && m[7] === 0.0 &&
                m[8] === 0.0 && m[9] === 0.0 && m[10] === 1.0 && m[11] === 0.0 &&
                m[12] === 0.0 && m[13] === 0.0 && m[14] === 0.0 && m[15] === 1.0);
            return _isIdentity;
        }
        math.matrixIsIdentity = matrixIsIdentity;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function floatClamp(v, min, max) {
            if (min === void 0) { min = 0; }
            if (max === void 0) { max = 1; }
            if (v < min)
                return min;
            else if (v > max)
                return max;
            else
                return v;
        }
        math.floatClamp = floatClamp;
        function sign(value) {
            value = +value;
            if (value === 0 || isNaN(value))
                return value;
            return value > 0 ? 1 : -1;
        }
        math.sign = sign;
        function getKeyCodeByAscii(ev) {
            if (ev.shiftKey) {
                return ev.keyCode - 32;
            }
            else {
                return ev.keyCode;
            }
        }
        math.getKeyCodeByAscii = getKeyCodeByAscii;
        function numberLerp(fromV, toV, v) {
            return fromV * (1 - v) + toV * v;
        }
        math.numberLerp = numberLerp;
        function x_AXIS() {
            return commonStatic.x_axis;
        }
        math.x_AXIS = x_AXIS;
        function y_AXIS() {
            return commonStatic.y_axis;
        }
        math.y_AXIS = y_AXIS;
        function z_AXIS() {
            return commonStatic.z_axis;
        }
        math.z_AXIS = z_AXIS;
        var commonStatic = (function () {
            function commonStatic() {
            }
            commonStatic.x_axis = new gd3d.math.vector3(1, 0, 0);
            commonStatic.y_axis = new gd3d.math.vector3(0, 1, 0);
            commonStatic.z_axis = new gd3d.math.vector3(0, 0, 1);
            return commonStatic;
        }());
        math.commonStatic = commonStatic;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function quatIdentity(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatIdentity = quatIdentity;
        function quatNormalize(src, out) {
            var mag = 1 / Math.sqrt(src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
        }
        math.quatNormalize = quatNormalize;
        function quatTransformVector(src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
        }
        math.quatTransformVector = quatTransformVector;
        function quatTransformVectorDataAndQuat(src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
        }
        math.quatTransformVectorDataAndQuat = quatTransformVectorDataAndQuat;
        function quatMagnitude(src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        }
        math.quatMagnitude = quatMagnitude;
        function quatClone(src, out) {
            out.rawData[0] = src.rawData[0];
            out.rawData[1] = src.rawData[1];
            out.rawData[2] = src.rawData[2];
            out.rawData[3] = src.rawData[3];
        }
        math.quatClone = quatClone;
        function quatEqual(quat, quat2, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(quat.x - quat2.x) > threshold)
                return false;
            if (Math.abs(quat.y - quat2.y) > threshold)
                return false;
            if (Math.abs(quat.z - quat2.z) > threshold)
                return false;
            if (Math.abs(quat.w - quat2.w) > threshold)
                return false;
            return true;
        }
        math.quatEqual = quatEqual;
        function quatToMatrix(src, out) {
            var xy2 = 2.0 * src.x * src.y, xz2 = 2.0 * src.x * src.z, xw2 = 2.0 * src.x * src.w;
            var yz2 = 2.0 * src.y * src.z, yw2 = 2.0 * src.y * src.w, zw2 = 2.0 * src.z * src.w;
            var xx = src.x * src.x, yy = src.y * src.y, zz = src.z * src.z, ww = src.w * src.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
        }
        math.quatToMatrix = quatToMatrix;
        function quatInverse(src, out) {
            var norm = src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = src.w * invNorm;
                out.x = -src.x * invNorm;
                out.y = -src.y * invNorm;
                out.z = -src.z * invNorm;
            }
        }
        math.quatInverse = quatInverse;
        function quatFromYawPitchRoll(yaw, pitch, roll, result) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        math.quatFromYawPitchRoll = quatFromYawPitchRoll;
        function quatMultiply(srca, srcb, out) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiply = quatMultiply;
        function quatMultiplyDataAndQuat(srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiplyDataAndQuat = quatMultiplyDataAndQuat;
        function quatMultiplyVector(vector, scr, out) {
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            out.w = -scr.x * x2 - scr.y * y2 - scr.z * z2;
            out.x = scr.w * x2 + scr.y * z2 - scr.z * y2;
            out.y = scr.w * y2 - scr.x * z2 + scr.z * x2;
            out.z = scr.w * z2 + scr.x * y2 - scr.y * x2;
        }
        math.quatMultiplyVector = quatMultiplyVector;
        function quatLerp(srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
        }
        math.quatLerp = quatLerp;
        function quatFromAxisAngle(axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            math.quatNormalize(out, out);
        }
        math.quatFromAxisAngle = quatFromAxisAngle;
        function quatToAxisAngle(src, axis) {
            var sqrLength = src.x * src.x + src.y * src.y + src.z * src.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(src.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = src.x * sqrLength;
                axis.y = src.y * sqrLength;
                axis.z = src.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        }
        math.quatToAxisAngle = quatToAxisAngle;
        function quatFromEulerAngles(ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            math.quatNormalize(out, out);
        }
        math.quatFromEulerAngles = quatFromEulerAngles;
        function quatToEulerAngles(src, result) {
            var qz = src.z;
            var qx = src.x;
            var qy = src.y;
            var qw = src.w;
            var sqw = qw * qw;
            var sqz = qz * qz;
            var sqx = qx * qx;
            var sqy = qy * qy;
            var zAxisY = qy * qz - qx * qw;
            var limit = .4999999;
            if (zAxisY < -limit) {
                result.y = 2 * Math.atan2(qy, qw);
                result.x = Math.PI / 2;
                result.z = 0;
            }
            else if (zAxisY > limit) {
                result.y = 2 * Math.atan2(qy, qw);
                result.x = -Math.PI / 2;
                result.z = 0;
            }
            else {
                result.z = Math.atan2(2.0 * (qx * qy + qz * qw), (-sqz - sqx + sqy + sqw));
                result.x = Math.asin(-2.0 * (qz * qy - qx * qw));
                result.y = Math.atan2(2.0 * (qz * qx + qy * qw), (sqz - sqx - sqy + sqw));
            }
            result.x /= Math.PI / 180;
            result.y /= Math.PI / 180;
            result.z /= Math.PI / 180;
        }
        math.quatToEulerAngles = quatToEulerAngles;
        function quatReset(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatReset = quatReset;
        function quatLookat(pos, targetpos, out) {
            var dir = math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = math.pool.new_vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var dirxz1 = math.pool.new_vector3(dir.x, 0, dir.z);
            var v3length = math.vec3Length(dirxz1);
            if (v3length > 0.9999999999)
                v3length = 1;
            if (v3length < -0.9999999999)
                v3length = -1;
            var pitch = Math.acos(v3length);
            if (dir.y > 0) {
                pitch = -pitch;
            }
            quatFromYawPitchRoll(yaw, pitch, 0, out);
            math.quatNormalize(out, out);
            math.pool.delete_vector3(dir);
            math.pool.delete_vector3(dirxz);
            math.pool.delete_vector3(dirxz1);
        }
        math.quatLookat = quatLookat;
        function quat2Lookat(pos, targetpos, out, updir) {
            if (updir === void 0) { updir = gd3d.math.pool.vector3_up; }
            var dir = gd3d.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dot = gd3d.math.vec3Dot(gd3d.math.pool.vector3_forward, dir);
            dot = gd3d.math.floatClamp(dot, -1, 1);
            var rotangle = Math.acos(dot) * 180 / Math.PI;
            if (rotangle < 0.01) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return;
            }
            if (rotangle > 179.9) {
                gd3d.math.quatFromAxisAngle(updir, 180, out);
                return;
            }
            var rotAxis = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Cross(gd3d.math.pool.vector3_forward, dir, rotAxis);
            gd3d.math.vec3Normalize(rotAxis, rotAxis);
            gd3d.math.quatFromAxisAngle(rotAxis, rotangle, out);
        }
        math.quat2Lookat = quat2Lookat;
        function quat2LookRotation(pos, targetpos, upwards, out) {
            var dir = gd3d.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.quatLookRotation(dir, upwards, out);
        }
        math.quat2LookRotation = quat2LookRotation;
        function quatLookRotation(dir, upwards, out) {
            math.vec3Normalize(dir, dir);
            var ab = math.vec3Dot(dir, gd3d.math.pool.vector3_forward);
            var an_dz = Math.acos(ab);
            var cdz = gd3d.math.pool.new_vector3();
            math.vec3Cross(dir, gd3d.math.pool.vector3_forward, cdz);
            math.vec3Normalize(cdz, cdz);
            if (math.vec3Dot(cdz, gd3d.math.pool.vector3_forward) < 0) {
                an_dz = 2 * Math.PI - an_dz;
            }
            an_dz = 180 / Math.PI * an_dz;
            quatFromAxisAngle(cdz, -an_dz, out);
            var y = gd3d.math.pool.new_vector3();
            quatTransformVector(out, gd3d.math.pool.vector3_up, y);
            var cyw = cdz;
            math.vec3Cross(dir, upwards, cyw);
            math.vec3Normalize(y, y);
            math.vec3Normalize(cyw, cyw);
            var cos2Y = math.vec3Dot(cyw, y);
            var sin2Y = Math.sqrt(1 - cos2Y * cos2Y);
            console.log(math.vec3Dot(y, upwards));
            if (math.vec3Dot(y, upwards) <= 0) {
                sin2Y = -sin2Y;
            }
            var siny = Math.sqrt((1 - sin2Y) / 2);
            var cosy = -Math.sqrt((sin2Y + 1) / 2);
            console.log(cos2Y);
            if (cos2Y < 0) {
                cosy = -cosy;
            }
            var yq = gd3d.math.pool.new_quaternion();
            yq.x = 0;
            yq.y = 0;
            yq.z = siny;
            yq.w = cosy;
            quatMultiply(out, yq, out);
            gd3d.math.pool.delete_vector3(dir);
            gd3d.math.pool.delete_vector3(cdz);
        }
        math.quatLookRotation = quatLookRotation;
        function quatYAxis(pos, targetpos, out) {
            var dir = math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = math.pool.new_vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            quatFromYawPitchRoll(yaw, 0, 0, out);
            math.quatNormalize(out, out);
            math.pool.delete_vector3(dir);
            math.pool.delete_vector3(dirxz);
        }
        math.quatYAxis = quatYAxis;
        function rotationTo(from, to, out) {
            var tmpvec3 = math.pool.new_vector3();
            var xUnitVec3 = math.pool.vector3_right;
            var yUnitVec3 = math.pool.vector3_up;
            var dot = math.vec3Dot(from, to);
            if (dot < -0.999999) {
                math.vec3Cross(xUnitVec3, from, tmpvec3);
                if (math.vec3Length(tmpvec3) < 0.000001) {
                    math.vec3Cross(yUnitVec3, from, tmpvec3);
                }
                math.vec3Normalize(tmpvec3, tmpvec3);
                quatFromAxisAngle(tmpvec3, 180, out);
            }
            else if (dot > 0.999999) {
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
            }
            else {
                math.vec3Cross(from, to, tmpvec3);
                out[0] = tmpvec3[0];
                out[1] = tmpvec3[1];
                out[2] = tmpvec3[2];
                out[3] = 1 + dot;
                quatNormalize(out, out);
            }
            math.pool.delete_vector3(tmpvec3);
        }
        math.rotationTo = rotationTo;
        function myLookRotation(dir, out, up) {
            if (up === void 0) { up = math.pool.vector3_up; }
            if (math.vec3Equal(dir, math.pool.vector3_zero)) {
                console.log("Zero direction in MyLookRotation");
                quatIdentity(out);
                return;
            }
            if (!math.vec3Equal(dir, up)) {
                var tempv = math.pool.new_vector3();
                math.vec3ScaleByNum(up, math.vec3Dot(up, dir), tempv);
                math.vec3Subtract(dir, tempv, tempv);
                var qu = math.pool.new_quaternion();
                this.rotationTo(math.pool.vector3_forward, tempv, qu);
                var qu2 = math.pool.new_quaternion();
                this.rotationTo(tempv, dir, qu2);
                quatMultiply(qu, qu2, out);
                math.pool.delete_quaternion(qu);
                math.pool.delete_quaternion(qu2);
                math.pool.delete_vector3(tempv);
            }
            else {
                this.rotationTo(math.pool.vector3_forward, dir, out);
            }
        }
        math.myLookRotation = myLookRotation;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function rectSet_One(out) {
            out.x = 0;
            out.y = 0;
            out.w = 1;
            out.h = 1;
        }
        math.rectSet_One = rectSet_One;
        function rectSet_Zero(out) {
            out.x = 0;
            out.y = 0;
            out.w = 0;
            out.h = 0;
        }
        math.rectSet_Zero = rectSet_Zero;
        function rectEqul(src1, src2) {
            return !((src1.x != src2.x) ||
                (src1.y != src2.y) ||
                (src1.w != src2.w) ||
                (src1.h != src2.h));
        }
        math.rectEqul = rectEqul;
        function rectInner(x, y, src) {
            if (x < src.x || x > src.x + src.w ||
                y < src.y || y > src.y + src.h) {
                return false;
            }
            return true;
        }
        math.rectInner = rectInner;
        function rectCollided(r1, r2) {
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.h + r1.y > r2.y;
        }
        math.rectCollided = rectCollided;
        function rectClone(src, out) {
            out.rawData[0] = src.rawData[0];
            out.rawData[1] = src.rawData[1];
            out.rawData[2] = src.rawData[2];
            out.rawData[3] = src.rawData[3];
        }
        math.rectClone = rectClone;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function caclStringByteLength(value) {
            var total = 0;
            for (var i = 0; i < value.length; i++) {
                var charCode = value.charCodeAt(i);
                if (charCode <= 0x007f) {
                    total += 1;
                }
                else if (charCode <= 0x07ff) {
                    total += 2;
                }
                else if (charCode <= 0xffff) {
                    total += 3;
                }
                else {
                    total += 4;
                }
            }
            return total;
        }
        math.caclStringByteLength = caclStringByteLength;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function spriteAnimation(row, column, index, out) {
            var width = 1.0 / column;
            var height = 1.0 / row;
            var offsetx = width * (index % column);
            var offsety = height * row - height * (Math.floor(index / column) + 1);
            out.x = width;
            out.y = height;
            out.z = offsetx;
            out.w = offsety;
        }
        math.spriteAnimation = spriteAnimation;
        function GetPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease) {
            if (crease === void 0) { crease = 0.3; }
            var oneMinT = 1 - t;
            var oneMinTPow3 = Math.pow(oneMinT, 3);
            var oneMinTPow2 = Math.pow(oneMinT, 2);
            var oneMinCrease = 1 - crease;
            var tempt1 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStart, oneMinTPow3 * oneMinCrease, tempt1);
            var tempt2 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStartHandle, 3 * oneMinTPow2 * t * crease, tempt2);
            var tempt3 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEndHandle, 3 * oneMinT * Math.pow(t, 2) * crease, tempt3);
            var tempt4 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEnd, Math.pow(t, 3) * oneMinCrease, tempt4);
            var tempt5 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Add(tempt1, tempt2, tempt5);
            gd3d.math.vec3Add(tempt5, tempt3, tempt5);
            gd3d.math.vec3Add(tempt5, tempt4, tempt5);
            gd3d.math.vec3ScaleByNum(tempt5, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease), out);
            gd3d.math.pool.delete_vector3(tempt1);
            gd3d.math.pool.delete_vector3(tempt2);
            gd3d.math.pool.delete_vector3(tempt3);
            gd3d.math.pool.delete_vector3(tempt4);
            gd3d.math.pool.delete_vector3(tempt5);
        }
        math.GetPointAlongCurve = GetPointAlongCurve;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec2Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
        }
        math.vec2Subtract = vec2Subtract;
        function vec2Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
        }
        math.vec2Add = vec2Add;
        function vec2Clone(from, to) {
            to.rawData[0] = from.rawData[0];
            to.rawData[1] = from.rawData[1];
        }
        math.vec2Clone = vec2Clone;
        function vec2Distance(a, b) {
            var out = math.pool.new_vector2();
            vec2Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y);
            math.pool.delete_vector2(out);
            return result;
        }
        math.vec2Distance = vec2Distance;
        function vec2ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
        }
        math.vec2ScaleByNum = vec2ScaleByNum;
        function vec2ScaleByVec2(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
        }
        math.vec2ScaleByVec2 = vec2ScaleByVec2;
        function vec2Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y);
        }
        math.vec2Length = vec2Length;
        function vec2SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
        }
        math.vec2SLerp = vec2SLerp;
        function vec2Normalize(from, out) {
            var num = vec2Length(from);
            if (num > Number.MIN_VALUE) {
                out.x = from.x / num;
                out.y = from.y / num;
            }
            else {
                out.x = 0;
                out.y = 0;
            }
        }
        math.vec2Normalize = vec2Normalize;
        function vec2Multiply(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        math.vec2Multiply = vec2Multiply;
        function vec2Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y;
        }
        math.vec2Dot = vec2Dot;
        function vec2Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            return true;
        }
        math.vec2Equal = vec2Equal;
        function vec2SetAll(vector, value) {
            vector.rawData[0] = value;
            vector.rawData[1] = value;
        }
        math.vec2SetAll = vec2SetAll;
        function vec2Set(vector, x, y) {
            vector.rawData[0] = x;
            vector.rawData[1] = y;
        }
        math.vec2Set = vec2Set;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec3Clone(from, to) {
            to.rawData[0] = from.rawData[0];
            to.rawData[1] = from.rawData[1];
            to.rawData[2] = from.rawData[2];
        }
        math.vec3Clone = vec3Clone;
        function vec3ToString(result) {
            result = this.x + "," + this.y + "," + this.z;
        }
        math.vec3ToString = vec3ToString;
        function vec3Add(a, b, out) {
            out.rawData[0] = a.x + b.x;
            out.rawData[1] = a.y + b.y;
            out.rawData[2] = a.z + b.z;
        }
        math.vec3Add = vec3Add;
        function vec3Subtract(a, b, out) {
            out.rawData[0] = a.x - b.x;
            out.rawData[1] = a.y - b.y;
            out.rawData[2] = a.z - b.z;
        }
        math.vec3Subtract = vec3Subtract;
        function vec3Minus(a, out) {
            out.rawData[0] = -a.x;
            out.rawData[1] = -a.y;
            out.rawData[2] = -a.z;
        }
        math.vec3Minus = vec3Minus;
        function vec3Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        }
        math.vec3Length = vec3Length;
        function vec3SqrLength(value) {
            return value.x * value.x + value.y * value.y + value.z * value.z;
        }
        math.vec3SqrLength = vec3SqrLength;
        function vec3Set_One(out) {
            out.rawData[0] = out.rawData[1] = out.rawData[2] = 1;
        }
        math.vec3Set_One = vec3Set_One;
        function vec3Set_Forward(out) {
            out.rawData[0] = out.rawData[1] = 0;
            out.rawData[2] = 1;
        }
        math.vec3Set_Forward = vec3Set_Forward;
        function vec3Set_Back(out) {
            out.rawData[0] = out.rawData[1] = 0;
            out.rawData[2] = -1;
        }
        math.vec3Set_Back = vec3Set_Back;
        function vec3Set_Up(out) {
            out.rawData[0] = out.rawData[2] = 0;
            out.rawData[1] = 1;
        }
        math.vec3Set_Up = vec3Set_Up;
        function vec3Set_Down(out) {
            out.rawData[0] = out.rawData[2] = 0;
            out.rawData[1] = -1;
        }
        math.vec3Set_Down = vec3Set_Down;
        function vec3Set_Left(out) {
            out.rawData[0] = -1;
            out.rawData[1] = out.rawData[2] = 0;
        }
        math.vec3Set_Left = vec3Set_Left;
        function vec3Set_Right(out) {
            out.rawData[0] = 1;
            out.rawData[1] = out.rawData[2] = 0;
        }
        math.vec3Set_Right = vec3Set_Right;
        function vec3Normalize(value, out) {
            var num = vec3Length(value);
            if (num > Number.MIN_VALUE) {
                out.rawData[0] = value.x / num;
                out.rawData[1] = value.y / num;
                out.rawData[2] = value.z / num;
            }
            else {
                out.rawData[0] = 0;
                out.rawData[1] = 0;
                out.rawData[2] = 0;
            }
        }
        math.vec3Normalize = vec3Normalize;
        function vec3ScaleByVec3(from, scale, out) {
            out.rawData[0] = from.x * scale.x;
            out.rawData[1] = from.y * scale.y;
            out.rawData[2] = from.z * scale.z;
        }
        math.vec3ScaleByVec3 = vec3ScaleByVec3;
        function vec3ScaleByNum(from, scale, out) {
            out.rawData[0] = from.x * scale;
            out.rawData[1] = from.y * scale;
            out.rawData[2] = from.z * scale;
        }
        math.vec3ScaleByNum = vec3ScaleByNum;
        function vec3Product(a, b, out) {
            out.rawData[0] = a.x * b.x;
            out.rawData[1] = a.y * b.y;
            out.rawData[2] = a.z * b.z;
        }
        math.vec3Product = vec3Product;
        function vec3Cross(lhs, rhs, out) {
            out.rawData[0] = lhs.y * rhs.z - lhs.z * rhs.y;
            out.rawData[1] = lhs.z * rhs.x - lhs.x * rhs.z;
            out.rawData[2] = lhs.x * rhs.y - lhs.y * rhs.x;
        }
        math.vec3Cross = vec3Cross;
        function vec3Reflect(inDirection, inNormal, out) {
            var v1 = 0;
            v1 = vec3Dot(inNormal, inDirection);
            vec3ScaleByNum(out, v1 * -2, out);
            vec3Add(out, inDirection, out);
        }
        math.vec3Reflect = vec3Reflect;
        function vec3Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
        }
        math.vec3Dot = vec3Dot;
        function vec3Project(vector, onNormal, out) {
            var num = 0;
            num = vec3Dot(onNormal, onNormal);
            if (num < Number.MIN_VALUE) {
                out.rawData[0] = out.rawData[1] = out.rawData[2] = 0;
            }
            else {
                var num2 = 0;
                num2 = vec3Dot(vector, onNormal);
                vec3ScaleByNum(onNormal, num2 / num, out);
            }
        }
        math.vec3Project = vec3Project;
        function vec3ProjectOnPlane(vector, planeNormal, out) {
            vec3Project(vector, planeNormal, out);
            vec3Subtract(vector, out, out);
        }
        math.vec3ProjectOnPlane = vec3ProjectOnPlane;
        function vec3Exclude(excludeThis, fromThat, out) {
            vec3Project(fromThat, excludeThis, out);
            vec3Subtract(fromThat, out, out);
        }
        math.vec3Exclude = vec3Exclude;
        function vec3Angle(from, to) {
            var out1 = math.pool.new_vector3();
            var out2 = math.pool.new_vector3();
            vec3Normalize(from, out1);
            vec3Normalize(to, out2);
            var result = vec3Dot(out1, out2);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result) * 57.29578;
            math.pool.delete_vector3(out1);
            math.pool.delete_vector3(out1);
            return result;
        }
        math.vec3Angle = vec3Angle;
        function vec3Distance(a, b) {
            var out = math.pool.new_vector3();
            vec3Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);
            math.pool.delete_vector3(out);
            return result;
        }
        math.vec3Distance = vec3Distance;
        function vec3ClampLength(vector, maxLength, out) {
            var val = 0;
            val = vec3SqrLength(vector);
            if (val > maxLength * maxLength) {
                vec3Normalize(vector, out);
                vec3ScaleByNum(out, maxLength, out);
            }
            out.rawData.set(vector.rawData);
        }
        math.vec3ClampLength = vec3ClampLength;
        function vec3Min(lhs, rhs, out) {
            out.rawData[0] = Math.min(lhs.x, rhs.x);
            out.rawData[1] = Math.min(lhs.y, rhs.y);
            out.rawData[2] = Math.min(lhs.z, rhs.z);
        }
        math.vec3Min = vec3Min;
        function vec3Max(lhs, rhs, out) {
            out.rawData[0] = Math.max(lhs.x, rhs.x);
            out.rawData[1] = Math.max(lhs.y, rhs.y);
            out.rawData[2] = Math.max(lhs.z, rhs.z);
        }
        math.vec3Max = vec3Max;
        function vec3AngleBetween(from, to) {
            vec3Normalize(from, from);
            vec3Normalize(to, to);
            var result = vec3Dot(from, to);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result);
            return result;
        }
        math.vec3AngleBetween = vec3AngleBetween;
        function vec3Reset(out) {
            out.rawData[0] = 0;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
        }
        math.vec3Reset = vec3Reset;
        function vec3SLerp(vector, vector2, v, out) {
            out.rawData[0] = vector.x * (1 - v) + vector2.x * v;
            out.rawData[1] = vector.y * (1 - v) + vector2.y * v;
            out.rawData[2] = vector.z * (1 - v) + vector2.z * v;
        }
        math.vec3SLerp = vec3SLerp;
        function vec3SetByFloat(x, y, z, out) {
            out.rawData[0] = x;
            out.rawData[1] = y;
            out.rawData[2] = z;
        }
        math.vec3SetByFloat = vec3SetByFloat;
        function vec3Format(vector, maxDot, out) {
            out.rawData[0] = floatFormat(vector.x, maxDot);
            out.rawData[1] = floatFormat(vector.y, maxDot);
            out.rawData[2] = floatFormat(vector.z, maxDot);
        }
        math.vec3Format = vec3Format;
        function quaternionFormat(vector, maxDot, out) {
            out.rawData[0] = floatFormat(vector.x, maxDot);
            out.rawData[1] = floatFormat(vector.y, maxDot);
            out.rawData[2] = floatFormat(vector.z, maxDot);
            out.rawData[3] = floatFormat(vector.w, maxDot);
        }
        math.quaternionFormat = quaternionFormat;
        function floatFormat(num, maxDot) {
            var vv = Math.pow(10, maxDot);
            return Math.round(num * vv) / vv;
        }
        math.floatFormat = floatFormat;
        function vec3Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            if (Math.abs(vector.z - vector2.z) > threshold)
                return false;
            return true;
        }
        math.vec3Equal = vec3Equal;
        function vec3SetAll(vector, value) {
            vector.rawData[0] = value;
            vector.rawData[1] = value;
            vector.rawData[2] = value;
        }
        math.vec3SetAll = vec3SetAll;
        function vec3Set(vector, x, y, z) {
            vector.rawData[0] = x;
            vector.rawData[1] = y;
            vector.rawData[2] = z;
        }
        math.vec3Set = vec3Set;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec4Clone(from, to) {
            to.rawData[0] = from.rawData[0];
            to.rawData[1] = from.rawData[1];
            to.rawData[2] = from.rawData[2];
            to.rawData[3] = from.rawData[3];
        }
        math.vec4Clone = vec4Clone;
        function vec4SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
            out.w = vector.w * (1 - v) + vector2.w * v;
        }
        math.vec4SLerp = vec4SLerp;
        function vec4Add(a, b, out) {
            out.rawData[0] = a.rawData[0] + b.rawData[0];
            out.rawData[1] = a.rawData[1] + b.rawData[1];
            out.rawData[2] = a.rawData[2] + b.rawData[2];
            out.rawData[3] = a.rawData[3] + b.rawData[3];
        }
        math.vec4Add = vec4Add;
        function vec4ScaleByNum(from, scale, out) {
            out.rawData[0] = from.rawData[0] * scale;
            out.rawData[1] = from.rawData[1] * scale;
            out.rawData[2] = from.rawData[2] * scale;
            out.rawData[3] = from.rawData[3] * scale;
        }
        math.vec4ScaleByNum = vec4ScaleByNum;
        function vec4SetAll(vector, value) {
            vector.rawData[0] = value;
            vector.rawData[1] = value;
            vector.rawData[2] = value;
            vector.rawData[3] = value;
        }
        math.vec4SetAll = vec4SetAll;
        function vec4Set(vector, x, y, z, w) {
            vector.rawData[0] = x;
            vector.rawData[1] = y;
            vector.rawData[2] = z;
            vector.rawData[3] = w;
        }
        math.vec4Set = vec4Set;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var navVec3 = (function () {
            function navVec3() {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.realy = 0;
            }
            navVec3.prototype.clone = function () {
                var navVec = new navVec3();
                navVec.x = this.x;
                navVec.y = this.y;
                navVec.z = this.z;
                navVec.realy = this.realy;
                return navVec;
            };
            navVec3.DistAZ = function (start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                return Math.sqrt(num * num + num2 * num2);
            };
            navVec3.NormalAZ = function (start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                var num3 = Math.sqrt(num * num + num2 * num2);
                var navVec = new navVec3();
                navVec.x = num / num3;
                navVec.y = 0.0;
                navVec.z = num2 / num3;
                return navVec;
            };
            navVec3.Cross = function (start, end) {
                var navVec = new navVec3();
                navVec.x = start.y * end.z - start.z * end.y;
                navVec.y = start.z * end.x - start.x * end.z;
                navVec.z = start.x * end.y - start.y * end.x;
                return navVec;
            };
            navVec3.DotAZ = function (start, end) {
                return start.x * end.x + start.z * end.z;
            };
            navVec3.Angle = function (start, end) {
                var d = start.x * end.x + start.z * end.z;
                var navVec = navVec3.Cross(start, end);
                var num = Math.acos(d);
                var flag = navVec.y < 0.0;
                if (flag) {
                    num = -num;
                }
                return num;
            };
            navVec3.Border = function (start, end, dist) {
                var navVec = navVec3.NormalAZ(start, end);
                var navVec2 = new navVec3();
                navVec2.x = start.x + navVec.x * dist;
                navVec2.y = start.y + navVec.y * dist;
                navVec2.z = start.z + navVec.z * dist;
                if (end.x == start.x) {
                    navVec2.realy = start.y;
                }
                else {
                    navVec2.realy = start.y + navVec.x * (end.y - start.y) / (end.x - start.x);
                }
                return navVec2;
            };
            navVec3.lerp = function (from, to, lerp, out) {
                out.x = (to.x - from.x) * lerp + from.x;
                out.y = (to.y - from.y) * lerp + from.y;
                out.z = (to.z - from.z) * lerp + from.z;
            };
            return navVec3;
        }());
        framework.navVec3 = navVec3;
        var navNode = (function () {
            function navNode() {
                this.nodeID = 0;
                this.poly = null;
                this.borderByPoly = null;
                this.borderByPoint = null;
                this.center = null;
            }
            navNode.prototype.genBorder = function () {
                var list = [];
                for (var i = 0; i < this.poly.length; i = i + 1) {
                    var num = i;
                    var num2 = i + 1;
                    var flag = num2 >= this.poly.length;
                    if (flag) {
                        num2 = 0;
                    }
                    var num3 = this.poly[num];
                    var num4 = this.poly[num2];
                    var flag2 = num3 < num4;
                    if (flag2) {
                        list.push(num3 + "-" + num4);
                    }
                    else {
                        list.push(num4 + "-" + num3);
                    }
                }
                this.borderByPoint = list;
            };
            navNode.prototype.isLinkTo = function (info, nid) {
                var flag = this.nodeID === nid;
                var result;
                if (flag) {
                    result = null;
                }
                else {
                    var flag2 = nid < 0;
                    if (flag2) {
                        result = null;
                    }
                    else {
                        var array = this.borderByPoly;
                        for (var i = 0; i < array.length; i = i + 1) {
                            var text = array[i];
                            var flag3 = (info.borders[text] == undefined);
                            if (!flag3) {
                                var flag4 = info.borders[text].nodeA === nid || info.borders[text].nodeB === nid;
                                if (flag4) {
                                    result = text;
                                    return result;
                                }
                            }
                        }
                        result = null;
                    }
                }
                return result;
            };
            navNode.prototype.getLinked = function (info) {
                var list = [];
                var array = this.borderByPoly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var key = array[i];
                    var flag = (info.borders[key] == undefined);
                    if (!flag) {
                        var flag2 = info.borders[key].nodeA === this.nodeID;
                        var num;
                        if (flag2) {
                            num = info.borders[key].nodeB;
                        }
                        else {
                            num = info.borders[key].nodeA;
                        }
                        var flag3 = num >= 0;
                        if (flag3) {
                            list.push(num);
                        }
                    }
                }
                return list;
            };
            navNode.prototype.genCenter = function (info) {
                this.center = new navVec3();
                this.center.x = 0.0;
                this.center.y = 0.0;
                this.center.z = 0.0;
                var array = this.poly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var num = array[i];
                    this.center.x += info.vecs[num].x;
                    this.center.y += info.vecs[num].y;
                    this.center.z += info.vecs[num].z;
                }
                this.center.x /= this.poly.length;
                this.center.y /= this.poly.length;
                this.center.z /= this.poly.length;
            };
            return navNode;
        }());
        framework.navNode = navNode;
        var navBorder = (function () {
            function navBorder() {
                this.borderName = null;
                this.nodeA = 0;
                this.nodeB = 0;
                this.pointA = 0;
                this.pointB = 0;
                this.length = 0;
                this.center = null;
            }
            return navBorder;
        }());
        framework.navBorder = navBorder;
        var navMeshInfo = (function () {
            function navMeshInfo() {
                this.vecs = null;
                this.nodes = null;
                this.borders = null;
                this.min = null;
                this.max = null;
            }
            navMeshInfo.prototype.calcBound = function () {
                this.min = new navVec3();
                this.max = new navVec3();
                this.min.x = 1.7976931348623157E+308;
                this.min.y = 1.7976931348623157E+308;
                this.min.z = 1.7976931348623157E+308;
                this.max.x = -1.7976931348623157E+308;
                this.max.y = -1.7976931348623157E+308;
                this.max.z = -1.7976931348623157E+308;
                for (var i = 0; i < this.vecs.length; i = i + 1) {
                    var flag = this.vecs[i].x < this.min.x;
                    if (flag) {
                        this.min.x = this.vecs[i].x;
                    }
                    var flag2 = this.vecs[i].y < this.min.y;
                    if (flag2) {
                        this.min.y = this.vecs[i].y;
                    }
                    var flag3 = this.vecs[i].z < this.min.z;
                    if (flag3) {
                        this.min.z = this.vecs[i].z;
                    }
                    var flag4 = this.vecs[i].x > this.max.x;
                    if (flag4) {
                        this.max.x = this.vecs[i].x;
                    }
                    var flag5 = this.vecs[i].y > this.max.y;
                    if (flag5) {
                        this.max.y = this.vecs[i].y;
                    }
                    var flag6 = this.vecs[i].z > this.max.z;
                    if (flag6) {
                        this.max.z = this.vecs[i].z;
                    }
                }
            };
            navMeshInfo.cross = function (p0, p1, p2) {
                return (p1.x - p0.x) * (p2.z - p0.z) - (p2.x - p0.x) * (p1.z - p0.z);
            };
            navMeshInfo.prototype.inPoly = function (p, poly) {
                var num = 0;
                var flag = poly.length < 3;
                var result;
                if (flag) {
                    result = false;
                }
                else {
                    var flag2 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[1]]) < (-num);
                    if (flag2) {
                        result = false;
                    }
                    else {
                        var flag3 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[poly.length - 1]]) > num;
                        if (flag3) {
                            result = false;
                        }
                        else {
                            var i = 2;
                            var num2 = poly.length - 1;
                            var num3 = -1;
                            while (i <= num2) {
                                var num4 = i + num2 >> 1;
                                var flag4 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[num4]]) < (-num);
                                if (flag4) {
                                    num3 = num4;
                                    num2 = num4 - 1;
                                }
                                else {
                                    i = num4 + 1;
                                }
                            }
                            var num5 = navMeshInfo.cross(this.vecs[poly[num3 - 1]], p, this.vecs[poly[num3]]);
                            result = (num5 > num);
                        }
                    }
                }
                return result;
            };
            navMeshInfo.prototype.genBorder = function () {
                var __border = {};
                for (var i0 = 0; i0 < this.nodes.length; i0 = i0 + 1) {
                    var n = this.nodes[i0];
                    for (var i1 = 0; i1 < n.borderByPoint.length; i1 = i1 + 1) {
                        var b = n.borderByPoint[i1];
                        if (__border[b] == undefined) {
                            __border[b] = new navBorder();
                            __border[b].borderName = b;
                            __border[b].nodeA = n.nodeID;
                            __border[b].nodeB = -1;
                            __border[b].pointA = -1;
                        }
                        else {
                            __border[b].nodeB = n.nodeID;
                            if (__border[b].nodeA > __border[b].nodeB) {
                                __border[b].nodeB = __border[b].nodeA;
                                __border[b].nodeB = n.nodeID;
                            }
                            var na = this.nodes[__border[b].nodeA];
                            var nb = this.nodes[__border[b].nodeB];
                            for (var i2 = 0; i2 < na.poly.length; i2 = i2 + 1) {
                                var i = na.poly[i2];
                                if (nb.poly.indexOf(i) >= 0) {
                                    if (__border[b].pointA == -1)
                                        __border[b].pointA = i;
                                    else
                                        __border[b].pointB = i;
                                }
                            }
                            var left = __border[b].pointA;
                            var right = __border[b].pointB;
                            var xd = this.vecs[left].x - this.vecs[right].x;
                            var yd = this.vecs[left].y - this.vecs[right].y;
                            var zd = this.vecs[left].z - this.vecs[right].z;
                            __border[b].length = Math.sqrt(xd * xd + yd * yd + zd * zd);
                            __border[b].center = new navVec3();
                            __border[b].center.x = this.vecs[left].x * 0.5 + this.vecs[right].x * 0.5;
                            __border[b].center.y = this.vecs[left].y * 0.5 + this.vecs[right].y * 0.5;
                            __border[b].center.z = this.vecs[left].z * 0.5 + this.vecs[right].z * 0.5;
                            __border[b].borderName = __border[b].nodeA + "-" + __border[b].nodeB;
                        }
                    }
                }
                var namechange = {};
                for (var key in __border) {
                    if (__border[key].nodeB < 0) {
                    }
                    else {
                        namechange[key] = __border[key].borderName;
                    }
                }
                this.borders = {};
                for (var key in __border) {
                    if (namechange[key] != undefined) {
                        this.borders[namechange[key]] = __border[key];
                    }
                }
                for (var m = 0; m < this.nodes.length; m = m + 1) {
                    var v = this.nodes[m];
                    var newborder = [];
                    for (var nnn = 0; nnn < v.borderByPoint.length; nnn = nnn + 1) {
                        var b = v.borderByPoint[nnn];
                        if (namechange[b] != undefined) {
                            newborder.push(namechange[b]);
                        }
                    }
                    v.borderByPoly = newborder;
                }
            };
            navMeshInfo.LoadMeshInfo = function (s) {
                var j = JSON.parse(s);
                var info = new navMeshInfo();
                var listVec = [];
                for (var jsonid in j["v"]) {
                    var v3 = new navVec3();
                    v3.x = j["v"][jsonid][0];
                    v3.y = j["v"][jsonid][1];
                    v3.z = j["v"][jsonid][2];
                    listVec.push(v3);
                }
                info.vecs = listVec;
                var polys = [];
                var list = j["p"];
                for (var i = 0; i < list.length; i++) {
                    var json = list[i];
                    var node = new navNode();
                    node.nodeID = i;
                    var poly = [];
                    for (var tt in json) {
                        poly.push(json[tt]);
                    }
                    node.poly = poly;
                    node.genBorder();
                    node.genCenter(info);
                    polys.push(node);
                }
                info.nodes = polys;
                info.calcBound();
                info.genBorder();
                return info;
            };
            return navMeshInfo;
        }());
        framework.navMeshInfo = navMeshInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NavMeshLoadManager = (function () {
            function NavMeshLoadManager() {
                this.navMeshVertexOffset = new gd3d.math.vector3(0, 0, 0);
                this._navmeshJson = "";
            }
            Object.defineProperty(NavMeshLoadManager.prototype, "navmeshJson", {
                get: function () { return this._navmeshJson; },
                enumerable: true,
                configurable: true
            });
            NavMeshLoadManager.prototype.loadNavMesh = function (navMeshUrl, app, onstate) {
                var _this = this;
                if (!app)
                    return;
                this.app = app;
                if (this.navTrans)
                    this.navTrans.parent.removeChild(this.navTrans);
                app.getAssetMgr().load(navMeshUrl, gd3d.framework.AssetTypeEnum.Auto, function (s) {
                    if (s.isfinish) {
                        var data = app.getAssetMgr().getAssetByName(navMeshUrl.substring(navMeshUrl.lastIndexOf("/") + 1));
                        _this.navmeshLoaded(data.content, function () {
                            if (onstate) {
                                onstate(s);
                            }
                        });
                    }
                    else if (s.iserror) {
                        if (onstate) {
                            onstate(s);
                        }
                    }
                });
            };
            NavMeshLoadManager.prototype.loadNavMeshByDate = function (dataStr, app, callback) {
                if (!app)
                    return;
                this.app = app;
                this.navmeshLoaded(dataStr, callback);
            };
            NavMeshLoadManager.prototype.navmeshLoaded = function (dataStr, callback) {
                console.warn("navmeshLoaded");
                if (dataStr == null || dataStr == "")
                    return;
                this._navmeshJson = dataStr;
                if (this.navTrans != null) {
                    if (this.navTrans.parent)
                        this.navTrans.parent.removeChild(this.navTrans);
                    this.navTrans.dispose();
                }
                this.navTrans = new gd3d.framework.transform();
                this.navTrans.name = "navMesh";
                var HF = gd3d.framework.HideFlags;
                this.navTrans.gameObject.hideFlags = HF.HideInHierarchy | HF.DontSave | HF.NotEditable;
                var meshD = new gd3d.render.meshData();
                meshD.pos = [];
                meshD.trisindex = [];
                var navinfo = gd3d.framework.navMeshInfo.LoadMeshInfo(dataStr);
                for (var i = 0; i < navinfo.vecs.length; i++) {
                    var v = navinfo.vecs[i];
                    var X = v.x - this.navMeshVertexOffset.x;
                    var Y = v.y - this.navMeshVertexOffset.y;
                    var Z = v.z - this.navMeshVertexOffset.z;
                    meshD.pos[i] = new gd3d.math.vector3(X, Y, Z);
                }
                var navindexmap = {};
                var indexDatas = [];
                for (var i = 0; i < navinfo.nodes.length; i++) {
                    var poly = navinfo.nodes[i].poly;
                    for (var fc = 0; fc < poly.length - 2; fc++) {
                        var sindex = indexDatas.length / 3;
                        navindexmap[sindex] = i;
                        indexDatas.push(poly[0]);
                        indexDatas.push(poly[fc + 2]);
                        indexDatas.push(poly[fc + 1]);
                    }
                }
                meshD.trisindex = indexDatas;
                var meshFiter = this.navTrans.gameObject.addComponent("meshFilter");
                this.navMesh = this.createMesh(meshD, this.app.webgl);
                meshFiter.mesh = this.navMesh;
                this.app.getScene().addChild(this.navTrans);
                this.navTrans.markDirty();
                this.navigate = new gd3d.framework.Navigate(navinfo, navindexmap);
                callback();
            };
            NavMeshLoadManager.prototype.createMesh = function (meshData, webgl) {
                var _mesh = new gd3d.framework.mesh();
                _mesh.data = meshData;
                var vf = gd3d.render.VertexFormatMask.Position;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new gd3d.framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            NavMeshLoadManager.prototype.showNavmesh = function (isshow, material) {
                if (material === void 0) { material = null; }
                if (this.navTrans) {
                    this.navTrans.gameObject.visible = isshow;
                    if (!isshow) {
                        this.navTrans.localTranslate = new gd3d.math.vector3(0, 0, 0);
                        this.navTrans.markDirty();
                        return;
                    }
                    var compent = this.navTrans.gameObject.getComponent("meshRenderer");
                    if (compent == null) {
                        compent = this.navTrans.gameObject.addComponent("meshRenderer");
                        if (material) {
                            compent.materials = [];
                            compent.materials[0] = material;
                        }
                    }
                    this.navTrans.localTranslate = new gd3d.math.vector3(0, 0, 0);
                    this.navTrans.markDirty();
                }
            };
            NavMeshLoadManager.prototype.dispose = function () {
                if (this.navTrans) {
                    this.navTrans.parent.removeChild(this.navTrans);
                    this.navTrans.dispose();
                    this.navTrans = null;
                    this.navMesh.dispose();
                    this.navMesh = null;
                    this.navigate.dispose();
                    this.navigate = null;
                }
            };
            Object.defineProperty(NavMeshLoadManager, "Instance", {
                get: function () {
                    if (NavMeshLoadManager._instance == null)
                        NavMeshLoadManager._instance = new NavMeshLoadManager();
                    return NavMeshLoadManager._instance;
                },
                enumerable: true,
                configurable: true
            });
            NavMeshLoadManager.prototype.moveToPoints = function (startPos, endPos) {
                var navTrans = NavMeshLoadManager.Instance.navTrans;
                var nav = NavMeshLoadManager.Instance.navigate;
                if (!nav)
                    return;
                var StratIndex = NavMeshLoadManager.findtriIndex(startPos, navTrans);
                if (StratIndex == undefined) {
                    var dir = new gd3d.math.vector3();
                    var direc = new gd3d.math.vector3();
                    gd3d.math.vec3Subtract(endPos, startPos, dir);
                    gd3d.math.vec3Normalize(dir, dir);
                    for (var i = 0; i < 5; i++) {
                        gd3d.math.vec3Clone(dir, direc);
                        gd3d.math.vec3ScaleByNum(direc, (i + 1) * 2, direc);
                        var pos = new gd3d.math.vector3();
                        gd3d.math.vec3Add(startPos, direc, pos);
                        StratIndex = NavMeshLoadManager.findtriIndex(pos, navTrans);
                        if (StratIndex != undefined)
                            break;
                    }
                }
                var endIndex = NavMeshLoadManager.findtriIndex(endPos, navTrans);
                var points = nav.pathPoints(startPos, endPos, StratIndex, endIndex);
                return points;
            };
            NavMeshLoadManager.findtriIndex = function (point, trans) {
                var result = -1;
                var ray = new gd3d.framework.ray(new gd3d.math.vector3(point.x, point.y + 500, point.z), new gd3d.math.vector3(0, -1, 0));
                var mesh;
                var meshFilter = trans.gameObject.getComponent("meshFilter");
                if (meshFilter != null) {
                    mesh = meshFilter.getMeshOutput();
                }
                if (!mesh)
                    return;
                var tempInfo = gd3d.math.pool.new_pickInfo();
                if (mesh.intersects(ray, trans.getWorldMatrix(), tempInfo))
                    result = tempInfo.faceId;
                gd3d.math.pool.delete_pickInfo(tempInfo);
                return result;
            };
            return NavMeshLoadManager;
        }());
        framework.NavMeshLoadManager = NavMeshLoadManager;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Navigate = (function () {
            function Navigate(navinfo, navindexmap) {
                this.navinfo = navinfo;
                this.navindexmap = navindexmap;
            }
            Navigate.prototype.pathPoints = function (start, end, startIndex, endIndex) {
                var startVec = new framework.navVec3();
                startVec.x = start.x;
                startVec.y = start.y;
                startVec.z = start.z;
                var endVec = new framework.navVec3();
                endVec.x = end.x;
                endVec.y = end.y;
                endVec.z = end.z;
                var startPoly = this.navindexmap[startIndex];
                var endPoly = this.navindexmap[endIndex];
                if (startPoly >= 0 && endPoly >= 0) {
                    var polyPath = gd3d.framework.pathFinding.calcAStarPolyPath(this.navinfo, startPoly, endPoly, endVec, 0.3);
                }
                if (polyPath) {
                    var wayPoints = gd3d.framework.pathFinding.calcWayPoints(this.navinfo, startVec, endVec, polyPath);
                    var navmeshWayPoints = [];
                    for (var i = 0; i < wayPoints.length; i++) {
                        navmeshWayPoints[i] = new gd3d.math.vector3(wayPoints[i].x, wayPoints[i].realy, wayPoints[i].z);
                    }
                    return navmeshWayPoints;
                }
                else {
                    return null;
                }
            };
            Navigate.prototype.dispose = function () {
                this.navinfo = null;
                this.navindexmap = null;
            };
            return Navigate;
        }());
        framework.Navigate = Navigate;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var FindNode = (function () {
            function FindNode() {
                this.nodeid = 0;
                this.pathSessionId = 0;
                this.ParentID = -1;
                this.Open = false;
                this.HValue = 0;
                this.GValue = 0;
                this.ArrivalWall = 0;
            }
            FindNode.prototype.CalcHeuristic = function (info, endPos) {
                var center = info.nodes[this.nodeid].center;
                var num = Math.abs(center.x - endPos.x);
                var num2 = Math.abs(center.z - endPos.z);
                this.HValue = Math.sqrt(num * num + num2 * num2);
            };
            FindNode.prototype.GetCost = function (info, neighborID) {
                var bc = info.nodes[neighborID].center;
                var nc = info.nodes[this.nodeid].center;
                var xd = bc.x - nc.x;
                var yd = bc.y - nc.y;
                var zd = bc.z - nc.z;
                var d = Math.sqrt(xd * xd + yd * yd + zd * zd);
                return d;
            };
            return FindNode;
        }());
        var pathFinding = (function () {
            function pathFinding() {
            }
            pathFinding.calcAStarPolyPath = function (info, startPoly, endPoly, endPos, offset) {
                if (endPos === void 0) { endPos = null; }
                if (offset === void 0) { offset = 0.1; }
                var nodeFind = [];
                var nodes = info.nodes;
                for (var i = 0; i < nodes.length; i = i + 1) {
                    var navNode = nodes[i];
                    var findNode = new FindNode();
                    findNode.nodeid = navNode.nodeID;
                    nodeFind.push(findNode);
                }
                var flag = endPos === null;
                if (flag) {
                    endPos = info.nodes[endPoly].center.clone();
                }
                var findNode2 = nodeFind[startPoly];
                findNode2.nodeid = startPoly;
                var num = 1;
                var flag2 = false;
                var openList = [];
                var list2 = [];
                findNode2.pathSessionId = num;
                openList.push(startPoly);
                var sortfun = function (x, y) {
                    var xFvalue = nodeFind[x].HValue + nodeFind[x].GValue;
                    var yFvalue = nodeFind[y].HValue + nodeFind[y].GValue;
                    if (xFvalue < yFvalue - 0.001)
                        return 1;
                    if (xFvalue > yFvalue + 0.001)
                        return -1;
                    return 0;
                };
                while (openList.length > 0) {
                    var findNode3 = nodeFind[openList[openList.length - 1]];
                    openList.splice(openList.length - 1, 1);
                    list2.push(findNode3.nodeid);
                    var flag3 = findNode3.nodeid === endPoly;
                    if (flag3) {
                        flag2 = true;
                        break;
                    }
                    var linked = info.nodes[findNode3.nodeid].getLinked(info);
                    for (var j = 0; j < linked.length; j = j + 1) {
                        var num2 = linked[j];
                        var flag4 = num2 < 0;
                        if (!flag4) {
                            var findNode4 = nodeFind[num2];
                            var flag5 = findNode4 === null || findNode4.nodeid !== num2;
                            if (flag5) {
                                return null;
                            }
                            var flag6 = findNode4.pathSessionId !== num;
                            if (flag6) {
                                var text = info.nodes[findNode4.nodeid].isLinkTo(info, findNode3.nodeid);
                                var flag7 = text !== null && info.borders[text].length >= offset * 2;
                                if (flag7) {
                                    findNode4.pathSessionId = num;
                                    findNode4.ParentID = findNode3.nodeid;
                                    findNode4.Open = true;
                                    findNode4.CalcHeuristic(info, endPos);
                                    findNode4.GValue = findNode3.GValue + findNode3.GetCost(info, findNode4.nodeid);
                                    openList.push(findNode4.nodeid);
                                    openList.sort(sortfun);
                                    findNode4.ArrivalWall = findNode3.nodeid;
                                }
                            }
                            else {
                                var open = findNode4.Open;
                                if (open) {
                                    var flag8 = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid) < findNode3.GValue;
                                    if (flag8) {
                                        findNode3.GValue = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid);
                                        findNode3.ParentID = findNode4.nodeid;
                                        findNode3.ArrivalWall = findNode4.nodeid;
                                    }
                                }
                            }
                        }
                    }
                }
                var list3 = [];
                var flag9 = list2.length > 0;
                if (flag9) {
                    var findNode5 = nodeFind[list2[list2.length - 1]];
                    list3.push(findNode5.nodeid);
                    while (findNode5.ParentID !== -1) {
                        list3.push(findNode5.ParentID);
                        findNode5 = nodeFind[findNode5.ParentID];
                    }
                }
                return list3;
            };
            pathFinding.NearAngle = function (a, b) {
                var num = a;
                var flag = a >= 180.0;
                if (flag) {
                    num = 360.0 - a;
                }
                var num2 = b;
                var flag2 = b >= 180.0;
                if (flag2) {
                    num2 = 360.0 - b;
                }
                var flag3 = num < num2;
                var result;
                if (flag3) {
                    result = a;
                }
                else {
                    result = b;
                }
                return result;
            };
            pathFinding.FindPath = function (info, startPos, endPos, offset) {
                if (offset === void 0) { offset = 0.1; }
                var startPoly = -1;
                var endPoly = -1;
                for (var i = 0; i < info.nodes.length; i = i + 1) {
                    var flag = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag) {
                        startPoly = i;
                    }
                    var flag2 = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag2) {
                        endPoly = i;
                    }
                }
                var polyPath = pathFinding.calcAStarPolyPath(info, startPoly, endPoly, endPos, offset);
                return pathFinding.calcWayPoints(info, startPos, endPos, polyPath, offset);
            };
            pathFinding.calcWayPoints = function (info, startPos, endPos, polyPath, offset) {
                if (offset === void 0) { offset = 0.1; }
                var wayPoints = [];
                if (polyPath.length == 0 || startPos == null || endPos == null) {
                    return null;
                }
                var lastPoint = startPos;
                var groupborder = [];
                var triPathList = polyPath.reverse();
                startPos.realy = startPos.y;
                endPos.realy = endPos.y;
                wayPoints.push(startPos);
                var ipoly = 0;
                var dirLeft = null;
                var ipolyLeft = -1;
                var dirRight = null;
                var ipolyRight = -1;
                var breakDir = 0;
                var posLeft = null;
                var posRight = null;
                var posNow = startPos.clone();
                for (var c = 0; c < 100; c++) {
                    for (var i = ipoly; i < triPathList.length; i++) {
                        if (i === triPathList.length - 1) {
                            if (dirLeft == null || dirRight == null) {
                                breakDir = 0;
                                break;
                            }
                            else {
                                var dirFinal = gd3d.framework.navVec3.NormalAZ(posNow, endPos);
                                var a1 = gd3d.framework.navVec3.Angle(dirLeft, dirFinal);
                                var b1 = gd3d.framework.navVec3.Angle(dirRight, dirFinal);
                                var flag4 = a1 * b1 > 0.0;
                                if (a1 * b1 > 0.0) {
                                    if (a1 > 0.0) {
                                        breakDir = 1;
                                    }
                                    else {
                                        breakDir = -1;
                                    }
                                }
                                else {
                                    breakDir = 0;
                                    break;
                                }
                            }
                        }
                        else {
                            var n1 = triPathList[i];
                            var n2 = triPathList[i + 1];
                            var bname = n1 + "-" + n2;
                            if (n2 < n1) {
                                bname = n2 + "-" + n1;
                            }
                            var border = info.borders[bname];
                            var pointA = gd3d.framework.navVec3.Border(info.vecs[border.pointA], info.vecs[border.pointB], offset);
                            var pointB = gd3d.framework.navVec3.Border(info.vecs[border.pointB], info.vecs[border.pointA], offset);
                            var dist1 = gd3d.framework.navVec3.DistAZ(posNow, pointA);
                            var dist2 = gd3d.framework.navVec3.DistAZ(posNow, pointB);
                            if (dist1 < 0.001 || dist2 < 0.001) {
                                continue;
                            }
                            if (dirLeft == null) {
                                dirLeft = gd3d.framework.navVec3.NormalAZ(posNow, pointA);
                                posLeft = pointA.clone();
                                ipolyLeft = i;
                            }
                            if (dirRight == null) {
                                dirRight = gd3d.framework.navVec3.NormalAZ(posNow, pointB);
                                posRight = pointB.clone();
                                ipolyRight = i;
                            }
                            var adir = gd3d.framework.navVec3.Angle(dirLeft, dirRight);
                            if (adir < 0.0) {
                                var navVec7 = dirLeft;
                                var navVec8 = posLeft;
                                var num12 = ipolyLeft;
                                dirLeft = dirRight;
                                posLeft = posRight;
                                ipolyLeft = ipolyRight;
                                dirRight = navVec7;
                                posRight = navVec8;
                                ipolyRight = num12;
                            }
                            if (ipolyLeft != i || ipolyRight != i) {
                                var ndirLeft = gd3d.framework.navVec3.NormalAZ(posNow, pointA);
                                var ndirRight = gd3d.framework.navVec3.NormalAZ(posNow, pointB);
                                var nadir = gd3d.framework.navVec3.Angle(ndirLeft, ndirRight);
                                if (nadir < 0.0) {
                                    var navVec11 = ndirLeft;
                                    var navVec12 = pointA;
                                    ndirLeft = ndirRight;
                                    pointA = pointB;
                                    ndirRight = navVec11;
                                    pointB = navVec12;
                                }
                                var aLL = gd3d.framework.navVec3.Angle(dirLeft, ndirLeft);
                                var aRL = gd3d.framework.navVec3.Angle(dirRight, ndirLeft);
                                var aLR = gd3d.framework.navVec3.Angle(dirLeft, ndirRight);
                                var aRR = gd3d.framework.navVec3.Angle(dirRight, ndirRight);
                                if ((aLL < 0 && aLR < 0)) {
                                    breakDir = -1;
                                    break;
                                }
                                if (aRL > 0.0 && aRR > 0.0) {
                                    breakDir = 1;
                                    break;
                                }
                                if (aLL > 0.0 && aRL < 0.0) {
                                    dirLeft = ndirLeft;
                                    posLeft = pointA;
                                    ipolyLeft = i;
                                }
                                if (aLR > 0.0 && aRR < 0.0) {
                                    dirRight = ndirRight;
                                    posRight = pointB;
                                    ipolyRight = i;
                                }
                            }
                        }
                    }
                    if (breakDir == 0) {
                        break;
                    }
                    else {
                        if (breakDir == -1) {
                            wayPoints.push(posLeft.clone());
                            posNow = posLeft;
                            ipoly = ipolyLeft;
                        }
                        else {
                            wayPoints.push(posRight.clone());
                            posNow = posRight;
                            ipoly = ipolyRight;
                        }
                        dirLeft = null;
                        dirRight = null;
                        ipolyLeft = -1;
                        ipolyRight = -1;
                    }
                }
                wayPoints.push(endPos);
                return wayPoints;
            };
            pathFinding.intersectBorder = function (a, b, c, d) {
                var nx1 = (b.z - a.z), ny1 = (a.x - b.x);
                var nx2 = (d.z - c.z), ny2 = (c.x - d.x);
                var denominator = nx1 * ny2 - ny1 * nx2;
                if (denominator == 0) {
                    return null;
                }
                var distC_N2 = nx2 * c.x + ny2 * c.z;
                var distA_N2 = nx2 * a.x + ny2 * a.z - distC_N2;
                var distB_N2 = nx2 * b.x + ny2 * b.z - distC_N2;
                if (distA_N2 * distB_N2 >= 0) {
                    return null;
                }
                var distA_N1 = nx1 * a.x + ny1 * a.z;
                var distC_N1 = nx1 * c.x + ny1 * c.z - distA_N1;
                var distD_N1 = nx1 * d.x + ny1 * d.z - distA_N1;
                if (distC_N1 * distD_N1 >= 0) {
                    return null;
                }
                var fraction = distA_N2 / denominator;
                var dx = fraction * ny1, dz = -fraction * nx1;
                var newpoint = new framework.navVec3();
                framework.navVec3.lerp(a, b, -fraction, newpoint);
                return newpoint;
            };
            return pathFinding;
        }());
        framework.pathFinding = pathFinding;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RVOManager = (function () {
            function RVOManager() {
                this.sim = new RVO.Simulator(1, 60, 20, 20, 5, 1.0, 0.1, [0, 0]);
                this.transforms = [];
                this.goals = [];
                this.radius = [];
                this.attackRanges = [];
                this.speeds = [];
                this.map = {};
                this.isRunning = false;
                this.currMoveDir = new gd3d.math.vector2();
                this._RoadPoints = [];
            }
            RVOManager.prototype.setRoadPoints = function (goalQueue) {
                var _this = this;
                if (!goalQueue || goalQueue.length < 1)
                    return;
                this._RoadPoints.forEach(function (sub) {
                    if (sub && sub != _this.lastGoal)
                        gd3d.math.pool.delete_vector3(sub);
                });
                this._RoadPoints.length = 0;
                for (var i = 0; i < goalQueue.length; i++) {
                    var v3 = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(goalQueue[i], v3);
                    this._RoadPoints.push(v3);
                }
                this.currGoal = this._RoadPoints.pop();
                this.goals[0][0] = this.currGoal.x;
                this.goals[0][1] = this.currGoal.z;
            };
            RVOManager.prototype.addAgent = function (key, transform, radius, attackRanges, speed) {
                var index = this.sim.agents.length;
                var current_position = [transform.localTranslate.x, transform.localTranslate.z];
                this.transforms.push(transform);
                this.attackRanges.push(attackRanges);
                this.radius.push(radius);
                this.speeds.push(speed);
                this.goals.push(current_position);
                this.sim.addAgent(current_position);
                this.sim.agents[index].id = key;
                this.sim.agents[index].radius = radius;
                this.sim.agents[index].maxSpeed = speed;
                this.map[key] = index;
                if (index == 0) {
                    this.sim.agents[0].neighborDist = 0;
                }
                this.isRunning = true;
            };
            RVOManager.prototype.removeAgent = function (key) {
                var offset = this.map[key];
                this.transforms.splice(offset, 1);
                this.attackRanges.splice(offset, 1);
                this.radius.splice(offset, 1);
                this.speeds.splice(offset, 1);
                this.goals.splice(offset, 1);
                this.sim.agents.splice(offset, 1);
                this.reBuildHashMap();
            };
            RVOManager.prototype.reBuildHashMap = function () {
                for (var i = 0; i < this.sim.agents.length; i++) {
                    this.map[this.sim.agents[i].id] = i;
                }
                this.sim.kdTree.agents = [];
                this.sim.kdTree.agentTree = [];
                this.sim.kdTree.obstacleTree = 0;
            };
            RVOManager.prototype.getTransformByKey = function (key) {
                var offset = this.map[key];
                return this.transforms[offset];
            };
            RVOManager.prototype.setRadius = function (id, value) {
                var i = this.map[id];
                this.sim.agents[i].radius = value;
            };
            RVOManager.prototype.setSpeed = function (id, value) {
                var i = this.map[id];
                this.sim.agents[i].maxSpeed = value;
            };
            RVOManager.prototype.setAttackRange = function (id, value) {
                var i = this.map[id];
                this.attackRanges[i] = value;
            };
            RVOManager.prototype.disable = function () {
                this.isRunning = false;
            };
            RVOManager.prototype.enable = function () {
                this.isRunning = true;
                for (var i in this.transforms) {
                    this.sim.agents[i].position = [this.transforms[i].localTranslate.x, this.transforms[i].localTranslate.z];
                }
            };
            RVOManager.prototype.update = function () {
                if (this.isRunning && (this.transforms.length >= 1)) {
                    this.RVO_check(this.sim, this.goals);
                    this.RVO_walking(this.sim, this.goals);
                    this.updateTransform(this.sim);
                }
            };
            RVOManager.prototype.isAlmostStatic = function () {
                var threshold = 0.1;
                var amount = 0;
                for (var i = 0; i < this.sim.agents.length; i++) {
                    if (this.sim.agents[i].prefVelocity != null) {
                        if (this.sim.agents[i].prefVelocity[0] < 0.01 && this.sim.agents[i].prefVelocity[1] < 0.01) {
                            amount++;
                        }
                    }
                }
                if (amount / this.sim.agents.length >= threshold) {
                    return true;
                }
                return false;
            };
            RVOManager.prototype.RVO_walking = function (sim, goals) {
                for (var i = 0, len = sim.agents.length; i < len; i++) {
                    if (sim.agents[i] != null) {
                        var goalVector = RVO.Vector.subtract(goals[i], sim.agents[i].position);
                        if (RVO.Vector.absSq(goalVector) > 1) {
                            goalVector = RVO.Vector.normalize(goalVector);
                        }
                        sim.agents[i].prefVelocity = goalVector;
                    }
                }
                sim.doStep();
            };
            RVOManager.prototype.updateTransform = function (sim) {
                for (var i = 0; i < sim.agents.length; i++) {
                    this.transforms[i].localTranslate.x = sim.agents[i].position[0];
                    this.transforms[i].localTranslate.z = sim.agents[i].position[1];
                    if (i == 0 && this.currGoal && this.lastGoal) {
                        var pos = this.transforms[i].localTranslate;
                        var nowDir = gd3d.math.pool.new_vector2();
                        this.cal2dDir(this.lastGoal, pos, nowDir);
                        var nowLen = gd3d.math.vec2Length(nowDir);
                        var tLen = gd3d.math.vec2Length(this.currMoveDir);
                        var y = gd3d.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        if (!isNaN(y)) {
                            pos.y = gd3d.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        }
                        gd3d.math.pool.delete_vector2(nowDir);
                    }
                    this.transforms[i].markDirty();
                }
            };
            RVOManager.prototype.RVO_check = function (sim, goals) {
                if (this.currGoal) {
                    var player = this.transforms[0];
                    var v2_0 = gd3d.math.pool.new_vector2();
                    v2_0.x = player.localTranslate.x;
                    v2_0.y = player.localTranslate.z;
                    var v2_1 = gd3d.math.pool.new_vector2();
                    v2_1.x = this.currGoal.x;
                    v2_1.y = this.currGoal.z;
                    var dis = gd3d.math.vec2Distance(v2_0, v2_1);
                    if (dis < 0.01) {
                        if (this.currGoal) {
                            if (this.lastGoal)
                                gd3d.math.pool.delete_vector3(this.lastGoal);
                            this.lastGoal = this.currGoal;
                            this.currGoal = null;
                            goals[0] = sim.agents[0].position;
                            sim.agents[0].radius = this.radius[0];
                        }
                        if (this._RoadPoints && this._RoadPoints.length > 0) {
                            this.currGoal = this._RoadPoints.pop();
                            this.cal2dDir(this.lastGoal, this.currGoal, this.currMoveDir);
                            goals[0] = [this.currGoal.x, this.currGoal.z];
                            sim.agents[0].radius = 0.1;
                        }
                    }
                }
                else if (this._RoadPoints && this._RoadPoints.length > 0) {
                    this.currGoal = this._RoadPoints.pop();
                    goals[0] = [this.currGoal.x, this.currGoal.z];
                    sim.agents[0].radius = 0.1;
                }
                for (var i = 1, len = sim.agents.length; i < len; i++) {
                    var range = RVO.Vector.absSq(RVO.Vector.subtract(sim.agents[i].position, sim.agents[0].position));
                    if (range < this.attackRanges[i]) {
                        goals[i] = sim.agents[i].position;
                        sim.agents[i].neighborDist = 0;
                    }
                    else {
                        goals[i] = sim.agents[0].position;
                        sim.agents[i].neighborDist = sim.agentDefaults.neighborDist;
                    }
                }
            };
            RVOManager.prototype.cal2dDir = function (oPos, tPos, out) {
                if (!oPos || !tPos || !out)
                    return;
                var ov2 = gd3d.math.pool.new_vector2();
                ov2.x = oPos.x;
                ov2.y = oPos.z;
                var tv2 = gd3d.math.pool.new_vector2();
                tv2.x = tPos.x;
                tv2.y = tPos.z;
                gd3d.math.vec2Subtract(tv2, ov2, out);
                gd3d.math.pool.delete_vector2(ov2);
                gd3d.math.pool.delete_vector2(tv2);
            };
            return RVOManager;
        }());
        framework.RVOManager = RVOManager;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectSystemData = (function () {
            function EffectSystemData() {
                this.beLoop = false;
                this.elementDic = {};
            }
            EffectSystemData.prototype.clone = function () {
                var data = new EffectSystemData();
                data.life = this.life;
                data.beLoop = this.beLoop;
                for (var key in this.elementDic) {
                    data.elementDic[key] = this.elementDic[key].clone();
                }
                return data;
            };
            EffectSystemData.prototype.dispose = function () {
                for (var key in this.elementDic) {
                    this.elementDic[key].dispose();
                    delete this.elementDic[key];
                }
            };
            return EffectSystemData;
        }());
        framework.EffectSystemData = EffectSystemData;
        var EffectElement = (function () {
            function EffectElement(_data) {
                this.startVboIndex = 0;
                this.startEboIndex = 0;
                this.endEboIndex = 0;
                this.delayTime = 0;
                this.actionActive = false;
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.data = _data;
                this.name = this.data.name;
                this.timelineFrame = {};
                this.delayTime = _data.delayTime;
                this.initActions();
                this.recordElementLerpAttributes();
            }
            EffectElement.prototype.recordElementLerpAttributes = function () {
                if (this.data.timelineFrame != undefined) {
                    for (var i in this.data.timelineFrame) {
                        var frameData = this.data.timelineFrame[i];
                        if (frameData.frameIndex != -1) {
                            if (frameData.lerpDatas != undefined && frameData.lerpDatas.length != 0) {
                                this.recordLerpValues(frameData);
                            }
                            else if (frameData.attrsData != undefined) {
                                if (this.timelineFrame[frameData.frameIndex] == undefined) {
                                    this.timelineFrame[frameData.frameIndex] = new EffectFrameData();
                                    this.timelineFrame[frameData.frameIndex].attrsData = new EffectAttrsData();
                                    this.timelineFrame[frameData.frameIndex].frameIndex = frameData.frameIndex;
                                }
                                for (var k in frameData.attrsData) {
                                    this.timelineFrame[frameData.frameIndex].attrsData.setLerpAttribute(k, frameData.attrsData.getAttribute(k));
                                }
                            }
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerpValues = function (effectFrameData) {
                for (var i in effectFrameData.lerpDatas) {
                    if (effectFrameData.lerpDatas[i].type == EffectLerpTypeEnum.Linear) {
                        for (var key in effectFrameData.lerpDatas[i].attrsList) {
                            var attrname = effectFrameData.lerpDatas[i].attrsList[key];
                            this.recordLerp(effectFrameData, effectFrameData.lerpDatas[i], attrname);
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerp = function (effectFrameData, lerpData, key) {
                var fromFrame = lerpData.fromFrame;
                var toFrame = lerpData.toFrame.getValue();
                var toVal = lerpData.attrsData.getAttribute(key);
                if (effectFrameData.attrsData[key] == undefined) {
                    effectFrameData.attrsData.initAttribute(key);
                }
                var fromVal = effectFrameData.attrsData.getAttribute(key);
                for (var i = fromFrame + 1; i <= toFrame; i++) {
                    var outVal = void 0;
                    if (fromVal instanceof gd3d.math.vector3) {
                        outVal = new gd3d.math.vector3();
                        gd3d.math.vec3SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (fromVal instanceof gd3d.math.vector2) {
                        outVal = new gd3d.math.vector2();
                        gd3d.math.vec2SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (typeof (fromVal) === 'number') {
                        outVal = gd3d.math.numberLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame));
                    }
                    var newFrameData = this.timelineFrame[i];
                    if (newFrameData == undefined) {
                        newFrameData = new EffectFrameData();
                        newFrameData.attrsData = new EffectAttrsData();
                        newFrameData.frameIndex = i;
                        this.timelineFrame[i] = newFrameData;
                    }
                    newFrameData.attrsData.setLerpAttribute(key, outVal);
                }
            };
            EffectElement.prototype.initActions = function () {
                this.actions = [];
                var action;
                for (var key in this.data.actionData) {
                    var actiondata = this.data.actionData[key];
                    switch (actiondata.actionType) {
                        case "linear":
                            action = new framework.LinearAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "loop":
                            action = new framework.LoopAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "rotation":
                            action = new framework.RotationAction();
                            break;
                        case "breath":
                            action = new framework.BreathAction();
                            break;
                        case "uvroll":
                            action = new framework.UVRollAction();
                            break;
                        case "uvsprite":
                            action = new framework.UVSpriteAnimationAction();
                            break;
                        case "rosepath":
                            action = new framework.RoseCurveAction();
                            break;
                        case "trail":
                            action = new framework.TrailAction();
                            break;
                    }
                    action.init(actiondata.startFrame, actiondata.endFrame, actiondata.params, this);
                    this.actions.push(action);
                }
            };
            EffectElement.prototype.update = function () {
                if (this.curAttrData == undefined || this.curAttrData == null)
                    return;
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        gd3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    gd3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.updateElementRotation = function () {
                var cameraTransform = gd3d.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                var worldRotation = gd3d.math.pool.new_quaternion();
                var localRotation = gd3d.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != RenderModel.None) {
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var translation = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        gd3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.StretchedBillBoard) {
                        gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                gd3d.math.pool.delete_quaternion(localRotation);
                gd3d.math.pool.delete_quaternion(worldRotation);
            };
            EffectElement.prototype.isCurFrameNeedRefresh = function (frameIndex) {
                if (this.timelineFrame[frameIndex] != undefined) {
                    return true;
                }
                if (this.curAttrData != undefined && this.curAttrData.renderModel != RenderModel.None) {
                    return true;
                }
                return this.actionActive;
            };
            EffectElement.prototype.setActive = function (_active) {
                if (this.active == _active)
                    return;
                this.active = _active;
                if (this.active) {
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.dispose = function () {
                this.data.dispose();
                this.curAttrData = null;
                this.actions.length = 0;
                delete this.timelineFrame;
            };
            return EffectElement;
        }());
        framework.EffectElement = EffectElement;
        var EffectElementData = (function () {
            function EffectElementData() {
                this.delayTime = 0;
            }
            EffectElementData.prototype.clone = function () {
                var elementdata = new EffectElementData();
                elementdata.name = this.name;
                elementdata.type = this.type;
                elementdata.refFrom = this.refFrom;
                elementdata.beloop = this.beloop;
                elementdata.actionData = [];
                elementdata.timelineFrame = [];
                if (this.initFrameData)
                    elementdata.initFrameData = this.initFrameData.clone();
                if (this.emissionData) {
                    elementdata.emissionData = this.emissionData.clone();
                }
                for (var key in this.timelineFrame) {
                    if (this.timelineFrame[key]) {
                        elementdata.timelineFrame[key] = this.timelineFrame[key].clone();
                    }
                }
                for (var key in this.actionData) {
                    if (this.actionData[key]) {
                        elementdata.actionData[key] = this.actionData[key].clone();
                    }
                }
                return elementdata;
            };
            EffectElementData.prototype.dispose = function () {
                if (this.actionData)
                    this.actionData.length = 0;
                if (this.initFrameData)
                    this.initFrameData.dispose();
                for (var key in this.timelineFrame) {
                    this.timelineFrame[key].dispose();
                }
                delete this.timelineFrame;
            };
            return EffectElementData;
        }());
        framework.EffectElementData = EffectElementData;
        var EffectAttrsData = (function () {
            function EffectAttrsData() {
                this.uv = new gd3d.math.vector2(1, 1);
                this.renderModel = RenderModel.None;
                this.matrix = new gd3d.math.matrix();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
            }
            EffectAttrsData.prototype.setLerpAttribute = function (attribute, val) {
                switch (attribute) {
                    case "pos":
                        this.pos = val;
                        break;
                    case "scale":
                        this.scale = val;
                        break;
                    case "euler":
                        this.euler = val;
                        break;
                    case "alpha":
                        this.alpha = val;
                        break;
                    case "uv":
                        this.uv = val;
                        break;
                    case "color":
                        this.color = val;
                        break;
                    case "tilling":
                        console.log("tilling 逻辑上不需要插值");
                        break;
                }
            };
            EffectAttrsData.prototype.getAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        return gd3d.math.pool.clone_vector3(this.pos);
                    case "scale":
                        return gd3d.math.pool.clone_vector3(this.scale);
                    case "euler":
                        return gd3d.math.pool.clone_vector3(this.euler);
                    case "alpha":
                        return this.alpha;
                    case "color":
                        return gd3d.math.pool.clone_vector3(this.color);
                    case "tilling":
                        return gd3d.math.pool.clone_vector2(this.tilling);
                    case "uv":
                        return gd3d.math.pool.clone_vector2(this.uv);
                    case "mat":
                        return this.mat.clone();
                    case "renderModel":
                        return this.renderModel;
                    case "rotationByEuler":
                        return gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                    case "localRotation":
                        return gd3d.math.pool.clone_quaternion(this.localRotation);
                    case "matrix":
                        return gd3d.math.pool.clone_matrix(this.matrix);
                    case "colorRate":
                        return this.colorRate;
                }
            };
            EffectAttrsData.prototype.initAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        this.pos = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "scale":
                        this.scale = new gd3d.math.vector3(1, 1, 1);
                        break;
                    case "euler":
                        this.euler = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "alpha":
                        this.alpha = 0;
                        break;
                    case "color":
                        this.color = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "uv":
                        this.uv = new gd3d.math.vector2(0, 0);
                        break;
                    case "tilling":
                        this.tilling = new gd3d.math.vector2(1, 1);
                        break;
                    case "colorRate":
                        this.colorRate = 1;
                        break;
                    default:
                        console.log("不支持的属性：" + attribute);
                        break;
                }
            };
            EffectAttrsData.prototype.resetMatrix = function () {
                gd3d.math.matrixZero(this.matrix);
            };
            EffectAttrsData.prototype.copyandinit = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = gd3d.math.pool.clone_vector3(this.pos);
                else
                    data.initAttribute("pos");
                if (this.euler != undefined)
                    data.euler = gd3d.math.pool.clone_vector3(this.euler);
                else
                    data.initAttribute("euler");
                if (this.color != undefined)
                    data.color = gd3d.math.pool.clone_vector3(this.color);
                else
                    data.initAttribute("color");
                if (this.scale != undefined)
                    data.scale = gd3d.math.pool.clone_vector3(this.scale);
                else
                    data.initAttribute("scale");
                if (this.uv != undefined)
                    data.uv = gd3d.math.pool.clone_vector2(this.uv);
                else
                    data.initAttribute("uv");
                if (this.tilling != undefined)
                    data.tilling = gd3d.math.pool.clone_vector2(this.tilling);
                else
                    data.initAttribute("tilling");
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                else
                    data.initAttribute("colorRate");
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = gd3d.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            EffectAttrsData.prototype.clone = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = gd3d.math.pool.clone_vector3(this.pos);
                if (this.euler != undefined)
                    data.euler = gd3d.math.pool.clone_vector3(this.euler);
                if (this.color != undefined)
                    data.color = gd3d.math.pool.clone_vector3(this.color);
                if (this.scale != undefined)
                    data.scale = gd3d.math.pool.clone_vector3(this.scale);
                if (this.tilling != undefined)
                    data.tilling = gd3d.math.pool.clone_vector2(this.tilling);
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                if (this.uv != undefined)
                    data.uv = gd3d.math.pool.clone_vector2(this.uv);
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = gd3d.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            return EffectAttrsData;
        }());
        framework.EffectAttrsData = EffectAttrsData;
        var EffectFrameData = (function () {
            function EffectFrameData() {
            }
            EffectFrameData.prototype.clone = function () {
                var framedata = new EffectFrameData();
                framedata.frameIndex = this.frameIndex;
                framedata.attrsData = this.attrsData.clone();
                framedata.lerpDatas = [];
                for (var key in this.lerpDatas) {
                    framedata.lerpDatas[key] = this.lerpDatas[key].clone();
                }
                return framedata;
            };
            EffectFrameData.prototype.dispose = function () {
                this.attrsData = null;
                if (this.lerpDatas)
                    this.lerpDatas.length = 0;
            };
            return EffectFrameData;
        }());
        framework.EffectFrameData = EffectFrameData;
        var EffectLerpData = (function () {
            function EffectLerpData() {
                this.attrsList = [];
            }
            EffectLerpData.prototype.clone = function () {
                var lerpdata = new EffectLerpData();
                lerpdata.type = this.type;
                lerpdata.fromFrame = this.fromFrame;
                lerpdata.toFrame = this.toFrame;
                lerpdata.attrsData = this.attrsData.clone();
                for (var key in this.attrsList) {
                    lerpdata.attrsList[key] = this.attrsList[key];
                }
                return lerpdata;
            };
            return EffectLerpData;
        }());
        framework.EffectLerpData = EffectLerpData;
        var EffectActionData = (function () {
            function EffectActionData() {
            }
            EffectActionData.prototype.clone = function () {
                var actiondata = new EffectActionData();
                actiondata.actionType = this.actionType;
                actiondata.startFrame = this.startFrame;
                actiondata.endFrame = this.endFrame;
                actiondata.params = [];
                for (var key in this.params) {
                    actiondata.params[key] = this.params[key];
                }
                return actiondata;
            };
            return EffectActionData;
        }());
        framework.EffectActionData = EffectActionData;
        var EffectMatData = (function () {
            function EffectMatData() {
            }
            EffectMatData.beEqual = function (data0, data1) {
                return data0.alphaCut === data1.alphaCut && data0.diffuseTexture === data1.diffuseTexture && data0.shader === data1.shader && data0.alphaTexture === data1.alphaTexture;
            };
            EffectMatData.prototype.clone = function () {
                var data = new EffectMatData();
                data.shader = this.shader;
                data.diffuseTexture = this.diffuseTexture;
                data.alphaTexture = this.alphaTexture;
                data.alphaCut = this.alphaCut;
                return data;
            };
            return EffectMatData;
        }());
        framework.EffectMatData = EffectMatData;
        var EffectBatcherState;
        (function (EffectBatcherState) {
            EffectBatcherState[EffectBatcherState["NotInitedStateType"] = 0] = "NotInitedStateType";
            EffectBatcherState[EffectBatcherState["InitedStateType"] = 1] = "InitedStateType";
            EffectBatcherState[EffectBatcherState["ResizeCapacityStateType"] = 2] = "ResizeCapacityStateType";
        })(EffectBatcherState = framework.EffectBatcherState || (framework.EffectBatcherState = {}));
        var EffectBatcher = (function () {
            function EffectBatcher(formate) {
                this.state = EffectBatcherState.NotInitedStateType;
                this.effectElements = [];
                this._totalVertexCount = 0;
                this._indexStartIndex = 0;
                this._vbosize = 0;
                this.vertexSize = 0;
                this.vertexSize = gd3d.render.meshData.calcByteSize(formate) / 4;
            }
            Object.defineProperty(EffectBatcher.prototype, "curTotalVertexCount", {
                get: function () {
                    return this._totalVertexCount;
                },
                set: function (val) {
                    this._totalVertexCount = val;
                    this.resizeVboSize(this._totalVertexCount * this.vertexSize);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EffectBatcher.prototype, "indexStartIndex", {
                get: function () {
                    return this._indexStartIndex;
                },
                set: function (value) {
                    this._indexStartIndex = value;
                    if (this.dataForEbo != null) {
                        var ebo = new Uint16Array(this._indexStartIndex);
                        ebo.set(this.dataForEbo, 0);
                        this.dataForEbo = ebo;
                    }
                    else {
                        this.dataForEbo = new Uint16Array(this._indexStartIndex);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EffectBatcher.prototype.resizeVboSize = function (value) {
                if (this._vbosize > value)
                    return;
                this._vbosize = value;
                if (this.dataForVbo != null) {
                    var vbo = new Float32Array(this._vbosize);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                else {
                    this.dataForVbo = new Float32Array(this._vbosize);
                }
            };
            EffectBatcher.prototype.dispose = function () {
                this.mesh.dispose();
                this.mat.dispose();
                this.dataForVbo = null;
                this.dataForEbo = null;
                for (var key in this.effectElements) {
                    this.effectElements[key].dispose();
                }
            };
            return EffectBatcher;
        }());
        framework.EffectBatcher = EffectBatcher;
        var EffectPlayStateEnum;
        (function (EffectPlayStateEnum) {
            EffectPlayStateEnum[EffectPlayStateEnum["None"] = 0] = "None";
            EffectPlayStateEnum[EffectPlayStateEnum["BeReady"] = 1] = "BeReady";
            EffectPlayStateEnum[EffectPlayStateEnum["Play"] = 2] = "Play";
            EffectPlayStateEnum[EffectPlayStateEnum["Pause"] = 3] = "Pause";
            EffectPlayStateEnum[EffectPlayStateEnum["Stop"] = 4] = "Stop";
            EffectPlayStateEnum[EffectPlayStateEnum["Dispose"] = 5] = "Dispose";
        })(EffectPlayStateEnum = framework.EffectPlayStateEnum || (framework.EffectPlayStateEnum = {}));
        var EffectElementTypeEnum;
        (function (EffectElementTypeEnum) {
            EffectElementTypeEnum[EffectElementTypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            EffectElementTypeEnum[EffectElementTypeEnum["EmissionType"] = 1] = "EmissionType";
            EffectElementTypeEnum[EffectElementTypeEnum["MultiMeshType"] = 2] = "MultiMeshType";
        })(EffectElementTypeEnum = framework.EffectElementTypeEnum || (framework.EffectElementTypeEnum = {}));
        var EffectLerpTypeEnum;
        (function (EffectLerpTypeEnum) {
            EffectLerpTypeEnum[EffectLerpTypeEnum["Linear"] = 0] = "Linear";
        })(EffectLerpTypeEnum = framework.EffectLerpTypeEnum || (framework.EffectLerpTypeEnum = {}));
        var RenderModel;
        (function (RenderModel) {
            RenderModel[RenderModel["None"] = 0] = "None";
            RenderModel[RenderModel["BillBoard"] = 1] = "BillBoard";
            RenderModel[RenderModel["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModel[RenderModel["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModel[RenderModel["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModel[RenderModel["Mesh"] = 5] = "Mesh";
        })(RenderModel = framework.RenderModel || (framework.RenderModel = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleEmissionType;
        (function (ParticleEmissionType) {
            ParticleEmissionType[ParticleEmissionType["burst"] = 0] = "burst";
            ParticleEmissionType[ParticleEmissionType["continue"] = 1] = "continue";
        })(ParticleEmissionType = framework.ParticleEmissionType || (framework.ParticleEmissionType = {}));
        var EmissionData = (function () {
            function EmissionData() {
                this.type = ParticleEmissionType.burst;
            }
            return EmissionData;
        }());
        framework.EmissionData = EmissionData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Emission = (function () {
            function Emission() {
                this.simulateInLocalSpace = true;
                this.renderModel = framework.RenderModel.Mesh;
                this.particleStartData = new gd3d.framework.ParticleStartData();
            }
            Emission.prototype.getVboData = function (vf) {
                if (this.dataForVbo == undefined) {
                    this.dataForVbo = this.mesh.data.genVertexDataArray(vf);
                }
                return this.dataForVbo;
            };
            Emission.prototype.clone = function () {
                var emission = new Emission();
                if (this.emissionType != undefined)
                    emission.emissionType = this.emissionType;
                emission.simulateInLocalSpace = this.simulateInLocalSpace;
                if (this.rootpos != undefined) {
                    emission.rootpos = gd3d.math.pool.clone_vector3(this.rootpos);
                }
                if (this.rootRotAngle != undefined) {
                    emission.rootRotAngle = gd3d.math.pool.clone_vector3(this.rootRotAngle);
                }
                if (this.rootScale != undefined) {
                    emission.rootScale = gd3d.math.pool.clone_vector3(this.rootScale);
                }
                if (this.maxEmissionCount != undefined)
                    emission.maxEmissionCount = this.maxEmissionCount;
                if (this.emissionCount != undefined)
                    emission.emissionCount = this.emissionCount;
                if (this.time != undefined)
                    emission.time = this.time;
                if (this.simulationSpeed != undefined) {
                    emission.simulationSpeed = this.simulationSpeed.clone();
                }
                if (this.moveSpeed != undefined)
                    emission.moveSpeed = this.moveSpeed.clone();
                if (this.gravity != undefined)
                    emission.gravity = this.gravity;
                if (this.euler != undefined)
                    emission.euler = this.euler.clone();
                if (this.eulerNodes != undefined)
                    emission.eulerNodes = this.cloneParticleNodeArray(this.eulerNodes);
                if (this.eulerSpeed != undefined)
                    emission.eulerSpeed = this.eulerSpeed.clone();
                if (this.scale != undefined)
                    emission.scale = this.scale.clone();
                if (this.scaleNodes != undefined)
                    emission.scaleNodes = this.cloneParticleNodeNumberArray(this.scaleNodes);
                if (this.scaleSpeed != undefined)
                    emission.scaleSpeed = this.scaleSpeed.clone();
                if (this.color != undefined)
                    emission.color = this.color.clone();
                if (this.colorRate != undefined)
                    emission.colorRate = this.colorRate;
                if (this.colorNodes != undefined)
                    emission.colorNodes = this.cloneParticleNodeArray(this.colorNodes);
                if (this.colorSpeed != undefined)
                    emission.colorSpeed = this.colorSpeed.clone();
                if (this.simulationSpeed != undefined)
                    emission.simulationSpeed = this.simulationSpeed.clone();
                if (this.alpha != undefined)
                    emission.alpha = this.alpha.clone();
                if (this.alphaNodes != undefined)
                    emission.alphaNodes = this.cloneParticleNodeNumberArray(this.alphaNodes);
                if (this.alphaSpeed != undefined)
                    emission.alphaSpeed = this.alphaSpeed.clone();
                if (this.uv != undefined)
                    emission.uv = this.uv.clone();
                if (this.uvType != undefined)
                    emission.uvType = this.uvType;
                if (this.uvRoll != undefined)
                    emission.uvRoll = this.uvRoll.clone();
                if (this.uvSprite != undefined)
                    emission.uvSprite = this.uvSprite.clone();
                if (this.mat != undefined)
                    emission.mat = this.mat.clone();
                if (this.life != undefined)
                    emission.life = this.life.clone();
                if (this.renderModel != undefined)
                    emission.renderModel = this.renderModel;
                if (this.mesh != undefined)
                    emission.mesh = this.mesh;
                if (this.dataForVbo != undefined)
                    emission.dataForVbo = this.dataForVbo;
                if (this.particleStartData != undefined)
                    emission.particleStartData = this.particleStartData.clone();
                return emission;
            };
            Emission.prototype.getworldRotation = function () {
            };
            Emission.prototype.cloneParticleNodeArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            Emission.prototype.cloneParticleNodeNumberArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            return Emission;
        }());
        framework.Emission = Emission;
        var UVSprite = (function () {
            function UVSprite() {
            }
            UVSprite.prototype.clone = function () {
                var sprite = new UVSprite();
                sprite.row = this.row;
                sprite.column = this.column;
                sprite.totalCount = this.totalCount;
                return sprite;
            };
            return UVSprite;
        }());
        framework.UVSprite = UVSprite;
        var UVRoll = (function () {
            function UVRoll() {
            }
            UVRoll.prototype.clone = function () {
                var roll = new UVRoll();
                if (this.uvSpeed != undefined)
                    roll.uvSpeed = this.uvSpeed;
                if (this.uvSpeedNodes != undefined) {
                    var array = new Array();
                    for (var i in this.uvSpeedNodes) {
                        array.push(this.uvSpeedNodes[i].clone());
                    }
                    roll.uvSpeedNodes = array;
                }
                return roll;
            };
            return UVRoll;
        }());
        framework.UVRoll = UVRoll;
        var UVTypeEnum;
        (function (UVTypeEnum) {
            UVTypeEnum[UVTypeEnum["NONE"] = 0] = "NONE";
            UVTypeEnum[UVTypeEnum["UVRoll"] = 1] = "UVRoll";
            UVTypeEnum[UVTypeEnum["UVSprite"] = 2] = "UVSprite";
        })(UVTypeEnum = framework.UVTypeEnum || (framework.UVTypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleNode = (function () {
            function ParticleNode() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
                this.z = new framework.ValueData();
            }
            ParticleNode.prototype.getValue = function () {
                return new gd3d.math.vector3(this.x.getValue(), this.y.getValue(), this.z.getValue());
            };
            ParticleNode.prototype.getValueRandom = function () {
                return new gd3d.math.vector3(this.x.getValueRandom(), this.y.getValueRandom(), this.z.getValueRandom());
            };
            ParticleNode.prototype.clone = function () {
                var node = new ParticleNode();
                if (this.x != undefined)
                    node.x = this.x.clone();
                if (this.y != undefined)
                    node.y = this.y.clone();
                if (this.z != undefined)
                    node.z = this.z.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return ParticleNode;
        }());
        framework.ParticleNode = ParticleNode;
        var AlphaNode = (function () {
            function AlphaNode() {
                this.alpha = new framework.ValueData();
            }
            AlphaNode.prototype.getValue = function () {
                return this.alpha.getValue();
            };
            return AlphaNode;
        }());
        framework.AlphaNode = AlphaNode;
        var UVSpeedNode = (function () {
            function UVSpeedNode() {
                this.u = new framework.ValueData();
                this.v = new framework.ValueData();
            }
            UVSpeedNode.prototype.getValue = function () {
                return new gd3d.math.vector2(this.u.getValue(), this.v.getValue());
            };
            UVSpeedNode.prototype.getValueRandom = function () {
                return new gd3d.math.vector2(this.u.getValueRandom(), this.v.getValueRandom());
            };
            UVSpeedNode.prototype.clone = function () {
                var node = new UVSpeedNode();
                node.u = this.u.clone();
                node.v = this.v.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return UVSpeedNode;
        }());
        framework.UVSpeedNode = UVSpeedNode;
        var ParticleNodeVec2 = (function () {
            function ParticleNodeVec2() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
            }
            ParticleNodeVec2.prototype.getValue = function () {
                return new gd3d.math.vector2(this.x.getValue(), this.y.getValue());
            };
            ParticleNodeVec2.prototype.getValueRandom = function () {
                return new gd3d.math.vector2(this.x.getValueRandom(), this.y.getValueRandom());
            };
            ParticleNodeVec2.prototype.clone = function () {
                var vec = new ParticleNodeVec2();
                vec.x = this.x.clone();
                vec.y = this.y.clone();
                if (this.key != undefined)
                    vec.key = this.key;
                return vec;
            };
            return ParticleNodeVec2;
        }());
        framework.ParticleNodeVec2 = ParticleNodeVec2;
        var ParticleNodeNumber = (function () {
            function ParticleNodeNumber() {
                this.num = new framework.ValueData();
            }
            ParticleNodeNumber.prototype.getValue = function () {
                return this.num.getValue();
            };
            ParticleNodeNumber.prototype.getValueRandom = function () {
                return this.num.getValueRandom();
            };
            ParticleNodeNumber.prototype.clone = function () {
                var num = new ParticleNodeNumber();
                num.num = this.num.clone();
                if (this.key != undefined) {
                    num.key = this.key;
                }
                return num;
            };
            return ParticleNodeNumber;
        }());
        framework.ParticleNodeNumber = ParticleNodeNumber;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleSystemShape;
        (function (ParticleSystemShape) {
            ParticleSystemShape[ParticleSystemShape["NORMAL"] = 0] = "NORMAL";
            ParticleSystemShape[ParticleSystemShape["BOX"] = 1] = "BOX";
            ParticleSystemShape[ParticleSystemShape["SPHERE"] = 2] = "SPHERE";
            ParticleSystemShape[ParticleSystemShape["HEMISPHERE"] = 3] = "HEMISPHERE";
            ParticleSystemShape[ParticleSystemShape["CONE"] = 4] = "CONE";
            ParticleSystemShape[ParticleSystemShape["EDGE"] = 5] = "EDGE";
            ParticleSystemShape[ParticleSystemShape["CIRCLE"] = 6] = "CIRCLE";
        })(ParticleSystemShape = framework.ParticleSystemShape || (framework.ParticleSystemShape = {}));
        var ParticleStartData = (function () {
            function ParticleStartData() {
                this.shapeType = ParticleSystemShape.NORMAL;
                this._position = new gd3d.math.vector3(0, 0, 0);
                this._direction = new gd3d.math.vector3(0, 1, 0);
                this._width = 0;
                this._height = 0;
                this.depth = 0;
                this._radius = 0;
                this._angle = 0;
                this.emitFrom = emitfromenum.base;
            }
            Object.defineProperty(ParticleStartData.prototype, "position", {
                get: function () {
                    return this._position;
                },
                set: function (_pos) {
                    gd3d.math.vec3Clone(_pos, this._position);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (_dir) {
                    gd3d.math.vec3Clone(_dir, this._direction);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (_w) {
                    this._width = _w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "height", {
                get: function () {
                    return this._height;
                },
                set: function (_h) {
                    this._height = _h;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                set: function (_r) {
                    this._radius = _r;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "angle", {
                get: function () {
                    return this._angle;
                },
                set: function (_a) {
                    this._angle = _a;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "randomDirection", {
                get: function () {
                    switch (this.shapeType) {
                        case ParticleSystemShape.BOX:
                            return this.boxDirection;
                        case ParticleSystemShape.SPHERE:
                            return this.sphereDirection;
                        case ParticleSystemShape.HEMISPHERE:
                            return this.hemisphereDirection;
                        case ParticleSystemShape.CONE:
                            return this.coneDirection;
                        case ParticleSystemShape.CIRCLE:
                            return this.circleDirection;
                        case ParticleSystemShape.EDGE:
                            return this.edgeDirection;
                        default:
                            return this.direction;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "boxDirection", {
                get: function () {
                    this.position.x = framework.ValueData.RandomRange(-this.width / 2, this.width / 2);
                    this.position.y = framework.ValueData.RandomRange(-this.height / 2, this.height / 2);
                    this.position.z = framework.ValueData.RandomRange(-this.depth / 2, this.depth / 2);
                    gd3d.math.vec3Normalize(this.position, this.direction);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "sphereDirection", {
                get: function () {
                    var θ = Math.random() * Math.PI * 2;
                    var φ = Math.random() * Math.PI;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(φ) * Math.cos(θ);
                    this.direction.y = Math.cos(φ);
                    this.direction.z = Math.sin(φ) * Math.sin(θ);
                    gd3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "hemisphereDirection", {
                get: function () {
                    var θ = Math.random() * Math.PI * 2;
                    var φ = Math.random() * Math.PI * 0.5;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(φ) * Math.cos(θ);
                    this.direction.y = Math.cos(φ);
                    this.direction.z = Math.sin(φ) * Math.sin(θ);
                    gd3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "coneDirection", {
                get: function () {
                    var randomAngle = Math.random() * Math.PI * 2;
                    var randomHeight = Math.random() * this.height;
                    var upradius = randomHeight * Math.tan(this.angle * Math.PI / 180) + this.radius;
                    var radomRadius = Math.random() * upradius;
                    var bottompos = gd3d.math.pool.new_vector3();
                    bottompos.x = this.radius * Math.cos(randomAngle);
                    bottompos.y = 0;
                    bottompos.z = this.radius * Math.sin(randomAngle);
                    if (this.emitFrom == emitfromenum.base) {
                        gd3d.math.vec3Clone(bottompos, this.position);
                    }
                    else if (this.emitFrom == emitfromenum.volume) {
                        this.position.x = radomRadius * Math.cos(randomAngle);
                        this.position.z = radomRadius * Math.sin(randomAngle);
                        this.position.y = randomHeight;
                    }
                    this.direction.x = Math.cos(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.z = Math.sin(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.y = Math.cos(this.angle * Math.PI / 180);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "circleDirection", {
                get: function () {
                    var _arc = this.angle * (Math.PI / 180);
                    var a = framework.ValueData.RandomRange(-_arc / 2, _arc / 2);
                    var _radius = framework.ValueData.RandomRange(0, this.radius);
                    this.direction.x = _radius * Math.cos(a);
                    this.direction.z = _radius * Math.sin(a);
                    this.direction.y = 0;
                    var length = gd3d.math.vec3Length(this.direction);
                    gd3d.math.vec3Normalize(this.direction, this.direction);
                    framework.EffectUtil.RotateVector3(this.direction, this.direction, this.direction);
                    this.getposition(this.direction, length);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "edgeDirection", {
                get: function () {
                    var edgePos = new gd3d.math.vector3(0, 0, 0);
                    edgePos.y += framework.ValueData.RandomRange(-this.radius / 2, this.radius / 2);
                    var lenght = gd3d.math.vec3Length(edgePos);
                    framework.EffectUtil.RotateVector3(edgePos, this.direction, edgePos);
                    gd3d.math.vec3Clone(this.direction, this.direction);
                    this.getposition(edgePos, length);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            ParticleStartData.prototype.getposition = function (dir, length) {
                gd3d.math.vec3ScaleByNum(dir, length, dir);
                this.position.x = dir.x;
                this.position.y = dir.y;
                this.position.z = dir.z;
            };
            ParticleStartData.prototype.clone = function () {
                var data = new ParticleStartData();
                data.shapeType = this.shapeType;
                data._position = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._position, data._position);
                data._direction = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._direction, data._direction);
                data._width = this._width;
                data._height = this._height;
                data.depth = this.depth;
                data._radius = this._radius;
                data._angle = this._angle;
                data.position = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.position, data.position);
                data.direction = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.direction, data.direction);
                return data;
            };
            return ParticleStartData;
        }());
        framework.ParticleStartData = ParticleStartData;
        var emitfromenum;
        (function (emitfromenum) {
            emitfromenum[emitfromenum["base"] = 0] = "base";
            emitfromenum[emitfromenum["volume"] = 1] = "volume";
        })(emitfromenum = framework.emitfromenum || (framework.emitfromenum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ValueData = (function () {
            function ValueData() {
                this.isRandom = true;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
            }
            Object.defineProperty(ValueData.prototype, "value", {
                set: function (_v) {
                    this._value = _v;
                    this.isRandom = false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMin", {
                set: function (_v) {
                    this._valueLimitMin = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMax", {
                set: function (_v) {
                    this._valueLimitMax = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            ValueData.prototype.clone = function () {
                var valu = new ValueData();
                valu.isRandom = this.isRandom;
                valu._value = this._value;
                valu._valueLimitMin = this._valueLimitMin;
                valu._valueLimitMax = this._valueLimitMax;
                return valu;
            };
            ValueData.prototype.getValue = function () {
                if (this.isRandom) {
                    if (!this.beInited) {
                        this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            ValueData.prototype.getValueRandom = function () {
                if (this.isRandom) {
                    this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                }
                return this._value;
            };
            ValueData.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            return ValueData;
        }());
        framework.ValueData = ValueData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Particle_new = (function () {
            function Particle_new(batcher) {
                this.startScale = new gd3d.math.vector3();
                this.startRotation = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.rotAngle = 0;
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localMatrix = new gd3d.math.matrix();
                this.localTranslate = new gd3d.math.vector3();
                this.localRotation = new gd3d.math.quaternion();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.color = new gd3d.math.vector3(1, 1, 1);
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.curLife = 0;
                this.life = 0;
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.actived = true;
                this.transformVertex = new gd3d.math.matrix();
                this.matToworld = new gd3d.math.matrix();
                this.batcher = batcher;
                this.emisson = batcher.emission;
                this.gameObject = this.emisson.gameObject;
                this.vertexStartIndex = batcher.curVerCount;
                this.dataForVbo = this.emisson.cloneMeshVBO();
                this.dataForEbo = this.emisson.cloneMeshEBO();
                this.sourceVbo = this.emisson.vbo;
                this.initByData();
            }
            Particle_new.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.emisson.vertexSize);
            };
            Particle_new.prototype.initByData = function () {
                this.totalLife = this.emisson.lifeTime.getValue();
                framework.effTools.getRandomDirAndPosByZEmission(this.emisson, this.speedDir, this.localTranslate);
                this.simulationSpeed = this.emisson.simulationSpeed.getValue();
                this.Starteuler = this.emisson.startEuler.getValue();
                gd3d.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                this.localScale = this.emisson.startScale.getValue();
                this.startColor = this.emisson.startColor;
                this.sizeNodes = this.emisson.sizeNodes;
                this.colorNodes = this.emisson.colorNodes;
                this.alphaNodes = this.emisson.alphaNodes;
                if (this.emisson.enableVelocityOverLifetime) {
                    this.movespeed = this.emisson.moveSpeed.getValue();
                }
                if (this.emisson.enableRotOverLifeTime) {
                    this.eulerSpeed = this.emisson.angleSpeed.getValue();
                }
                if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    var localOrgin = gd3d.math.pool.vector3_zero;
                    gd3d.math.quatLookat(localOrgin, this.speedDir, this.rotationByShape);
                    var initRot = gd3d.math.pool.new_quaternion();
                    gd3d.math.quatFromEulerAngles(90, 0, 90, initRot);
                    gd3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                    gd3d.math.quatClone(this.rotationByShape, this.localRotation);
                    gd3d.math.pool.delete_quaternion(initRot);
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    gd3d.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    gd3d.math.quatClone(quat, this.emissionWorldRotation);
                }
            };
            Particle_new.prototype.update = function (delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                this.life = this.curLife / this.totalLife;
                gd3d.math.floatClamp(this.life, 0, 1);
                if (this.curLife >= this.totalLife) {
                    gd3d.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            Particle_new.prototype._updateLocalMatrix = function (delta) {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.emisson.matToObj, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            Particle_new.prototype.refreshEmissionData = function () {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            };
            Particle_new.prototype._updateRotation = function (delta) {
                if (this.emisson.rendermodel == framework.RenderModel.Mesh) {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_up, this.rotAngle, this.rotationByEuler);
                    gd3d.math.quatClone(this.rotationByEuler, this.localRotation);
                }
                else {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle, this.rotationByEuler);
                    this.refreshEmissionData();
                    var translation = gd3d.math.pool.new_vector3();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var worldRotation = gd3d.math.pool.new_quaternion();
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.vec3Clone(this.localTranslate, translation);
                    var cam = this.emisson.renderCamera;
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    gd3d.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.emisson.rendermodel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        var xaxis = gd3d.math.pool.new_vector3();
                        var yaxis = gd3d.math.pool.new_vector3();
                        var zaxis = gd3d.math.pool.new_vector3();
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.matToworld, xaxis);
                        gd3d.math.vec3Normalize(xaxis, xaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.matToworld, yaxis);
                        gd3d.math.vec3Normalize(yaxis, yaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_forward, this.matToworld, zaxis);
                        gd3d.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        gd3d.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        gd3d.math.pool.delete_quaternion(worldRotation);
                        gd3d.math.pool.delete_vector3(translation);
                        gd3d.math.pool.delete_quaternion(invTransformRotation);
                        gd3d.math.pool.delete_vector3(xaxis);
                        gd3d.math.pool.delete_vector3(yaxis);
                        gd3d.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    gd3d.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(worldRotation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
            };
            Particle_new.prototype._updatePos = function (delta) {
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                gd3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
                if (this.emisson.enableVelocityOverLifetime) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
            };
            Particle_new.prototype._updateEuler = function (delta) {
                if (this.emisson.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            };
            Particle_new.prototype._updateScale = function (delta) {
                if (this.emisson.enableSizeOverLifetime) {
                    for (var i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life && this.sizeNodes[i + 1].key >= this.life) {
                            var target = gd3d.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            gd3d.math.vec3ScaleByNum(this.startScale, target, this.localScale);
                            break;
                        }
                    }
                }
            };
            Particle_new.prototype._updateColor = function (delta) {
                if (this.emisson.enableColorOverLifetime) {
                    if (this.colorNodes != null) {
                        for (var i = 0; i < this.colorNodes.length - 1; i++) {
                            if (this.colorNodes[i].key <= this.life && this.colorNodes[i + 1].key >= this.life) {
                                gd3d.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                break;
                            }
                        }
                    }
                    if (this.alphaNodes != null) {
                        for (var i = 0; i < this.alphaNodes.length - 1; i++) {
                            if (this.alphaNodes[i].key <= this.life && this.alphaNodes[i + 1].key >= this.life) {
                                this.alpha = gd3d.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key));
                                break;
                            }
                        }
                    }
                }
            };
            Particle_new.prototype._updateUV = function (delta) {
                if (this.emisson.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z = this.emisson.uSpeed * this.curLife;
                    this.tex_ST.w = this.emisson.vSpeed * this.curLife;
                }
                else if (this.emisson.uvType == framework.UVTypeEnum.UVSprite) {
                    var spriteindex = Math.floor(this.life * this.emisson.count);
                    gd3d.math.spriteAnimation(this.emisson.row, this.emisson.column, spriteindex, this.tex_ST);
                }
            };
            Particle_new.prototype._updateVBO = function () {
                var vertexSize = this.emisson.vertexSize;
                for (var i = 0; i < this.emisson.perVertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = this.sourceVbo[i * vertexSize + 3] * this.startColor.r;
                        var g = this.sourceVbo[i * vertexSize + 4] * this.startColor.g;
                        var b = this.sourceVbo[i * vertexSize + 5] * this.startColor.b;
                        var a = this.sourceVbo[i * vertexSize + 6] * this.startColor.a;
                        if (this.colorNodes != null) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alphaNodes != null) {
                            a = this.alpha;
                        }
                        r *= this.emisson.colorRate;
                        g *= this.emisson.colorRate;
                        b *= this.emisson.colorRate;
                        a *= this.emisson.colorRate;
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.emisson.vertexSize + 3] = r;
                        this.dataForVbo[i * this.emisson.vertexSize + 4] = g;
                        this.dataForVbo[i * this.emisson.vertexSize + 5] = b;
                        this.dataForVbo[i * this.emisson.vertexSize + 6] = a;
                    }
                    {
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            };
            Particle_new.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tex_ST = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.Starteuler = null;
                this.localScale = null;
                this.color = null;
            };
            return Particle_new;
        }());
        framework.Particle_new = Particle_new;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Vector3AttributeData = (function () {
            function Vector3AttributeData() {
                this.init();
            }
            Vector3AttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, new gd3d.math.vector3());
                this.addFramePoint(keyPoint);
            };
            Vector3AttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            Vector3AttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            Vector3AttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            Vector3AttributeData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Vector3AttributeData);
            return Vector3AttributeData;
        }());
        framework.Vector3AttributeData = Vector3AttributeData;
        var Vector2AttributeData = (function () {
            function Vector2AttributeData() {
                this.init();
            }
            Vector2AttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, new gd3d.math.vector2());
                this.addFramePoint(keyPoint);
            };
            Vector2AttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            Vector2AttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            Vector2AttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            Vector2AttributeData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Vector2AttributeData);
            return Vector2AttributeData;
        }());
        framework.Vector2AttributeData = Vector2AttributeData;
        var NumberAttributeData = (function () {
            function NumberAttributeData() {
                this.init();
            }
            NumberAttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, 0);
                this.addFramePoint(keyPoint, null);
            };
            NumberAttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            NumberAttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            NumberAttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            NumberAttributeData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], NumberAttributeData);
            return NumberAttributeData;
        }());
        framework.NumberAttributeData = NumberAttributeData;
        var AttributeUIState;
        (function (AttributeUIState) {
            AttributeUIState[AttributeUIState["None"] = 0] = "None";
            AttributeUIState[AttributeUIState["Show"] = 1] = "Show";
            AttributeUIState[AttributeUIState["Hide"] = 2] = "Hide";
        })(AttributeUIState = framework.AttributeUIState || (framework.AttributeUIState = {}));
        var AttributeUIType;
        (function (AttributeUIType) {
            AttributeUIType[AttributeUIType["Number"] = 0] = "Number";
            AttributeUIType[AttributeUIType["Vector2"] = 1] = "Vector2";
            AttributeUIType[AttributeUIType["Vector3"] = 2] = "Vector3";
            AttributeUIType[AttributeUIType["Vector4"] = 3] = "Vector4";
        })(AttributeUIType = framework.AttributeUIType || (framework.AttributeUIType = {}));
        var AttributeValType;
        (function (AttributeValType) {
            AttributeValType[AttributeValType["FixedValType"] = 0] = "FixedValType";
            AttributeValType[AttributeValType["LerpType"] = 1] = "LerpType";
        })(AttributeValType = framework.AttributeValType || (framework.AttributeValType = {}));
        var FrameKeyPointData = (function () {
            function FrameKeyPointData(frameIndex, val) {
                this.frameIndex = frameIndex;
                this.val = val;
            }
            return FrameKeyPointData;
        }());
        framework.FrameKeyPointData = FrameKeyPointData;
        var AttributeUtil = (function () {
            function AttributeUtil() {
            }
            AttributeUtil.addFrameIndex = function (datas, index) {
                for (var i = 0; i < datas.length - 1; i++) {
                    if (index > datas[i] && index <= datas[i + 1]) {
                        datas.splice(i, 0, index);
                        return;
                    }
                }
                datas.push(index);
            };
            return AttributeUtil;
        }());
        framework.AttributeUtil = AttributeUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AttributeType;
        (function (AttributeType) {
            AttributeType[AttributeType["PositionType"] = 1] = "PositionType";
            AttributeType[AttributeType["EulerType"] = 2] = "EulerType";
            AttributeType[AttributeType["ScaleType"] = 3] = "ScaleType";
            AttributeType[AttributeType["ColorType"] = 4] = "ColorType";
            AttributeType[AttributeType["ColorRateType"] = 5] = "ColorRateType";
            AttributeType[AttributeType["AlphaType"] = 6] = "AlphaType";
            AttributeType[AttributeType["TillingType"] = 7] = "TillingType";
        })(AttributeType = framework.AttributeType || (framework.AttributeType = {}));
        var EffectElementSingleMesh = (function () {
            function EffectElementSingleMesh(sys, data) {
                if (data === void 0) { data = null; }
                this.elementType = gd3d.framework.EffectElementTypeEnum.SingleMeshType;
                this.beloop = false;
                this.delayTime = 0;
                this.life = 5;
                this.colorRate = 1;
                this.renderModel = gd3d.framework.RenderModel.Mesh;
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.position = [];
                this.euler = [];
                this.scale = [];
                this.color = [];
                this.alpha = [];
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
                this.effectSys = sys;
                if (data != null) {
                    this.initByElementdata(data);
                }
                else {
                    this.initByDefData();
                }
            }
            EffectElementSingleMesh.prototype.initByElementdata = function (data) {
            };
            EffectElementSingleMesh.prototype.initByDefData = function () {
                this.mesh = this.mgr.getDefaultMesh("quad");
                var shader = this.mgr.getShader("diffuse.shader.json");
                this.mat.setShader(shader);
            };
            EffectElementSingleMesh.prototype.writeToJson = function (obj) {
            };
            EffectElementSingleMesh.prototype.update = function () {
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        gd3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    gd3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElementSingleMesh.prototype.updateElementRotation = function () {
                var cameraTransform = gd3d.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                var worldRotation = gd3d.math.pool.new_quaternion();
                var localRotation = gd3d.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != framework.RenderModel.None) {
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var translation = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        gd3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                gd3d.math.pool.delete_quaternion(localRotation);
                gd3d.math.pool.delete_quaternion(worldRotation);
            };
            EffectElementSingleMesh.prototype.dispose = function () {
            };
            EffectElementSingleMesh = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
            ], EffectElementSingleMesh);
            return EffectElementSingleMesh;
        }());
        framework.EffectElementSingleMesh = EffectElementSingleMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectElementEmission = (function () {
            function EffectElementEmission(sys, data) {
                if (data === void 0) { data = null; }
                this.active = true;
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.maxVertexCount = 2048;
                this.rotTranslate = new gd3d.math.vector3();
                this.rotScale = new gd3d.math.vector3(1, 1, 1);
                this.rotRotation = new gd3d.math.vector3();
                this.rotQuta = new gd3d.math.quaternion();
                this.elementType = framework.EffectElementTypeEnum.EmissionType;
                this.delayTime = 0;
                this.beloop = true;
                this.lifeTime = new framework.NumberData(5);
                this.simulateInLocalSpace = true;
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                this.startColor = new gd3d.math.color(1, 1, 1, 1);
                this.colorRate = 1;
                this.duration = new framework.NumberData();
                this.emissionCount = new framework.NumberData();
                this.emissionType = framework.ParticleEmissionType.burst;
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.simulationSpeed = new framework.NumberData();
                this.emitFrom = framework.emitfromenum.base;
                this.rendermodel = framework.RenderModel.BillBoard;
                this.enableVelocityOverLifetime = false;
                this.enableSizeOverLifetime = false;
                this.enableRotOverLifeTime = false;
                this.enableColorOverLifetime = false;
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                this.beBurst = false;
                this.beover = false;
                this.worldRotation = new gd3d.math.quaternion();
                this.matToObj = new gd3d.math.matrix();
                this.matToWorld = new gd3d.math.matrix();
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.gameObject = sys.gameObject;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                if (data == null) {
                    this.initDefparticleData();
                }
                else {
                    this.initByEmissonData(data);
                }
                this.perVertexCount = this.mesh.data.pos.length;
                this.perIndexxCount = this.mesh.data.trisindex.length;
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    this._continueSpaceTime = this.duration.getValue() / this.emissionCount.getValue();
                }
                this.getmatrixToObj();
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            EffectElementEmission.prototype.initDefparticleData = function () {
                this.duration.setValue(2.0);
                this.emissionCount.setValue(10);
                this.shapeType = framework.ParticleSystemShape.CONE;
                this.simulationSpeed.setValue(0.1);
                this.radius = 1.0;
                this.angle = 45;
                this.height = 1.0;
                this.mat = framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
                this.mesh = framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
            };
            EffectElementEmission.prototype.initByEmissonData = function (data) {
            };
            EffectElementEmission.prototype.getWorldRotation = function () {
                var parRot = this.gameObject.transform.getWorldRotate();
                gd3d.math.quatMultiply(parRot, this.rotQuta, this.worldRotation);
                return this.worldRotation;
            };
            EffectElementEmission.prototype.getmatrixToObj = function () {
                gd3d.math.quatFromEulerAngles(this.rotRotation.x, this.rotRotation.y, this.rotRotation.z, this.rotQuta);
                gd3d.math.matrixMakeTransformRTS(this.rotTranslate, this.rotScale, this.rotQuta, this.matToObj);
            };
            EffectElementEmission.prototype.getmatrixToWorld = function () {
                var mat = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.matToObj, this.matToWorld);
                return this.matToWorld;
            };
            EffectElementEmission.prototype.update = function (delta) {
                this.updateLife(delta);
                this.updateBatcher(delta);
            };
            EffectElementEmission.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EffectElementEmission.prototype.updateLife = function (delta) {
                if (this.beover)
                    return;
                this.curTime += delta;
                this.updateEmission();
                if (this.curTime > this.lifeTime.getValue()) {
                    if (this.beloop) {
                        this.reInit();
                    }
                    else {
                        this.beover = true;
                    }
                }
            };
            EffectElementEmission.prototype.reInit = function () {
                this.beover = false;
                this.curTime = 0;
                this.beBurst = false;
            };
            EffectElementEmission.prototype.updateEmission = function () {
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    var rate = this.curTime / this.duration.getValue();
                    rate = gd3d.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionCount.getValue());
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                }
                else if (this.emissionType == framework.ParticleEmissionType.burst && !this.beBurst) {
                    this.addParticle(this.emissionCount.getValue());
                    this.beBurst = true;
                }
            };
            EffectElementEmission.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            };
            EffectElementEmission.prototype.addBatcher = function () {
                var batcher = new framework.EmissionBatcher_new(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            };
            Object.defineProperty(EffectElementEmission.prototype, "renderCamera", {
                get: function () {
                    if (this._renderCamera != null) {
                        return this._renderCamera;
                    }
                    else {
                        return gd3d.framework.sceneMgr.app.getScene().mainCamera;
                    }
                },
                enumerable: true,
                configurable: true
            });
            EffectElementEmission.prototype.render = function (context, assetmgr, camera) {
                this._renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            };
            EffectElementEmission.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            };
            EffectElementEmission.prototype.getMesh = function () {
                if (this.rendermodel == framework.RenderModel.Mesh) {
                    return this.mesh;
                }
                else if (this.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad_particle");
                }
                else {
                    this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                }
            };
            EffectElementEmission.prototype.cloneMeshVBO = function () {
                if (this.vbo == null) {
                    this.vbo = this.mesh.data.genVertexDataArray(this.vf);
                }
                return new Float32Array(this.vbo);
            };
            EffectElementEmission.prototype.cloneMeshEBO = function () {
                if (this.ebo == null) {
                    this.ebo = this.mesh.data.genIndexDataArray();
                }
                return new Uint16Array(this.ebo);
            };
            EffectElementEmission.prototype.writeToJson = function (obj) {
                throw new Error("Method not implemented.");
            };
            EffectElementEmission = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
            ], EffectElementEmission);
            return EffectElementEmission;
        }());
        framework.EffectElementEmission = EffectElementEmission;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EmissionBatcher_new = (function () {
            function EmissionBatcher_new(emissionElement) {
                this.particles = [];
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emission = emissionElement;
                this.webgl = emissionElement.webgl;
                this.mat = this.emission.mat;
                this.initMesh();
            }
            EmissionBatcher_new.prototype.initMesh = function () {
                this.mesh = new framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.emission.vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
            };
            EmissionBatcher_new.prototype.addParticle = function () {
                this.refreshBuffer();
                var p = new framework.Particle_new(this);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emission.perVertexCount;
                this.curIndexCount += this.emission.perIndexxCount;
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            };
            EmissionBatcher_new.prototype.refreshBuffer = function () {
                var needvercount = this.curVerCount + this.emission.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emission.perIndexxCount;
                if (needvercount * this.emission.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    var vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    var ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            };
            EmissionBatcher_new.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher_new.prototype.render = function (context, assetmgr, camera) {
                var mesh = this.mesh;
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            };
            EmissionBatcher_new.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher_new;
        }());
        framework.EmissionBatcher_new = EmissionBatcher_new;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var effTools = (function () {
            function effTools() {
            }
            effTools.getRandomDirAndPosByZEmission = function (emission, outDir, outPos) {
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_zero, outPos);
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        var radius = Math.random() * emission.radius;
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        gd3d.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2;
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = gd3d.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            gd3d.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            };
            effTools.getTex_ST = function (emission, out_St) {
                if (emission.uvType != framework.UVTypeEnum.UVSprite) {
                    out_St.x = 1;
                    out_St.y = 1;
                    out_St.z = 0;
                    out_St.w = 0;
                }
                else {
                    gd3d.math.spriteAnimation(emission.row, emission.column, 0, out_St);
                }
            };
            return effTools;
        }());
        framework.effTools = effTools;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Curve3 = (function () {
            function Curve3(points, nbPoints) {
                this._beizerPoints = points;
                this._bezierPointNum = nbPoints;
            }
            Object.defineProperty(Curve3.prototype, "beizerPoints", {
                get: function () {
                    return this._beizerPoints;
                },
                set: function (value) {
                    this._beizerPoints = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Curve3.prototype, "bezierPointNum", {
                get: function () {
                    return this._bezierPointNum;
                },
                set: function (value) {
                    this._bezierPointNum = value;
                },
                enumerable: true,
                configurable: true
            });
            Curve3.CreateLinearBezier = function (start, end, indices) {
                indices = indices > 2 ? indices : 3;
                var bez = new Array();
                var equation = function (t, va10, va11) {
                    var res = (1.0 - t) * va10 + t * va11;
                    return res;
                };
                bez.push(start);
                for (var i = 1; i <= indices; i++) {
                    bez.push(new gd3d.math.vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
                }
                return new Curve3(bez, indices);
            };
            Curve3.GetLerpBezier = function (nodes) {
                var beizerPoint = new Array();
                for (var n = 0; n < nodes.length; n++) {
                    beizerPoint.push(nodes[n].getValue());
                }
                return new Curve3(beizerPoint, nodes.length);
            };
            Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
                bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2) {
                    var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
                bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2, val3) {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.prototype.getPoints = function () {
                return this._beizerPoints;
            };
            return Curve3;
        }());
        framework.Curve3 = Curve3;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LinearAction = (function () {
            function LinearAction() {
            }
            LinearAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.attrival = framework.EffectUtil.parseEffectVec3(this.params["value"]);
                            break;
                        case "uv":
                            this.attrival = framework.EffectUtil.parseEffectUVSpeed(this.params["value"]);
                            break;
                        case "alpha":
                            this.attrival = this.params["value"];
                            break;
                    }
                }
            };
            LinearAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos.x = baseValue.pos.x + this.attrival.x.getValue();
                        baseValue.pos.y = baseValue.pos.y + this.attrival.y.getValue();
                        baseValue.pos.z = baseValue.pos.z + this.attrival.z.getValue();
                        break;
                    case "scale":
                        baseValue.scale.x = baseValue.scale.x + this.attrival.x.getValue();
                        baseValue.scale.y = baseValue.scale.y + this.attrival.y.getValue();
                        baseValue.scale.z = baseValue.scale.z + this.attrival.z.getValue();
                        break;
                    case "euler":
                        baseValue.euler.x = baseValue.euler.x + this.attrival.x.getValue();
                        baseValue.euler.y = baseValue.euler.y + this.attrival.y.getValue();
                        baseValue.euler.z = baseValue.euler.z + this.attrival.z.getValue();
                        break;
                    case "color":
                        baseValue.color.x = baseValue.color.x + this.attrival.x.getValue();
                        baseValue.color.y = baseValue.color.y + this.attrival.y.getValue();
                        baseValue.color.z = baseValue.color.z + this.attrival.z.getValue();
                        break;
                    case "uv":
                        baseValue.uv.x = baseValue.uv.x + this.attrival.u.getValue();
                        baseValue.uv.y = baseValue.uv.y + this.attrival.v.getValue();
                        break;
                    case "alpha":
                        baseValue.alpha = baseValue.alpha + this.attrival;
                        break;
                }
            };
            return LinearAction;
        }());
        framework.LinearAction = LinearAction;
        var DestroyAction = (function () {
            function DestroyAction() {
            }
            DestroyAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            DestroyAction.prototype.update = function (frameIndex) {
                if (frameIndex >= this.startFrame) {
                    this.elements.setActive(false);
                }
            };
            return DestroyAction;
        }());
        framework.DestroyAction = DestroyAction;
        var LoopAction = (function () {
            function LoopAction() {
            }
            LoopAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            LoopAction.prototype.update = function (frameIndex) {
                if (frameIndex == this.startFrame) {
                    this.elements.loopFrame = this.startFrame + 1;
                    this.elements.curAttrData = this.elements.data.initFrameData.attrsData.copyandinit();
                }
            };
            return LoopAction;
        }());
        framework.LoopAction = LoopAction;
        var UVRollAction = (function () {
            function UVRollAction() {
                this.speedu = 0;
                this.speedv = 0;
                this.startu = 0;
                this.startv = 0;
            }
            UVRollAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["speedu"] != undefined) {
                    this.speedu = this.params["speedu"];
                }
                if (this.params["speedv"] != undefined) {
                    this.speedv = this.params["speedv"];
                }
                if (this.params["startu"] != undefined) {
                    this.startu = this.params["startu"];
                }
                if (this.params["startv"] != undefined) {
                    this.startv = this.params["startv"];
                }
            };
            UVRollAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if (this.startFrame == frameIndex) {
                    this.elements.curAttrData.uv.x = this.startu;
                    this.elements.curAttrData.uv.y = this.startv;
                    return;
                }
                this.elements.curAttrData.uv.x += this.speedu;
                this.elements.curAttrData.uv.y += this.speedv;
            };
            return UVRollAction;
        }());
        framework.UVRollAction = UVRollAction;
        var UVSpriteAnimationAction = (function () {
            function UVSpriteAnimationAction() {
                this.fps = 30;
                this.row = 1;
                this.colum = 1;
                this.totalCount = 1;
                this.frameInternal = 1;
                this.spriteIndex = 0;
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
            }
            UVSpriteAnimationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["row"] != undefined) {
                    this.row = this.params["row"];
                }
                if (this.params["colum"] != undefined) {
                    this.colum = this.params["colum"];
                }
                if (this.params["count"] != undefined) {
                    this.totalCount = this.params["count"];
                }
            };
            UVSpriteAnimationAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var spriteindex = Math.floor((frameIndex - this.startFrame) / (this.endFrame - this.startFrame) * this.totalCount);
                gd3d.math.spriteAnimation(this.row, this.colum, spriteindex, this.tex_ST);
                this.elements.curAttrData.uv.x = this.tex_ST.z;
                this.elements.curAttrData.uv.y = this.tex_ST.w;
                this.elements.curAttrData.tilling.x = this.tex_ST.x;
                this.elements.curAttrData.tilling.y = this.tex_ST.y;
            };
            return UVSpriteAnimationAction;
        }());
        framework.UVSpriteAnimationAction = UVSpriteAnimationAction;
        var RotationAction = (function () {
            function RotationAction() {
            }
            RotationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["velocity"] != undefined) {
                    this.velocity = framework.EffectUtil.parseEffectVec3(this.params["velocity"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RotationAction.prototype.update = function (frameIndex) {
                this.elements.curAttrData.euler.z = this.elements.curAttrData.euler.z + (this.velocity.z.getValue()) * this.frameInternal;
                if (this.elements.curAttrData.renderModel == framework.RenderModel.None) {
                    this.elements.curAttrData.euler.x = this.elements.curAttrData.euler.x + (this.velocity.x.getValue()) * this.frameInternal;
                    this.elements.curAttrData.euler.y = this.elements.curAttrData.euler.y + (this.velocity.y.getValue()) * this.frameInternal;
                }
            };
            return RotationAction;
        }());
        framework.RotationAction = RotationAction;
        var RoseCurveAction = (function () {
            function RoseCurveAction() {
            }
            RoseCurveAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["radius"] != undefined) {
                    this.radius = this.params["radius"];
                }
                if (this.params["level"] != undefined) {
                    this.level = this.params["radius"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["polar"] != undefined) {
                    this.polar = framework.EffectUtil.parseEffectVec3(this.params["polar"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RoseCurveAction.prototype.update = function (frameIndex) {
                var initFrameDataPos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.data.initFrameData.attrsData.pos, initFrameDataPos);
                var radius = this.radius;
                var curFrame = frameIndex % 360;
                var x = this.polar.x.getValue();
                var y = this.polar.y.getValue();
                var z = this.polar.z.getValue();
                {
                    var theta = frameIndex * this.speed;
                    this.elements.curAttrData.pos.x = initFrameDataPos.x + radius * Math.cos(3 * theta + x) * Math.cos(theta);
                    this.elements.curAttrData.pos.z = initFrameDataPos.z + radius * Math.cos(3 * theta + x) * Math.sin(theta);
                    this.elements.curAttrData.pos.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                }
                {
                    var deltaTheta = frameIndex * this.speed + 0.001;
                    var targetPoint = gd3d.math.pool.new_vector3();
                    targetPoint.x = initFrameDataPos.x + radius * Math.cos(3 * deltaTheta + x) * Math.cos(deltaTheta);
                    targetPoint.z = initFrameDataPos.z + radius * Math.cos(3 * deltaTheta + x) * Math.sin(deltaTheta);
                    targetPoint.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                    var rotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.quatLookat(this.elements.curAttrData.pos, targetPoint, rotation);
                    gd3d.math.quatToEulerAngles(rotation, this.elements.curAttrData.euler);
                    gd3d.math.pool.delete_vector3(targetPoint);
                    gd3d.math.pool.delete_quaternion(rotation);
                }
                gd3d.math.pool.delete_vector3(initFrameDataPos);
            };
            return RoseCurveAction;
        }());
        framework.RoseCurveAction = RoseCurveAction;
        var TrailAction = (function () {
            function TrailAction() {
                this.offsetTransalte = new gd3d.math.vector3();
            }
            TrailAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["pos"] != undefined) {
                    this.position = framework.EffectUtil.parseEffectVec3(this.params["pos"]);
                }
                this.offsetTransalte.x = this.position.x.getValue();
                this.offsetTransalte.y = this.position.y.getValue();
                this.offsetTransalte.z = this.position.z.getValue();
                if (this.params["eular"] != undefined) {
                    this.eular = framework.EffectUtil.parseEffectVec3(this.params["eular"]);
                }
                if (this.params["color"] != undefined) {
                    this.color = framework.EffectUtil.parseEffectVec3(this.params["color"]);
                }
                if (this.params["width"] != undefined) {
                    this.width = this.params["width"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["alpha"] != undefined) {
                    this.alpha = this.params["alpha"];
                }
                var mat = new gd3d.framework.material();
                var shader = new gd3d.framework.shader();
                var texture = new gd3d.framework.texture();
                if (this.params["shader"] != undefined)
                    shader = framework.sceneMgr.app.getAssetMgr().getShader(this.params["shader"]);
                else
                    shader = framework.sceneMgr.app.getAssetMgr().getShader("shader/def");
                mat.setShader(shader);
                if (this.params["diffuseTexture"] != undefined)
                    texture = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.params["diffuseTexture"]);
                mat.setTexture("_MainTex", texture);
                this.frameInternal = 1 / framework.effectSystem.fps;
                this.transform = new gd3d.framework.transform();
                framework.sceneMgr.scene.addChild(this.transform);
                var curAttrData = this.elements.data.initFrameData.attrsData.clone();
                var worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                var trailTransform = new gd3d.framework.transform();
                this.transform.addChild(trailTransform);
                var x = this.eular.x.getValue();
                var y = this.eular.y.getValue();
                var z = this.eular.z.getValue();
                this.startRotation = new gd3d.math.quaternion();
                gd3d.math.quatFromEulerAngles(x, y, z, this.startRotation);
                gd3d.math.quatMultiply(this.startRotation, curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
                trailTransform.markDirty();
                var trailrender = trailTransform.gameObject.addComponent("trailRender");
                trailrender.color = new gd3d.math.color(this.color.x.getValue(), this.color.y.getValue(), this.color.z.getValue(), this.alpha);
                trailrender.setspeed(this.speed);
                trailrender.setWidth(this.width);
                trailrender.material = mat;
            };
            TrailAction.prototype.update = function (frameIndex) {
                var worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.vec3Add(this.transform.localTranslate, this.offsetTransalte, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                gd3d.math.quatMultiply(this.startRotation, this.elements.curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
            };
            return TrailAction;
        }());
        framework.TrailAction = TrailAction;
        var BreathAction = (function () {
            function BreathAction() {
            }
            BreathAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    this.loopframe = this.params["loopframe"];
                    this.halfloopframe = this.loopframe / 2;
                    this.curTargetFrame = this.startFrame + this.halfloopframe;
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.startvalue = framework.EffectUtil.parseEffectVec3(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectVec3(this.params["targetvalue"]).getValue();
                            break;
                        case "uv":
                            this.startvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["targetvalue"]).getValue();
                            break;
                        case "alpha":
                            this.startvalue = this.params["startvalue"];
                            this.targetvalue = this.params["targetvalue"];
                            break;
                    }
                }
            };
            BreathAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex)
                    return;
                if (frameIndex >= this.curTargetFrame) {
                    this.swap();
                    this.curTargetFrame += this.halfloopframe;
                }
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos = this.getLerpValue(frameIndex);
                        break;
                    case "scale":
                        baseValue.scale = this.getLerpValue(frameIndex);
                        break;
                    case "euler":
                        baseValue.euler = this.getLerpValue(frameIndex);
                        break;
                    case "color":
                        baseValue.color = this.getLerpValue(frameIndex);
                        break;
                    case "uv":
                        baseValue.uv = this.getLerpValue(frameIndex);
                        break;
                    case "alpha":
                        baseValue.alpha = this.getLerpValue(frameIndex);
                        break;
                }
            };
            BreathAction.prototype.swap = function () {
                var temp;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    temp = gd3d.math.pool.clone_vector3(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector3(this.targetvalue);
                    this.targetvalue = temp;
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    temp = gd3d.math.pool.clone_vector2(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector2(this.targetvalue);
                    this.targetvalue = temp;
                }
                else {
                    temp = this.startvalue;
                    this.startvalue = this.targetvalue;
                    this.targetvalue = temp;
                }
            };
            BreathAction.prototype.getLerpValue = function (frameIndex) {
                var curframe = (frameIndex - this.startFrame) % this.halfloopframe;
                var outVal;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    outVal = new gd3d.math.vector3();
                    gd3d.math.vec3SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    outVal = new gd3d.math.vector2();
                    gd3d.math.vec2SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else {
                    outVal = gd3d.math.numberLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe);
                }
                return outVal;
            };
            return BreathAction;
        }());
        framework.BreathAction = BreathAction;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectParser = (function () {
            function EffectParser() {
            }
            EffectParser.prototype.Parse = function (str, assetmgr) {
                if (str == null)
                    return null;
                this.asMgr = assetmgr;
                var effectData = new framework.EffectSystemData();
                var content = JSON.parse(str);
                if (content["life"] != undefined)
                    effectData.life = content["life"];
                if (content["beloop"] != undefined) {
                    effectData.beLoop = content["beloop"];
                }
                var refOriDic = {};
                var unRefOriDic = {};
                var refCount = 0;
                if (content["elements"] != undefined) {
                    effectData.elementDic = {};
                    var elements = content["elements"];
                    for (var i in elements) {
                        var elementData = elements[i];
                        var name_9 = "";
                        if (elementData["name"] != undefined) {
                            name_9 = elementData["name"];
                            if (effectData.elementDic[name_9] != undefined || refOriDic[name_9] != undefined) {
                                console.error("特效中元素的名字重复：" + name_9);
                                continue;
                            }
                        }
                        else {
                            console.error("未设置特效中元素的名字！");
                            continue;
                        }
                        if (elementData["ref"] != undefined) {
                            refOriDic[name_9] = elementData;
                            refCount++;
                            continue;
                        }
                        else {
                            effectData.elementDic[name_9] = this._parse(elementData);
                            unRefOriDic[name_9] = elementData;
                        }
                    }
                    while (refCount > 0) {
                        for (var key in refOriDic) {
                            var desOriData = refOriDic[key];
                            if (desOriData == null)
                                continue;
                            var refFrom = desOriData["ref"];
                            if (unRefOriDic[refFrom] != undefined) {
                                var srcOriData = unRefOriDic[refFrom];
                                this.copyAndOverWrite(srcOriData, desOriData);
                                var element = this._parse(desOriData);
                                effectData.elementDic[desOriData["name"]] = element;
                                delete refOriDic[key];
                                refCount--;
                            }
                        }
                    }
                }
                return effectData;
            };
            EffectParser.prototype._parse = function (elementData) {
                var element = new framework.EffectElementData();
                if (elementData["beloop"] != undefined)
                    element.beloop = elementData["beloop"];
                if (elementData["delaytime"] != undefined)
                    element.delayTime = elementData["delaytime"];
                element.name = elementData["name"];
                if (elementData["type"] != undefined) {
                    switch (elementData["type"]) {
                        case "singlemesh":
                            element.type = framework.EffectElementTypeEnum.SingleMeshType;
                            break;
                        case "emission":
                            element.type = framework.EffectElementTypeEnum.EmissionType;
                            break;
                    }
                }
                switch (element.type) {
                    case framework.EffectElementTypeEnum.SingleMeshType:
                        this._parseSingleMeshTypeData(elementData, element);
                        break;
                    case framework.EffectElementTypeEnum.EmissionType:
                        this._parseEmissionTypeData(elementData, element);
                        break;
                }
                return element;
            };
            EffectParser.prototype.copyAndOverWrite = function (srcData, desData) {
                for (var key in srcData) {
                    var data = srcData[key];
                    if (data != undefined) {
                        var baseType = typeof (data);
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (desData[key] == undefined)
                                    desData[key] = data;
                                break;
                            default:
                                if (desData[key] == undefined) {
                                    desData[key] = srcData[key];
                                }
                                else {
                                    this.copyAndOverWrite(srcData[key], desData[key]);
                                }
                                break;
                        }
                    }
                }
            };
            EffectParser.prototype._parseSingleMeshTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    element.timelineFrame = {};
                    element.actionData = [];
                    var _timelineArray = elementData["timeline"];
                    for (var j in _timelineArray) {
                        var _timeline = _timelineArray[j];
                        if (_timeline["frame"] == undefined) {
                            console.error("必须要配一个关键帧的索引");
                            continue;
                        }
                        var frame = new framework.EffectFrameData();
                        frame.frameIndex = _timeline["frame"];
                        element.timelineFrame[frame.frameIndex] = frame;
                        frame.attrsData = new framework.EffectAttrsData();
                        if (_timeline["attrs"] != undefined) {
                            var _attrs = _timeline["attrs"];
                            for (var key in _attrs) {
                                var val = this._parseToObjData(key, _attrs[key]);
                                if (key == "mat") {
                                    frame.attrsData.mat = val;
                                }
                                else if (key == "pos") {
                                    frame.attrsData.pos = val.getValue();
                                }
                                else if (key == "scale") {
                                    frame.attrsData.scale = val.getValue();
                                }
                                else if (key == "euler") {
                                    frame.attrsData.euler = val.getValue();
                                }
                                else if (key == "mesh") {
                                    frame.attrsData.mesh = val;
                                }
                                else if (key == "color") {
                                    frame.attrsData.color = val.getValue();
                                }
                                else if (key == "alpha") {
                                    frame.attrsData.alpha = val.getValue();
                                    ;
                                }
                                else if (key == "tilling") {
                                    frame.attrsData.tilling = val.getValue();
                                }
                                else if (key == "billboard") {
                                    frame.attrsData.renderModel = val;
                                }
                                else if (key == "colorRate") {
                                    frame.attrsData.colorRate = val;
                                }
                            }
                        }
                        if (frame.frameIndex == -1) {
                            element.initFrameData = frame;
                        }
                        if (_timeline["lerp"] != undefined) {
                            frame.lerpDatas = [];
                            for (var x in _timeline["lerp"]) {
                                var lerp = new framework.EffectLerpData();
                                lerp.fromFrame = frame.frameIndex;
                                frame.lerpDatas.push(lerp);
                                var _lerp = _timeline["lerp"][x];
                                if (_lerp["type"] != undefined) {
                                    switch (_lerp["type"]) {
                                        case "linear":
                                            lerp.type = framework.EffectLerpTypeEnum.Linear;
                                            break;
                                    }
                                }
                                if (_lerp["to"] != undefined)
                                    lerp.toFrame = this._parseToValueData(_lerp["to"]);
                                if (_lerp["attribute"] != undefined) {
                                    lerp.attrsData = new framework.EffectAttrsData();
                                    var _attribs = _lerp["attribute"];
                                    for (var key in _attribs) {
                                        lerp.attrsList.push(key);
                                        var val = this._parseToObjData(key, _attribs[key]);
                                        if (key == "pos") {
                                            lerp.attrsData.pos = val.getValue();
                                        }
                                        else if (key == "scale") {
                                            lerp.attrsData.scale = val.getValue();
                                        }
                                        else if (key == "euler") {
                                            lerp.attrsData.euler = val.getValue();
                                        }
                                        else if (key == "color") {
                                            lerp.attrsData.color = val.getValue();
                                        }
                                        else if (key == "alpha") {
                                            lerp.attrsData.alpha = val.getValue();
                                        }
                                        else {
                                            console.error("未支持的插值属性：" + key);
                                        }
                                    }
                                }
                            }
                        }
                        if (_timeline["actions"] != undefined) {
                            var _actions = _timeline["actions"];
                            for (var k in _actions) {
                                var action = new framework.EffectActionData();
                                var _action = _actions[k];
                                action.actionType = _action["action"];
                                action.startFrame = frame.frameIndex;
                                if (_action["end"] != undefined) {
                                    action.endFrame = _action["end"];
                                }
                                else {
                                    action.endFrame = -1;
                                }
                                if (_action["param"] != undefined) {
                                    action.params = _action["param"];
                                }
                                element.actionData.push(action);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    var timelines = elementData["timeline"];
                    if (timelines.length > 0 && timelines[0] != undefined && timelines[0]["attrs"] != undefined) {
                        var _data = timelines[0]["attrs"];
                        var data = new framework.Emission();
                        element.emissionData = data;
                        if (_data["emissionType"] != undefined) {
                            switch (_data["emissionType"]) {
                                case "burst":
                                    data.emissionType = framework.ParticleEmissionType.burst;
                                    break;
                                case "continue":
                                    data.emissionType = framework.ParticleEmissionType.continue;
                                    break;
                            }
                            if (_data["simulateinlocal"] != undefined) {
                                data.simulateInLocalSpace = _data["simulateinlocal"];
                            }
                            if (_data["maxcount"] != undefined)
                                data.maxEmissionCount = _data["maxcount"];
                            if (_data["emissioncount"] != undefined)
                                data.emissionCount = _data["emissioncount"];
                            if (_data["time"] != undefined)
                                data.time = _data["time"];
                            if (_data["mesh"] != undefined)
                                data.mesh = this._parseToObjData("mesh", _data["mesh"]);
                            if (_data["mat"] != undefined)
                                data.mat = this._parseToObjData("mat", _data["mat"]);
                            if (_data["rootpos"] != undefined) {
                                data.rootpos = framework.EffectUtil.parseVector3(_data["rootpos"]);
                            }
                            else {
                                data.rootpos = new gd3d.math.vector3();
                            }
                            if (_data["rootRotAngle"] != undefined) {
                                data.rootRotAngle = framework.EffectUtil.parseVector3(_data["rootRotAngle"]);
                            }
                            else {
                                data.rootRotAngle = new gd3d.math.vector3();
                            }
                            if (_data["rootscale"]) {
                                data.rootScale = framework.EffectUtil.parseVector3(_data["rootscale"]);
                            }
                            else {
                                data.rootScale = new gd3d.math.vector3(1, 1, 1);
                            }
                            if (_data["moveSpeed"] != undefined)
                                data.moveSpeed = this._parseToObjData("moveSpeed", _data["moveSpeed"]);
                            if (_data["gravity"] != undefined)
                                data.gravity = _data["gravity"];
                            if (_data["euler"] != undefined)
                                data.euler = this._parseToObjData("euler", _data["euler"]);
                            if (_data["eulerSpeed"] != undefined)
                                data.eulerSpeed = this._parseToObjData("eulerSpeed", _data["eulerSpeed"]);
                            if (_data["eulerNodes"] != undefined) {
                                data.eulerNodes = [];
                                if (data.euler != undefined) {
                                    data.eulerNodes.push(data.euler);
                                    data.euler.key = 0;
                                }
                                for (var i in _data["eulerNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["eulerNodes"][i]);
                                    data.eulerNodes.push(node);
                                }
                            }
                            if (_data["scale"] != undefined)
                                data.scale = this._parseToObjData("scale", _data["scale"]);
                            if (_data["scaleSpeed"] != undefined)
                                data.scaleSpeed = this._parseToObjData("scaleSpeed", _data["scaleSpeed"]);
                            if (_data["scaleNodes"] != undefined) {
                                data.scaleNodes = [];
                                var startscale = new framework.ParticleNodeNumber();
                                startscale.num.value = 1;
                                startscale.key = 0;
                                data.scaleNodes.push(startscale);
                                for (var i in _data["scaleNodes"]) {
                                    var node = framework.EffectUtil.parseEffectNumNode(_data["scaleNodes"][i]);
                                    data.scaleNodes.push(node);
                                }
                            }
                            if (_data["simulationSpeed"] != undefined) {
                                data.simulationSpeed = this._parseToObjData("simulationSpeed", _data["simulationSpeed"]);
                            }
                            if (_data["alpha"] != undefined) {
                                data.alpha = this._parseToObjData("alpha", _data["alpha"]);
                            }
                            if (_data["alphaSpeed"] != undefined)
                                data.alphaSpeed = this._parseToObjData("alphaSpeed", _data["alphaSpeed"]);
                            if (_data["alphaNodes"] != undefined) {
                                data.alphaNodes = [];
                                if (data.alpha != undefined) {
                                    data.alphaNodes.push(data.alpha);
                                    data.alpha.key = 0;
                                }
                                for (var i in _data["alphaNodes"]) {
                                    var node = new framework.ParticleNodeNumber();
                                    var item = _data["alphaNodes"][i];
                                    if (item["key"] != null) {
                                        node.key = item["key"];
                                    }
                                    var alphavalue = item["alpha"];
                                    if (alphavalue != null) {
                                        if (alphavalue instanceof Array) {
                                            node.num.valueLimitMin = alphavalue[0];
                                            node.num.valueLimitMax = alphavalue[1];
                                        }
                                        else {
                                            node.num.value = alphavalue;
                                        }
                                    }
                                    data.alphaNodes.push(node);
                                }
                            }
                            if (_data["color"] != undefined)
                                data.color = this._parseToObjData("color", _data["color"]);
                            if (_data["colorRate"] != undefined)
                                data.colorRate = _data["colorRate"];
                            if (_data["colorSpeed"] != undefined)
                                data.colorSpeed = this._parseToObjData("colorSpeed", _data["colorSpeed"]);
                            if (_data["colorNodes"] != undefined) {
                                data.colorNodes = [];
                                if (data.color != undefined) {
                                    data.colorNodes.push(data.color);
                                    data.color.key = 0;
                                }
                                for (var i in _data["colorNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["colorNodes"][i]);
                                    data.colorNodes.push(node);
                                }
                            }
                            if (_data["uv"] != undefined) {
                                data.uv = framework.EffectUtil.parseEffectVec2(_data["uv"]);
                            }
                            if (_data["uvtype"] != undefined) {
                                switch (_data["uvtype"]) {
                                    case "uvroll":
                                        data.uvType = framework.UVTypeEnum.UVRoll;
                                        if (_data["uvroll"] != undefined) {
                                            data.uvRoll = new framework.UVRoll();
                                            data.uvRoll.uvSpeed = framework.EffectUtil.parseEffectUVSpeed(_data["uvroll"]);
                                        }
                                        break;
                                    case "uvsprite":
                                        var _val = _data["uvsprite"];
                                        data.uvType = framework.UVTypeEnum.UVSprite;
                                        data.uvSprite = new framework.UVSprite();
                                        if (_val["row"] != undefined)
                                            data.uvSprite.row = _val["row"];
                                        if (_val["colum"] != undefined)
                                            data.uvSprite.column = _val["colum"];
                                        if (_val["count"] != undefined)
                                            data.uvSprite.totalCount = _val["count"];
                                        break;
                                    default:
                                        data.uvType = framework.UVTypeEnum.NONE;
                                        break;
                                }
                            }
                            else
                                data.uvType = framework.UVTypeEnum.NONE;
                            if (_data["billboard"] != undefined)
                                data.renderModel = this._parseToObjData("billboard", _data["billboard"]);
                            if (_data["life"] != undefined)
                                data.life = framework.EffectUtil.parseEffectValueData(_data["life"]);
                            if (_data["startpos"] != undefined) {
                                this._parseEmissionShape(_data["startpos"], element);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionShape = function (_startdata, element) {
                var startdata = element.emissionData.particleStartData;
                switch (_startdata["type"]) {
                    case "normal":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                        break;
                    case "box":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.BOX;
                        break;
                    case "sphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.SPHERE;
                        break;
                    case "hemisphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.HEMISPHERE;
                        break;
                    case "cone":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CONE;
                        break;
                    case "circle":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "edge":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.EDGE;
                        break;
                    default:
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                        break;
                }
                if (_startdata["width"] != undefined) {
                    startdata.width = _startdata["width"];
                }
                if (_startdata["height"] != undefined) {
                    startdata.height = _startdata["height"];
                }
                if (_startdata["depth"] != undefined) {
                    startdata.depth = _startdata["depth"];
                }
                if (_startdata["angle"] != undefined) {
                    startdata.angle = _startdata["angle"];
                }
                if (_startdata["radius"] != undefined) {
                    startdata.radius = _startdata["radius"];
                }
                if (_startdata["direction"] != undefined) {
                    var _startdir = _startdata["direction"];
                    startdata.direction.x = _startdir["x"];
                    startdata.direction.y = _startdir["y"];
                    startdata.direction.z = _startdir["z"];
                }
            };
            EffectParser.prototype._parseToObjData = function (attrib, content) {
                switch (attrib) {
                    case "pos":
                    case "scale":
                    case "euler":
                    case "color":
                    case "moveSpeed":
                    case "eulerSpeed":
                    case "scaleSpeed":
                    case "colorSpeed":
                        return framework.EffectUtil.parseEffectVec3(content);
                    case "":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "alphaSpeed":
                    case "alpha":
                    case "simulationSpeed":
                        return framework.EffectUtil.parseEffectNum(content);
                    case "tilling":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "mat":
                        var mat = new framework.EffectMatData();
                        if (content != undefined) {
                            if (content["shader"] != undefined)
                                mat.shader = this.asMgr.getShader(content["shader"]);
                            else
                                mat.shader = this.asMgr.getShader("shader/def");
                            if (content["diffuseTexture"] != undefined)
                                mat.diffuseTexture = this.asMgr.getAssetByName(content["diffuseTexture"]);
                            if (content["alphaCut"] != undefined)
                                mat.alphaCut = content["alphaCut"];
                            if (content["_AlphaTex"] != undefined)
                                mat.alphaTexture = this.asMgr.getAssetByName(content["_AlphaTex"]);
                        }
                        return mat;
                    case "emmision":
                        var emission = new framework.EmissionData();
                        if (content["type"] != undefined)
                            emission.type = content["type"];
                        if (content["time"] != undefined)
                            emission.time = content["time"];
                        if (content["count"] != undefined)
                            emission.count = content["count"];
                        return emission;
                    case "billboard":
                        var billboardType = framework.RenderModel.Mesh;
                        if (content == "billboard") {
                            billboardType = framework.RenderModel.BillBoard;
                        }
                        else if (content == "horizontal") {
                            billboardType = framework.RenderModel.HorizontalBillBoard;
                        }
                        else if (content == "stretched") {
                            billboardType = framework.RenderModel.StretchedBillBoard;
                        }
                        else if (content == "vertical") {
                            billboardType = framework.RenderModel.VerticalBillBoard;
                        }
                        else if (content == "mesh") {
                            billboardType = framework.RenderModel.Mesh;
                        }
                        else {
                            billboardType = framework.RenderModel.None;
                        }
                        return billboardType;
                    case "mesh":
                        var str = content;
                        if (content.toString().indexOf(".mesh.bin") >= 0)
                            return this.asMgr.getAssetByName(content);
                        else
                            return this.asMgr.getDefaultMesh(content);
                    default:
                        return content;
                }
            };
            EffectParser.prototype._parseToParticleNode = function (content) {
                content = framework.StringUtil.replaceAll(content, " ", "");
                var charArray = content.match(framework.RegexpUtil.vector3FloatOrRangeRegexp);
                if (charArray != undefined) {
                    var node = new framework.ParticleNode();
                    for (var i = 1; i < charArray.length; i++) {
                        if (i == 1) {
                            node.x = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 2) {
                            node.y = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 3) {
                            node.z = this._parseToValueData(charArray[i]);
                        }
                    }
                    return node;
                }
                return null;
            };
            EffectParser.prototype._parseToValueData = function (content) {
                var data = new framework.ValueData();
                var array = this._parseToNumberArray(content);
                if (array != null) {
                    if (array.length > 1) {
                        data.valueLimitMin = array[0];
                        data.valueLimitMax = array[1];
                        data.isRandom = true;
                    }
                    else {
                        data.value = array[0];
                        data.isRandom = false;
                    }
                }
                return data;
            };
            EffectParser.prototype._parseToNumberArray = function (content) {
                content = framework.StringUtil.trimAll(content);
                content = framework.StringUtil.replaceAll(content, "\\[", "");
                content = framework.StringUtil.replaceAll(content, "\\]", "");
                var _array = content.split(",");
                var result = [];
                for (var i = 0; i < _array.length; i++) {
                    result.push(parseInt(_array[i]));
                }
                return result;
            };
            return EffectParser;
        }());
        framework.EffectParser = EffectParser;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectUtil = (function () {
            function EffectUtil() {
            }
            EffectUtil.lookatbyXAxis = function (pos, xAxis, yAxis, zAxis, targetpos, quat) {
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(targetpos, pos, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var crossup = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(dir, xAxis, crossup);
                gd3d.math.vec3Normalize(crossup, crossup);
                var anglerot = gd3d.math.vec3Dot(yAxis, crossup);
                anglerot = Math.acos(anglerot) * 180 / Math.PI;
                var dot = gd3d.math.vec3Dot(zAxis, crossup);
                dot = Math.acos(dot) * 180 / Math.PI;
                if (dot > 90) {
                    anglerot = -anglerot;
                }
                gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_right, anglerot, quat);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(crossup);
            };
            EffectUtil.eulerFromQuaternion = function (out, q, order) {
                var sqx = q.x * q.x;
                var sqy = q.y * q.y;
                var sqz = q.z * q.z;
                var sqw = q.w * q.w;
                if (order === 'XYZ') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.y * q.z), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.z + q.y * q.w), -1, 1));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YXZ') {
                    out.x = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.w - q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZXY') {
                    out.x = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.w + q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.y * q.w - q.z * q.x), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZYX') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.z * q.y), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(gd3d.math.floatClamp(2 * (q.y * q.w - q.x * q.z), -1, 1));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YZX') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.z * q.y), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.y * q.w - q.x * q.z), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.y + q.z * q.w), -1, 1));
                }
                else if (order === 'XZY') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.y * q.z), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(gd3d.math.floatClamp(2 * (q.z * q.w - q.x * q.y), -1, 1));
                }
                else {
                    console.log('No order given for quaternion to euler conversion.');
                    return;
                }
            };
            EffectUtil.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            EffectUtil.vecMuliNum = function (vec, num) {
                var v = new gd3d.math.vector3(vec.x * num, vec.y * num, vec.z * num);
                return v;
            };
            EffectUtil.parseVector3 = function (value) {
                var vector3 = new gd3d.math.vector3();
                vector3.x = value["x"];
                vector3.y = value["y"];
                vector3.z = value["z"];
                return vector3;
            };
            EffectUtil.parseEffectVec3 = function (value) {
                var node = new framework.ParticleNode();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectVec2 = function (value) {
                var node = new framework.ParticleNodeVec2();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectNum = function (value) {
                var node = new framework.ParticleNodeNumber();
                if (value instanceof Array) {
                    node.num.valueLimitMin = value[0];
                    node.num.valueLimitMax = value[1];
                    node.num.isRandom = true;
                }
                else {
                    node.num.value = value;
                    node.num.isRandom = false;
                }
                return node;
            };
            EffectUtil.parseEffectNumNode = function (value) {
                var node = new framework.ParticleNodeNumber();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node.num.value = value[key];
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectValueData = function (value) {
                var val = new framework.ValueData();
                if (value instanceof Array) {
                    val.valueLimitMin = value[0];
                    val.valueLimitMax = value[1];
                    val.isRandom = true;
                }
                else {
                    val.value = value;
                    val.isRandom = false;
                }
                return val;
            };
            EffectUtil.parseEffectUVSpeed = function (value) {
                var node = new framework.UVSpeedNode();
                for (var key in value) {
                    node[key].value = value[key];
                }
                return node;
            };
            EffectUtil.lookat = function (eye, targetpos, out, up) {
                if (up === void 0) { up = gd3d.math.pool.vector3_up; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var unitprojectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(unitprojectedXZ, unitprojectedXZ);
                var yaw = Math.acos(unitprojectedXZ.z) / Math.PI * 180;
                if (unitprojectedXZ.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
                var right = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(up, dir, right);
                gd3d.math.vec3Normalize(right, right);
                var projectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                var length = gd3d.math.vec3Length(projectedXZ);
                var pitch = Math.acos(length) / Math.PI * 180;
                if (dir.y < 0) {
                    pitch = -pitch;
                }
                var quadRight = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(right, pitch, quadRight);
            };
            EffectUtil.RotateVector3 = function (source, direction, out) {
                gd3d.math.vec3Normalize(source, source);
                gd3d.math.vec3Normalize(direction, direction);
                var forward = new gd3d.math.vector3(0, 0, 1);
                var axis = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(forward, direction, axis);
                gd3d.math.vec3Normalize(axis, axis);
                if (axis.x == 0 && axis.y == 0 && axis.z == 0) {
                    axis.x = 1;
                    axis.y = 0;
                    axis.z = 0;
                }
                var cos = gd3d.math.vec3Dot(forward, direction);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                var quatertion = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(axis, angle, quatertion);
                gd3d.math.quatTransformVector(quatertion, source, out);
                gd3d.math.pool.delete_vector3(axis);
                gd3d.math.pool.delete_quaternion(quatertion);
            };
            EffectUtil.bindAxisBillboard = function (localAxis, out) {
                gd3d.math.vec3Normalize(localAxis, localAxis);
                var yAxis = gd3d.math.pool.vector3_up;
                var normal = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(yAxis, localAxis, normal);
                gd3d.math.vec3Normalize(normal, normal);
                if (normal.x == 0 && normal.y == 0 && normal.z == 0) {
                    normal.x = 1;
                    normal.y = 0;
                    normal.z = 0;
                }
                var cos = gd3d.math.vec3Dot(yAxis, localAxis);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                gd3d.math.quatFromAxisAngle(normal, angle, out);
            };
            EffectUtil.lookatVerticalBillboard = function (eye, targetpos, out, up) {
                if (up === void 0) { up = gd3d.math.pool.vector3_up; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var dirxz = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(dirxz, dirxz);
                var yaw = Math.acos(dirxz.z) / Math.PI * 180;
                if (dirxz.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
            };
            EffectUtil.quatLookatZ = function (eye, targetpos, out, forward) {
                if (forward === void 0) { forward = gd3d.math.pool.vector3_forward; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var dirxy = new gd3d.math.vector3(-dir.x, dir.y, 0);
                gd3d.math.vec3Normalize(dirxy, dirxy);
                var roll = Math.acos(dirxy.y) / Math.PI * 180;
                if (dirxy.x < 0) {
                    roll = -roll;
                }
                gd3d.math.quatFromAxisAngle(forward, roll, out);
            };
            EffectUtil.quatLookatX = function (eye, targetpos, out, right) {
                if (right === void 0) { right = gd3d.math.pool.vector3_right; }
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var diryz = new gd3d.math.vector3(0, -dir.y, dir.z);
                gd3d.math.vec3Normalize(diryz, diryz);
                var pitch = Math.acos(diryz.z) / Math.PI * 180;
                if (diryz.y < 0) {
                    pitch = -pitch;
                }
                gd3d.math.quatFromAxisAngle(right, pitch, out);
            };
            return EffectUtil;
        }());
        framework.EffectUtil = EffectUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EmissionBatcher = (function () {
            function EmissionBatcher(emissionElement) {
                this.particles = [];
                this.vertexSize = 0;
                this.vf = 0;
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emissionElement = emissionElement;
                this.webgl = emissionElement.webgl;
                this.gameObject = emissionElement.gameObject;
                this.vf = emissionElement.vf;
                this.data = emissionElement.emissionData;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                this.initMesh();
                this.mat = new framework.material();
                if (this.data.mat.shader == null) {
                    this.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                }
                else {
                    this.mat.setShader(this.data.mat.shader);
                }
                if (this.data.mat.alphaCut != undefined)
                    this.mat.setFloat("_AlphaCut", this.data.mat.alphaCut);
                if (this.data.mat.diffuseTexture != null)
                    this.mat.setTexture("_MainTex", this.data.mat.diffuseTexture);
                if (this.data.mat.alphaTexture != null)
                    this.mat.setTexture("_AlphaTex", this.data.mat.alphaTexture);
            }
            EmissionBatcher.prototype.initMesh = function () {
                this.mesh = new framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
            };
            EmissionBatcher.prototype.addParticle = function () {
                this.refreshBuffer();
                var p = new framework.Particle(this);
                p.update(0);
                p.uploadData(this.dataForVbo);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emissionElement.perVertexCount;
                this.curIndexCount += this.emissionElement.perIndexxCount;
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            };
            EmissionBatcher.prototype.refreshBuffer = function () {
                var needvercount = this.curVerCount + this.emissionElement.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emissionElement.perIndexxCount;
                if (needvercount * this.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    var vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    var ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            };
            EmissionBatcher.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher.prototype.render = function (context, assetmgr, camera) {
                var mesh = this.mesh;
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            };
            EmissionBatcher.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher;
        }());
        framework.EmissionBatcher = EmissionBatcher;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Particle = (function () {
            function Particle(batcher) {
                this.renderModel = framework.RenderModel.Mesh;
                this.startScale = new gd3d.math.vector3();
                this.startRotation = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localMatrix = new gd3d.math.matrix();
                this.localRotation = new gd3d.math.quaternion();
                this.tilling = new gd3d.math.vector2(1, 1);
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.actived = true;
                this.transformVertex = new gd3d.math.matrix();
                this.matToworld = new gd3d.math.matrix();
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.batcher = batcher;
                this.gameObject = batcher.gameObject;
                this.emisson = batcher.emissionElement;
                this.vf = batcher.vf;
                this.data = batcher.data.clone();
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                this.vertexStartIndex = batcher.curVerCount;
                this.vertexCount = this.emisson.perVertexCount;
                this.dataForVbo = new Float32Array(this.vertexCount * this.vertexSize);
                this.dataForEbo = this.data.mesh.data.genIndexDataArray();
                this.dataForVbo.set(this.data.mesh.data.genVertexDataArray(this.vf), 0);
                this.sourceVbo = this.data.getVboData(this.vf);
                this.initByData();
            }
            Particle.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.vertexSize);
            };
            Particle.prototype.initByData = function () {
                this.totalLife = this.data.life.getValueRandom();
                this.renderModel = this.data.renderModel;
                this.curLife = 0;
                var localRandomDirection = this.data.particleStartData.randomDirection;
                this.speedDir = gd3d.math.pool.clone_vector3(localRandomDirection);
                var localRandomTranslate = this.data.particleStartData.position;
                this.localTranslate = gd3d.math.pool.clone_vector3(localRandomTranslate);
                this.simulationSpeed = this.data.simulationSpeed != undefined ? this.data.simulationSpeed.getValue() : 0;
                if (this.data.euler == undefined)
                    this.euler = new gd3d.math.vector3(0, 0, 0);
                else
                    this.euler = this.data.euler.getValueRandom();
                if (this.data.scale == undefined)
                    this.localScale = new gd3d.math.vector3(1, 1, 1);
                else
                    this.localScale = this.data.scale.getValueRandom();
                if (this.data.color == undefined)
                    this.color = new gd3d.math.vector3(0, 0, 0);
                else
                    this.color = this.data.color.getValueRandom();
                if (this.data.alpha == undefined)
                    this.alpha = 1;
                else
                    this.alpha = this.data.alpha.getValueRandom();
                if (this.data.uv == undefined)
                    this.uv = new gd3d.math.vector2();
                else
                    this.uv = this.data.uv.getValueRandom();
                if (this.data.moveSpeed != undefined) {
                    this.movespeed = this.data.moveSpeed.getValue();
                }
                else {
                    this.movespeed = new gd3d.math.vector3();
                }
                if (this.data.colorRate == undefined)
                    this.colorRate = this.data.colorRate;
                else
                    this.colorRate = 1;
                gd3d.math.vec3Clone(this.localScale, this.startScale);
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                if (this.renderModel == framework.RenderModel.None || this.renderModel == framework.RenderModel.StretchedBillBoard) {
                    if (this.data.particleStartData.shapeType != framework.ParticleSystemShape.NORMAL) {
                        var localOrgin = gd3d.math.pool.vector3_zero;
                        gd3d.math.quatLookat(localOrgin, localRandomDirection, this.rotationByShape);
                        var initRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatFromEulerAngles(90, 0, 90, initRot);
                        gd3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                        gd3d.math.quatClone(this.rotationByShape, this.localRotation);
                        gd3d.math.pool.delete_quaternion(initRot);
                    }
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    gd3d.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    gd3d.math.quatClone(quat, this.emissionWorldRotation);
                }
            };
            Particle.prototype.update = function (delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                if (this.curLife >= this.totalLife) {
                    gd3d.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateAlpha(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            Particle.prototype._updateLocalMatrix = function (delta) {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.emisson.matToBatcher, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            Particle.prototype.refreshEmissionData = function () {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            };
            Particle.prototype._updateRotation = function (delta) {
                this._updateElementRotation();
            };
            Particle.prototype._updateElementRotation = function () {
                if (this.renderModel != framework.RenderModel.Mesh) {
                    this.refreshEmissionData();
                    var translation = gd3d.math.pool.new_vector3();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var worldRotation = gd3d.math.pool.new_quaternion();
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.vec3Clone(this.localTranslate, translation);
                    var cam = this.batcher.emissionElement.renderCamera;
                    if (cam == null) {
                        cam = gd3d.framework.sceneMgr.app.getScene().mainCamera;
                    }
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    gd3d.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        var xaxis = gd3d.math.pool.new_vector3();
                        var yaxis = gd3d.math.pool.new_vector3();
                        var zaxis = gd3d.math.pool.new_vector3();
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.matToworld, xaxis);
                        gd3d.math.vec3Normalize(xaxis, xaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.matToworld, yaxis);
                        gd3d.math.vec3Normalize(yaxis, yaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_forward, this.matToworld, zaxis);
                        gd3d.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        gd3d.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        gd3d.math.pool.delete_quaternion(worldRotation);
                        gd3d.math.pool.delete_vector3(translation);
                        gd3d.math.pool.delete_quaternion(invTransformRotation);
                        gd3d.math.pool.delete_vector3(xaxis);
                        gd3d.math.pool.delete_vector3(yaxis);
                        gd3d.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    gd3d.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(worldRotation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatClone(this.rotationByEuler, this.localRotation);
                }
            };
            Particle.prototype._updatePos = function (delta) {
                if (this.data.moveSpeed != undefined) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                gd3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
            };
            Particle.prototype._updateEuler = function (delta) {
                var index = 0;
                if (this.data.eulerNodes != undefined && this.data.eulerSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.eulerNodes != undefined) {
                    this._updateNode(this.data.eulerNodes, this.totalLife, this.euler);
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
                else if (this.data.eulerSpeed != undefined) {
                    if (this.data.eulerSpeed.x != undefined)
                        this.euler.x += this.data.eulerSpeed.x.getValue() * delta;
                    if (this.data.eulerSpeed.y != undefined)
                        this.euler.y += this.data.eulerSpeed.y.getValue() * delta;
                    if (this.data.eulerSpeed.z != undefined)
                        this.euler.z += this.data.eulerSpeed.z.getValue() * delta;
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
            };
            Particle.prototype._updateScale = function (delta) {
                var index = 0;
                if (this.data.scaleNodes != undefined && this.data.scaleSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.scaleNodes != undefined) {
                    this._updateNode(this.data.scaleNodes, this.totalLife, this.localScale, nodeType.scale);
                }
                else if (this.data.scaleSpeed != undefined) {
                    if (this.data.scaleSpeed.x != undefined)
                        this.localScale.x += this.data.scaleSpeed.x.getValue() * delta;
                    if (this.data.scaleSpeed.y != undefined)
                        this.localScale.y += this.data.scaleSpeed.y.getValue() * delta;
                    if (this.data.scaleSpeed.z != undefined)
                        this.localScale.z += this.data.scaleSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateColor = function (delta) {
                var index = 0;
                if (this.data.colorNodes != undefined && this.data.colorSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.colorNodes != undefined) {
                    this._updateNode(this.data.colorNodes, this.totalLife, this.color);
                }
                else if (this.data.colorSpeed != undefined) {
                    if (this.data.colorSpeed.x != undefined)
                        this.color.x += this.data.colorSpeed.x.getValue() * delta;
                    if (this.data.colorSpeed.y != undefined)
                        this.color.y += this.data.colorSpeed.y.getValue() * delta;
                    if (this.data.colorSpeed.z != undefined)
                        this.color.z += this.data.colorSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateNode = function (nodes, life, out, nodetype) {
                if (nodetype === void 0) { nodetype = nodeType.none; }
                var index = 0;
                var duration = 0;
                if (nodes != undefined) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i + 1 < nodes.length) {
                            if (nodes[i].key * life <= this.curLife && nodes[i + 1].key * life >= this.curLife) {
                                this.tempStartNode = nodes[i];
                                this.tempEndNode = nodes[i + 1];
                                index++;
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                                break;
                            }
                        }
                        else {
                            if (this.curLife < nodes[i].key * life) {
                                this.tempStartNode = nodes[i - 1];
                                this.tempEndNode = nodes[i];
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                            }
                        }
                    }
                    if (this.tempStartNode instanceof framework.ParticleNode) {
                        if (duration > 0) {
                            gd3d.math.vec3SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                    else if (this.tempStartNode instanceof framework.ParticleNodeNumber) {
                        if (duration > 0) {
                            if (nodetype == nodeType.alpha) {
                                this.alpha = gd3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                            }
                            else if (nodetype = nodeType.scale) {
                                var targetscale = gd3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                                gd3d.math.vec3ScaleByNum(this.startScale, targetscale, out);
                            }
                        }
                    }
                    else if (this.tempStartNode instanceof framework.UVSpeedNode) {
                        if (duration > 0) {
                            gd3d.math.vec2SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                }
            };
            Particle.prototype._updateAlpha = function (delta) {
                var index = 0;
                if (this.data.alphaNodes != undefined && this.data.alphaSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.alphaNodes != undefined) {
                    this._updateNode(this.data.alphaNodes, this.totalLife, this.alpha, nodeType.alpha);
                }
                else if (this.data.alphaSpeed != undefined) {
                    this.alpha += this.data.alphaSpeed.getValue() * delta;
                }
            };
            Particle.prototype._updateUV = function (delta) {
                if (this.uv == undefined)
                    this.uv = new gd3d.math.vector2();
                if (this.data.uvType == framework.UVTypeEnum.NONE) {
                    this.uv = this.data.uv.getValue();
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVRoll) {
                    if (this.data.uvRoll != undefined) {
                        if (this.data.uvRoll.uvSpeedNodes != undefined && this.data.uvRoll.uvSpeed != undefined) {
                            console.error("uv只能通过插值或者speed来修改，不能两个同时存在！");
                            return;
                        }
                        var index = 0;
                        if (this.data.uvRoll.uvSpeedNodes != undefined) {
                            this._updateNode(this.data.uvRoll.uvSpeedNodes, this.totalLife, this.uv);
                        }
                        else if (this.data.uvRoll.uvSpeed != undefined) {
                            if (this.data.uvRoll.uvSpeed.u != undefined)
                                this.tex_ST.z += this.data.uvRoll.uvSpeed.u.getValue() * delta;
                            if (this.data.uvRoll.uvSpeed.v != undefined)
                                this.tex_ST.w += this.data.uvRoll.uvSpeed.v.getValue() * delta;
                        }
                    }
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVSprite) {
                    if (this.data.uvSprite != undefined) {
                        var spriteindex = Math.floor(this.curLife / this.totalLife * this.data.uvSprite.totalCount);
                        gd3d.math.spriteAnimation(this.data.uvSprite.row, this.data.uvSprite.column, spriteindex, this.tex_ST);
                    }
                }
            };
            Particle.prototype._updateVBO = function () {
                var vertexSize = this.vertexSize;
                for (var i = 0; i < this.vertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 3], 0, 1);
                        var g = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 4], 0, 1);
                        var b = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 5], 0, 1);
                        var a = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 6], 0, 1);
                        if (this.color != undefined) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alpha != undefined)
                            a = this.alpha;
                        if (this.colorRate != undefined) {
                            r *= this.colorRate;
                            g *= this.colorRate;
                            b *= this.colorRate;
                            a *= this.colorRate;
                        }
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.vertexSize + 3] = r;
                        this.dataForVbo[i * this.vertexSize + 4] = g;
                        this.dataForVbo[i * this.vertexSize + 5] = b;
                        this.dataForVbo[i * this.vertexSize + 6] = a;
                    }
                    {
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            };
            Particle.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tilling = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.euler = null;
                this.localScale = null;
                this.colorRate = 1;
                this.color = null;
                this.uv = null;
            };
            return Particle;
        }());
        framework.Particle = Particle;
        var nodeType;
        (function (nodeType) {
            nodeType[nodeType["none"] = 0] = "none";
            nodeType[nodeType["alpha"] = 1] = "alpha";
            nodeType[nodeType["scale"] = 2] = "scale";
        })(nodeType = framework.nodeType || (framework.nodeType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Particles = (function () {
            function Particles(sys) {
                this.emissionElements = [];
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectSys = sys;
            }
            Particles.prototype.addEmission = function (_emissionNew) {
                var _emissionElement = new EmissionElement(_emissionNew, this.effectSys, this);
                this.emissionElements.push(_emissionElement);
            };
            Particles.prototype.updateForEmission = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].updateForEmission(delta);
                }
            };
            Particles.prototype.update = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].update(delta);
                }
            };
            Particles.prototype.render = function (context, assetmgr, camera) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].render(context, assetmgr, camera);
                }
            };
            Particles.prototype.dispose = function () {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].dispose();
                }
                this.emissionElements.length = 0;
            };
            return Particles;
        }());
        framework.Particles = Particles;
        var EmissionElement = (function () {
            function EmissionElement(_emission, sys, mgr) {
                this.maxVertexCount = 2048;
                this.localtranslate = new gd3d.math.vector3();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.localrotate = new gd3d.math.quaternion();
                this.eluerAngle = new gd3d.math.quaternion();
                this.beloop = false;
                this.simulateInLocalSpace = true;
                this.active = true;
                this.isover = false;
                this.worldRotation = new gd3d.math.quaternion();
                this.matToBatcher = new gd3d.math.matrix();
                this.matToWorld = new gd3d.math.matrix();
                this.testtime = 0;
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.ParticleMgr = mgr;
                this.vf = mgr.vf;
                this.gameObject = mgr.effectSys.gameObject;
                this.beloop = _emission.beloop;
                this.emissionData = _emission.emissionData;
                this.perVertexCount = this.emissionData.mesh.data.pos.length;
                this.perIndexxCount = this.emissionData.mesh.data.trisindex.length;
                this.simulateInLocalSpace = this.emissionData.simulateInLocalSpace;
                switch (this.emissionData.emissionType) {
                    case framework.ParticleEmissionType.burst:
                        break;
                    case framework.ParticleEmissionType.continue:
                        this._continueSpaceTime = this.emissionData.time / (this.emissionData.emissionCount);
                        break;
                }
                gd3d.math.vec3Clone(this.emissionData.rootpos, this.localtranslate);
                gd3d.math.vec3Clone(this.emissionData.rootRotAngle, this.eluerAngle);
                gd3d.math.vec3Clone(this.emissionData.rootScale, this.localScale);
                gd3d.math.quatFromEulerAngles(this.eluerAngle.x, this.eluerAngle.y, this.eluerAngle.z, this.localrotate);
                gd3d.math.matrixMakeTransformRTS(this.localtranslate, this.localScale, this.localrotate, this.matToBatcher);
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            EmissionElement.prototype.getWorldRotation = function () {
                var parRot = this.gameObject.transform.getWorldRotate();
                gd3d.math.quatMultiply(parRot, this.localrotate, this.worldRotation);
                return this.worldRotation;
            };
            EmissionElement.prototype.getmatrixToWorld = function () {
                var mat = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.matToBatcher, this.matToWorld);
                return this.matToWorld;
            };
            EmissionElement.prototype.update = function (delta) {
                this.updateBatcher(delta);
            };
            EmissionElement.prototype.updateForEmission = function (delta) {
                this.testtime += delta;
                this.curTime += delta;
                this.updateEmission(delta);
            };
            EmissionElement.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EmissionElement.prototype.updateEmission = function (delta) {
                if (this.isover)
                    return;
                if (this.emissionData.emissionType == framework.ParticleEmissionType.continue) {
                    var rate = this.curTime / this.emissionData.time;
                    rate = gd3d.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionData.emissionCount);
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                    if (rate == 1) {
                        if (this.beloop) {
                            this.curTime = 0;
                            this.numcount = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
                else if (this.emissionData.emissionType == framework.ParticleEmissionType.burst) {
                    if (this.curTime > this.emissionData.time) {
                        this.addParticle(this.emissionData.emissionCount);
                        if (this.beloop) {
                            this.curTime = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
            };
            EmissionElement.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.update(0);
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            };
            EmissionElement.prototype.addBatcher = function () {
                var batcher = new framework.EmissionBatcher(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            };
            EmissionElement.prototype.render = function (context, assetmgr, camera) {
                this.renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            };
            EmissionElement.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            };
            EmissionElement.prototype.isOver = function () {
                return this.isover;
            };
            return EmissionElement;
        }());
        framework.EmissionElement = EmissionElement;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var BJSCANNON;
        var helpv3 = new gd3d.math.vector3();
        var CannonJSPlugin = (function () {
            function CannonJSPlugin(_useDeltaForWorldStep, iterations) {
                if (_useDeltaForWorldStep === void 0) { _useDeltaForWorldStep = true; }
                if (iterations === void 0) { iterations = 10; }
                this._useDeltaForWorldStep = _useDeltaForWorldStep;
                this.BJSCANNON = CANNON || {};
                this.name = "CannonJSPlugin";
                this._physicsMaterials = new Array();
                this._fixedTimeStep = 1 / 60;
                if (!this.isSupported()) {
                    console.error("CannonJS is not available. Please make sure you included the js file.");
                    return;
                }
                this.world = new BJSCANNON.World();
                this.world.broadphase = new BJSCANNON.NaiveBroadphase();
                this.world.solver.iterations = iterations;
            }
            CannonJSPlugin.prototype.setGravity = function (gravity) {
                this.world.gravity.copy(gravity);
            };
            CannonJSPlugin.prototype.setTimeStep = function (timeStep) {
                this._fixedTimeStep = timeStep;
            };
            CannonJSPlugin.prototype.getTimeStep = function () {
                return this._fixedTimeStep;
            };
            CannonJSPlugin.prototype.executeStep = function (delta, impostors) {
                this.world.step(this._fixedTimeStep, this._useDeltaForWorldStep ? delta : 0, 3);
            };
            CannonJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {
                var worldPoint = new BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
                var impulse = new BJSCANNON.Vec3(force.x, force.y, force.z);
                impostor.physicsBody.applyImpulse(impulse, worldPoint);
            };
            CannonJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {
                var worldPoint = new BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
                var impulse = new BJSCANNON.Vec3(force.x, force.y, force.z);
                impostor.physicsBody.applyForce(impulse, worldPoint);
            };
            CannonJSPlugin.prototype.generatePhysicsBody = function (impostor) {
                if (impostor.isBodyInitRequired()) {
                    var shape = this._createShape(impostor);
                    var oldBody = impostor.physicsBody;
                    if (oldBody) {
                        this.removePhysicsBody(impostor);
                    }
                    var material = this._addMaterial("mat-" + impostor.uniqueId, impostor.getParam("friction"), impostor.getParam("restitution"));
                    var bodyCreationObject = {
                        mass: impostor.getParam("mass"),
                        material: material
                    };
                    var nativeOptions = impostor.getParam("nativeOptions");
                    for (var key in nativeOptions) {
                        if (nativeOptions.hasOwnProperty(key)) {
                            bodyCreationObject[key] = nativeOptions[key];
                        }
                    }
                    impostor.physicsBody = new BJSCANNON.Body(bodyCreationObject);
                    impostor.physicsBody.addEventListener("collide", impostor.onCollide);
                    impostor.physicsBody.addShape(shape);
                    this.world.add(impostor.physicsBody);
                    if (oldBody) {
                        ['force', 'torque', 'velocity', 'angularVelocity'].forEach(function (param) {
                            impostor.physicsBody[param].copy(oldBody[param]);
                        });
                    }
                }
                impostor.physicsBody.position.copy(impostor.object.localPosition);
                impostor.physicsBody.quaternion.copy(impostor.object.localRotate);
            };
            CannonJSPlugin.prototype.removePhysicsBody = function (impostor) {
                impostor.physicsBody.removeEventListener("collide", impostor.onCollide);
                this.world.remove(impostor.physicsBody);
            };
            CannonJSPlugin.prototype.generateJoint = function (impostorJoint) {
                var mainBody = impostorJoint.mainImpostor.physicsBody;
                var connectedBody = impostorJoint.connectedImpostor.physicsBody;
                if (!mainBody || !connectedBody) {
                    return;
                }
                var constraint;
                var jointData = impostorJoint.joint.jointData;
                var constraintData = {
                    pivotA: jointData.mainPivot ? new BJSCANNON.Vec3().copy(jointData.mainPivot) : null,
                    pivotB: jointData.connectedPivot ? new BJSCANNON.Vec3().copy(jointData.connectedPivot) : null,
                    axisA: jointData.mainAxis ? new BJSCANNON.Vec3().copy(jointData.mainAxis) : null,
                    axisB: jointData.connectedAxis ? new BJSCANNON.Vec3().copy(jointData.connectedAxis) : null,
                    maxForce: jointData.nativeParams.maxForce,
                    collideConnected: !!jointData.collision
                };
                switch (impostorJoint.joint.type) {
                    case framework.PhysicsJoint.HingeJoint:
                    case framework.PhysicsJoint.Hinge2Joint:
                        constraint = new BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);
                        break;
                    case framework.PhysicsJoint.DistanceJoint:
                        constraint = new BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);
                        break;
                    case framework.PhysicsJoint.SpringJoint:
                        var springData = jointData;
                        constraint = new BJSCANNON.Spring(mainBody, connectedBody, {
                            restLength: springData.length,
                            stiffness: springData.stiffness,
                            damping: springData.damping,
                            localAnchorA: constraintData.pivotA,
                            localAnchorB: constraintData.pivotB
                        });
                        break;
                    case framework.PhysicsJoint.LockJoint:
                        constraint = new BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);
                        break;
                    case framework.PhysicsJoint.PointToPointJoint:
                    case framework.PhysicsJoint.BallAndSocketJoint:
                    default:
                        constraint = new BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotA, constraintData.maxForce);
                        break;
                }
                constraint.collideConnected = !!jointData.collision;
                impostorJoint.joint.physicsJoint = constraint;
                if (impostorJoint.joint.type !== framework.PhysicsJoint.SpringJoint) {
                    this.world.addConstraint(constraint);
                }
                else {
                    impostorJoint.mainImpostor.registerAfterPhysicsStep(function () {
                        constraint.applyForce();
                    });
                }
            };
            CannonJSPlugin.prototype.removeJoint = function (impostorJoint) {
                this.world.removeConstraint(impostorJoint.joint.physicsJoint);
            };
            CannonJSPlugin.prototype._addMaterial = function (name, friction, restitution) {
                var index;
                var mat;
                for (index = 0; index < this._physicsMaterials.length; index++) {
                    mat = this._physicsMaterials[index];
                    if (mat.friction === friction && mat.restitution === restitution) {
                        return mat;
                    }
                }
                var currentMat = new BJSCANNON.Material(name);
                currentMat.friction = friction;
                currentMat.restitution = restitution;
                this._physicsMaterials.push(currentMat);
                return currentMat;
            };
            CannonJSPlugin.prototype._checkWithEpsilon = function (value) {
                return value < framework.PhysicsEngine.Epsilon ? framework.PhysicsEngine.Epsilon : value;
            };
            CannonJSPlugin.prototype._createShape = function (impostor) {
                var object = impostor.object;
                var returnValue;
                gd3d.math.vec3Clone(impostor.getObjectExtendSize(), helpv3);
                var extendSize = helpv3;
                switch (impostor.type) {
                    case framework.ImpostorType.SphereImpostor:
                        var radiusX = extendSize.x;
                        var radiusY = extendSize.y;
                        var radiusZ = extendSize.z;
                        returnValue = new BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);
                        break;
                    case framework.ImpostorType.CylinderImpostor:
                        console.warn("CylinderImpostor not handle yet");
                        var nativeParams = impostor.getParam("nativeOptions");
                        if (!nativeParams) {
                            nativeParams = {};
                        }
                        var radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;
                        var radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;
                        var height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);
                        var numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;
                        returnValue = new BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);
                        var quat = new BJSCANNON.Quaternion();
                        quat.setFromAxisAngle(new BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);
                        var translation = new BJSCANNON.Vec3(0, 0, 0);
                        returnValue.transformAllPoints(translation, quat);
                        break;
                    case framework.ImpostorType.BoxImpostor:
                        gd3d.math.vec3ScaleByNum(extendSize, 0.5, extendSize);
                        var box = extendSize;
                        returnValue = new BJSCANNON.Box(new BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));
                        break;
                    case framework.ImpostorType.PlaneImpostor:
                        console.warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead");
                        returnValue = new BJSCANNON.Plane();
                        break;
                    case framework.ImpostorType.ConvexHullImpostor:
                        if (object && object.gameObject.components.length > 0) {
                            var mr = object.gameObject.getComponent("meshFilter");
                            if (mr) {
                                var verts_1 = [];
                                mr.mesh.data.pos.forEach(function (p) {
                                    verts_1.push(new CANNON.Vec3(p.x, p.y, p.z));
                                });
                                var tris = [];
                                var dataTris = mr.mesh.data.trisindex;
                                var tLen = dataTris.length;
                                for (var i = 0; i < tLen; i += 3) {
                                    tris.push([dataTris[i + 2], dataTris[i + 1], dataTris[i]]);
                                }
                                returnValue = new BJSCANNON.ConvexPolyhedron(verts_1, tris);
                            }
                        }
                        break;
                    case framework.ImpostorType.MeshImpostor:
                        console.warn("MeshImpostor not handle yet");
                        break;
                    case framework.ImpostorType.HeightmapImpostor:
                        console.warn("HeightmapImpostor not handle yet");
                        break;
                    case framework.ImpostorType.ParticleImpostor:
                        returnValue = new BJSCANNON.Particle();
                        break;
                    case framework.ImpostorType.NoImpostor:
                        returnValue = new BJSCANNON.Box(new BJSCANNON.Vec3(0, 0, 0));
                        break;
                }
                return returnValue;
            };
            CannonJSPlugin.prototype.vec3Copy = function (from, to) {
                to.rawData[0] = from.x;
                to.rawData[1] = from.y;
                to.rawData[2] = from.z;
            };
            CannonJSPlugin.prototype.QuatCopy = function (from, to) {
                to.rawData[0] = from.x;
                to.rawData[1] = from.y;
                to.rawData[2] = from.z;
                to.rawData[3] = from.w;
            };
            CannonJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {
                this.vec3Copy(impostor.physicsBody.position, impostor.object.localPosition);
                this.QuatCopy(impostor.physicsBody.quaternion, impostor.object.localRotate);
            };
            CannonJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {
                impostor.physicsBody.position.copy(newPosition);
                impostor.physicsBody.quaternion.copy(newRotation);
            };
            CannonJSPlugin.prototype.isSupported = function () {
                return BJSCANNON !== undefined;
            };
            CannonJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {
                impostor.physicsBody.velocity.copy(velocity);
            };
            CannonJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {
                impostor.physicsBody.angularVelocity.copy(velocity);
            };
            CannonJSPlugin.prototype.getLinearVelocity = function (impostor) {
                var v = impostor.physicsBody.velocity;
                if (!v) {
                    return null;
                }
                return new gd3d.math.vector3(v.x, v.y, v.z);
            };
            CannonJSPlugin.prototype.getAngularVelocity = function (impostor) {
                var v = impostor.physicsBody.angularVelocity;
                if (!v) {
                    return null;
                }
                return new gd3d.math.vector3(v.x, v.y, v.z);
            };
            CannonJSPlugin.prototype.setBodyMass = function (impostor, mass) {
                impostor.physicsBody.mass = mass;
                impostor.physicsBody.updateMassProperties();
            };
            CannonJSPlugin.prototype.getBodyMass = function (impostor) {
                return impostor.physicsBody.mass;
            };
            CannonJSPlugin.prototype.getBodyFriction = function (impostor) {
                return impostor.physicsBody.material.friction;
            };
            CannonJSPlugin.prototype.setBodyFriction = function (impostor, friction) {
                impostor.physicsBody.material.friction = friction;
            };
            CannonJSPlugin.prototype.getBodyRestitution = function (impostor) {
                return impostor.physicsBody.material.restitution;
            };
            CannonJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {
                impostor.physicsBody.material.restitution = restitution;
            };
            CannonJSPlugin.prototype.sleepBody = function (impostor) {
                impostor.physicsBody.sleep();
            };
            CannonJSPlugin.prototype.isSleeping = function (impostor) {
                return false;
            };
            CannonJSPlugin.prototype.wakeUpBody = function (impostor) {
                impostor.physicsBody.wakeUp();
            };
            CannonJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {
                joint.physicsJoint.distance = maxDistance;
            };
            CannonJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {
                if (!motorIndex) {
                    joint.physicsJoint.enableMotor();
                    joint.physicsJoint.setMotorSpeed(speed);
                    if (maxForce) {
                        this.setLimit(joint, maxForce);
                    }
                }
            };
            CannonJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {
                joint.physicsJoint.motorEquation.maxForce = upperLimit;
                joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;
            };
            CannonJSPlugin.prototype.getRadius = function (impostor) {
                var shape = impostor.physicsBody.shapes[0];
                return shape.boundingSphereRadius;
            };
            CannonJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {
                var shape = impostor.physicsBody.shapes[0];
                result.x = shape.halfExtents.x * 2;
                result.y = shape.halfExtents.y * 2;
                result.z = shape.halfExtents.z * 2;
            };
            CannonJSPlugin.prototype.dispose = function () {
            };
            CannonJSPlugin.prototype._extendNamespace = function () {
                var step_tmp1 = new BJSCANNON.Vec3();
                var Engine = BJSCANNON;
                BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
                    maxSubSteps = maxSubSteps || 10;
                    timeSinceLastCalled = timeSinceLastCalled || 0;
                    if (timeSinceLastCalled === 0) {
                        this.internalStep(dt);
                        this.time += dt;
                    }
                    else {
                        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
                        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;
                        var t0 = performance.now();
                        for (var i = 0; i !== internalSteps; i++) {
                            this.internalStep(dt);
                            if (performance.now() - t0 > dt * 1000) {
                                break;
                            }
                        }
                        this.time += timeSinceLastCalled;
                        var h = this.time % dt;
                        var h_div_dt = h / dt;
                        var interpvelo = step_tmp1;
                        var bodies = this.bodies;
                        for (var j = 0; j !== bodies.length; j++) {
                            var b = bodies[j];
                            if (b.type !== Engine.Body.STATIC && b.sleepState !== Engine.Body.SLEEPING) {
                                b.position.vsub(b.previousPosition, interpvelo);
                                interpvelo.scale(h_div_dt, interpvelo);
                                b.position.vadd(interpvelo, b.interpolatedPosition);
                            }
                            else {
                                b.interpolatedPosition.copy(b.position);
                                b.interpolatedQuaternion.copy(b.quaternion);
                            }
                        }
                    }
                };
            };
            return CannonJSPlugin;
        }());
        framework.CannonJSPlugin = CannonJSPlugin;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var help_v3 = new gd3d.math.vector3();
        var help_v3_1 = new gd3d.math.vector3();
        var help_v3_2 = new gd3d.math.vector3();
        var help_quat = new gd3d.math.quaternion();
        var OimoJSPlugin = (function () {
            function OimoJSPlugin(iterations, oimoInjection) {
                if (oimoInjection === void 0) { oimoInjection = OIMO; }
                this.name = "OIMOJSPlugin";
                this._physicsMaterials = new Array();
                this._fixedTimeStep = 1 / 60;
                this._tmpImpostorsArray = [];
                this._tmpPositionVector = new gd3d.math.vector3();
                this.BJSOIMO = oimoInjection;
                if (!this.isSupported()) {
                    console.error("OIMO is not available. Please make sure you included the js file.");
                    return;
                }
                var opt = {
                    iterations: iterations,
                };
                this.world = new this.BJSOIMO.World(opt);
                this.world.clear();
            }
            OimoJSPlugin.prototype.setGravity = function (gravity) {
                this.world.gravity.copy(gravity);
            };
            OimoJSPlugin.prototype.setTimeStep = function (timeStep) {
                this.world.timeStep = timeStep;
            };
            OimoJSPlugin.prototype.getTimeStep = function () {
                return this.world.timeStep;
            };
            OimoJSPlugin.prototype.executeStep = function (delta, impostors) {
                var _this = this;
                impostors.forEach(function (impostor) {
                    impostor.beforeStep();
                });
                this.world.step();
                impostors.forEach(function (impostor) {
                    impostor.afterStep();
                    _this._tmpImpostorsArray[impostor.uniqueId] = impostor;
                });
                var contact = this.world.contacts;
                while (contact !== null) {
                    if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {
                        contact = contact.next;
                        continue;
                    }
                    var mainImpostor = this._tmpImpostorsArray[+contact.body1.name];
                    var collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];
                    if (!mainImpostor || !collidingImpostor) {
                        contact = contact.next;
                        continue;
                    }
                    mainImpostor.onCollide({ body: collidingImpostor.physicsBody });
                    collidingImpostor.onCollide({ body: mainImpostor.physicsBody });
                    contact = contact.next;
                }
            };
            OimoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {
                var mass = impostor.physicsBody.mass;
                var _point = help_v3;
                gd3d.math.vec3ScaleByNum(contactPoint, this.world.invScale, _point);
                var _force = help_v3_1;
                gd3d.math.vec3ScaleByNum(force, this.world.invScale * mass, _force);
                impostor.physicsBody.applyImpulse(_point, _force);
            };
            OimoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {
                console.warn("Oimo doesn't support applying force. Using impule instead.");
                this.applyImpulse(impostor, force, contactPoint);
            };
            OimoJSPlugin.prototype.checkWithEpsilon = function (value) {
                return Math.max(value, framework.PhysicsEngine.Epsilon);
            };
            OimoJSPlugin.prototype.generatePhysicsBody = function (impostor) {
                var _this = this;
                if (impostor.parent) {
                    if (impostor.physicsBody) {
                        this.removePhysicsBody(impostor);
                        impostor.forceUpdate();
                    }
                    return;
                }
                if (impostor.isBodyInitRequired()) {
                    var bodyConfig_1 = {
                        name: impostor.uniqueId,
                        config: [impostor.getParam("mass") || 1, impostor.getParam("friction"), impostor.getParam("restitution")],
                        size: [],
                        type: [],
                        pos: [],
                        posShape: [],
                        rot: [],
                        rotShape: [],
                        move: impostor.getParam("mass") !== 0,
                        density: impostor.getParam("mass"),
                        friction: impostor.getParam("friction"),
                        restitution: impostor.getParam("restitution"),
                        kinematic: impostor.getParam("kinematic"),
                        world: this.world
                    };
                    var impostors = [impostor];
                    if (impostor.object.children) {
                        impostor.object.children.forEach(function (m) {
                            if (m.physicsImpostor) {
                                impostors.push(m.physicsImpostor);
                            }
                        });
                    }
                    var globalQuat_1 = help_quat;
                    globalQuat_1.x = globalQuat_1.y = globalQuat_1.z = 0;
                    globalQuat_1.w = 1;
                    var wPos_impostor_1 = impostor.object.getWorldPosition();
                    impostors.forEach(function (i) {
                        var oldQuaternion = i.object.localRotate;
                        gd3d.math.quatClone(i.object.localRotate, globalQuat_1);
                        var rot = help_v3;
                        gd3d.math.quatToEulerAngles(oldQuaternion, rot);
                        console.log(_this._tmpPositionVector);
                        var extendSize = i.getObjectExtendSize();
                        var radToDeg = 57.295779513082320876;
                        if (i === impostor) {
                            var center = impostor.getObjectCenter();
                            bodyConfig_1.pos.push(center.x);
                            bodyConfig_1.pos.push(center.y);
                            bodyConfig_1.pos.push(center.z);
                            bodyConfig_1.posShape.push(0, 0, 0);
                            bodyConfig_1.rotShape.push(0, 0, 0);
                        }
                        else {
                            var localPosition = help_v3_2;
                            gd3d.math.vec3Subtract(i.object.getWorldPosition(), wPos_impostor_1, localPosition);
                            bodyConfig_1.posShape.push(localPosition.x);
                            bodyConfig_1.posShape.push(localPosition.y);
                            bodyConfig_1.posShape.push(localPosition.z);
                            bodyConfig_1.rotShape.push(rot.x * radToDeg);
                            bodyConfig_1.rotShape.push(rot.y * radToDeg);
                            bodyConfig_1.rotShape.push(rot.z * radToDeg);
                        }
                        var sizeX, sizeY, sizeZ;
                        switch (i.type) {
                            case framework.ImpostorType.ParticleImpostor:
                                console.warn("No Particle support in OIMO.js. using SphereImpostor instead");
                            case framework.ImpostorType.SphereImpostor:
                                var radiusX = extendSize.x;
                                var radiusY = extendSize.y;
                                var radiusZ = extendSize.z;
                                var size = Math.max(_this.checkWithEpsilon(radiusX), _this.checkWithEpsilon(radiusY), _this.checkWithEpsilon(radiusZ)) / 2;
                                bodyConfig_1.type.push('sphere');
                                bodyConfig_1.size.push(size);
                                bodyConfig_1.size.push(size);
                                bodyConfig_1.size.push(size);
                                break;
                            case framework.ImpostorType.CylinderImpostor:
                                sizeX = _this.checkWithEpsilon(extendSize.x) / 2;
                                sizeY = _this.checkWithEpsilon(extendSize.y);
                                bodyConfig_1.type.push('cylinder');
                                bodyConfig_1.size.push(sizeX);
                                bodyConfig_1.size.push(sizeY);
                                bodyConfig_1.size.push(sizeY);
                                break;
                            case framework.ImpostorType.PlaneImpostor:
                            case framework.ImpostorType.NoImpostor:
                            case framework.ImpostorType.BoxImpostor:
                            default:
                                sizeX = _this.checkWithEpsilon(extendSize.x);
                                sizeY = _this.checkWithEpsilon(extendSize.y);
                                sizeZ = _this.checkWithEpsilon(extendSize.z);
                                bodyConfig_1.type.push('box');
                                bodyConfig_1.size.push(sizeX);
                                bodyConfig_1.size.push(sizeY);
                                bodyConfig_1.size.push(sizeZ);
                                break;
                        }
                        i.object.localRotate = oldQuaternion;
                    });
                    impostor.physicsBody = this.world.add(bodyConfig_1);
                    impostor.physicsBody.resetQuaternion(globalQuat_1);
                    impostor.physicsBody.updatePosition(0);
                    var massCenter = help_v3;
                    var p = impostor.physicsBody.position;
                    gd3d.math.vec3Set(massCenter, p.x, p.y, p.z);
                    impostor.physicsBody.position;
                    var wpos = impostor.object.getWorldPosition();
                    if (!gd3d.math.vec3Equal(massCenter, wpos)) {
                        var scale = help_v3_1;
                        gd3d.math.vec3Clone(impostor.object.getWorldScale(), scale);
                        scale.x = 1 / scale.x;
                        scale.y = 1 / scale.y;
                        scale.z = 1 / scale.z;
                        gd3d.math.vec3Subtract(wpos, massCenter, this._tmpPositionVector);
                        gd3d.math.vec3ScaleByVec3(this._tmpPositionVector, scale, this._tmpPositionVector);
                    }
                }
                else {
                    this._tmpPositionVector.x = this._tmpPositionVector.y = this._tmpPositionVector.z = 0;
                }
                impostor.setDeltaPosition(this._tmpPositionVector);
            };
            OimoJSPlugin.prototype.removePhysicsBody = function (impostor) {
                this.world.removeRigidBody(impostor.physicsBody);
            };
            OimoJSPlugin.prototype.generateJoint = function (impostorJoint) {
                var mainBody = impostorJoint.mainImpostor.physicsBody;
                var connectedBody = impostorJoint.connectedImpostor.physicsBody;
                if (!mainBody || !connectedBody) {
                    return;
                }
                var jointData = impostorJoint.joint.jointData;
                var options = jointData.nativeParams || {};
                var type;
                var nativeJointData = {
                    body1: mainBody,
                    body2: connectedBody,
                    axe1: options.axe1 || (jointData.mainAxis ? framework.physicTool.vec3AsArray(jointData.mainAxis) : null),
                    axe2: options.axe2 || (jointData.connectedAxis ? framework.physicTool.vec3AsArray(jointData.connectedAxis) : null),
                    pos1: options.pos1 || (jointData.mainPivot ? framework.physicTool.vec3AsArray(jointData.mainPivot) : null),
                    pos2: options.pos2 || (jointData.connectedPivot ? framework.physicTool.vec3AsArray(jointData.connectedPivot) : null),
                    min: options.min,
                    max: options.max,
                    collision: options.collision || jointData.collision,
                    spring: options.spring,
                    world: this.world
                };
                switch (impostorJoint.joint.type) {
                    case framework.PhysicsJoint.BallAndSocketJoint:
                        type = "jointBall";
                        break;
                    case framework.PhysicsJoint.SpringJoint:
                        console.warn("OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead");
                        var springData = jointData;
                        nativeJointData.min = springData.length || nativeJointData.min;
                        nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);
                    case framework.PhysicsJoint.DistanceJoint:
                        type = "jointDistance";
                        nativeJointData.max = jointData.maxDistance;
                        break;
                    case framework.PhysicsJoint.PrismaticJoint:
                        type = "jointPrisme";
                        break;
                    case framework.PhysicsJoint.SliderJoint:
                        type = "jointSlide";
                        break;
                    case framework.PhysicsJoint.WheelJoint:
                        type = "jointWheel";
                        break;
                    case framework.PhysicsJoint.HingeJoint:
                    default:
                        type = "jointHinge";
                        break;
                }
                nativeJointData.type = type;
                impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);
            };
            OimoJSPlugin.prototype.removeJoint = function (impostorJoint) {
                try {
                    this.world.removeConstraint(impostorJoint.joint.physicsJoint);
                }
                catch (e) {
                    console.warn(e);
                }
            };
            OimoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {
                framework.physicTool.Ivec3Copy(impostor.physicsBody.position, impostor.object.localPosition);
                framework.physicTool.IQuatCopy(impostor.physicsBody.quaternion, impostor.object.localRotate);
                var obj = impostor.object;
                if (obj.parent && obj.parent.parent) {
                    obj.setWorldRotate(obj.localRotate);
                    obj.setWorldPosition(obj.localPosition);
                }
            };
            OimoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {
                impostor.physicsBody.position.copy(newPosition);
                impostor.physicsBody.quaternion.copy(newRotation);
                impostor.physicsBody.syncShapes();
                impostor.physicsBody.awake();
            };
            OimoJSPlugin.prototype.isSupported = function () {
                return this.BJSOIMO !== undefined;
            };
            OimoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {
                impostor.physicsBody.velocity.copy(velocity);
            };
            OimoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {
                impostor.physicsBody.angularVelocity.copy(velocity);
            };
            OimoJSPlugin.prototype.getLinearVelocity = function (impostor) {
                var v = impostor.physicsBody.velocity;
                if (!v) {
                    return null;
                }
                return new gd3d.math.vector3(v.x, v.y, v.z);
            };
            OimoJSPlugin.prototype.getAngularVelocity = function (impostor) {
                var v = impostor.physicsBody.angularVelocity;
                if (!v) {
                    return null;
                }
                return new gd3d.math.vector3(v.x, v.y, v.z);
            };
            OimoJSPlugin.prototype.setBodyMass = function (impostor, mass) {
                var staticBody = mass === 0;
                impostor.physicsBody.shapes.density = staticBody ? 1 : mass;
                impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);
            };
            OimoJSPlugin.prototype.getBodyMass = function (impostor) {
                return impostor.physicsBody.shapes.density;
            };
            OimoJSPlugin.prototype.getBodyFriction = function (impostor) {
                return impostor.physicsBody.shapes.friction;
            };
            OimoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {
                impostor.physicsBody.shapes.friction = friction;
            };
            OimoJSPlugin.prototype.getBodyRestitution = function (impostor) {
                return impostor.physicsBody.shapes.restitution;
            };
            OimoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {
                impostor.physicsBody.shapes.restitution = restitution;
            };
            OimoJSPlugin.prototype.sleepBody = function (impostor) {
                impostor.physicsBody.sleep();
            };
            OimoJSPlugin.prototype.isSleeping = function (impostor) {
                return impostor.physicsBody.sleeping;
            };
            OimoJSPlugin.prototype.wakeUpBody = function (impostor) {
                impostor.physicsBody.awake();
            };
            OimoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {
                joint.physicsJoint.limitMotor.upperLimit = maxDistance;
                if (minDistance !== void 0) {
                    joint.physicsJoint.limitMotor.lowerLimit = minDistance;
                }
            };
            OimoJSPlugin.prototype.setMotor = function (joint, speed, force, motorIndex) {
                if (force !== undefined) {
                    console.warn("OimoJS plugin currently has unexpected behavior when using setMotor with force parameter");
                }
                else {
                    force = 1e6;
                }
                speed *= -1;
                var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
                if (motor) {
                    motor.setMotor(speed, force);
                }
            };
            OimoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit, motorIndex) {
                var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
                if (motor) {
                    motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);
                }
            };
            OimoJSPlugin.prototype.getRadius = function (impostor) {
                return impostor.physicsBody.shapes.radius;
            };
            OimoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {
                var shape = impostor.physicsBody.shapes;
                result.x = shape.halfWidth * 2;
                result.y = shape.halfHeight * 2;
                result.z = shape.halfDepth * 2;
            };
            OimoJSPlugin.prototype.dispose = function () {
                this.world.clear();
            };
            return OimoJSPlugin;
        }());
        framework.OimoJSPlugin = OimoJSPlugin;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PhysicsEngine = (function () {
            function PhysicsEngine(gravity, _physicsPlugin) {
                if (gravity === void 0) { gravity = null; }
                if (_physicsPlugin === void 0) { _physicsPlugin = new framework.CannonJSPlugin(); }
                this._physicsPlugin = _physicsPlugin;
                this._impostors = [];
                this._joints = [];
                if (!this._physicsPlugin.isSupported()) {
                    throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. "
                        + "Please make sure it is included.");
                }
                gravity = gravity || new gd3d.math.vector3(0, -9.807, 0);
                this.setGravity(gravity);
                this.setTimeStep();
            }
            PhysicsEngine.prototype.setGravity = function (gravity) {
                this.gravity = gravity;
                this._physicsPlugin.setGravity(this.gravity);
            };
            PhysicsEngine.prototype.setTimeStep = function (newTimeStep) {
                if (newTimeStep === void 0) { newTimeStep = 1 / 60; }
                this._physicsPlugin.setTimeStep(newTimeStep);
            };
            PhysicsEngine.prototype.getTimeStep = function () {
                return this._physicsPlugin.getTimeStep();
            };
            PhysicsEngine.prototype.dispose = function () {
                this._impostors.forEach(function (impostor) {
                    impostor.dispose();
                });
                this._physicsPlugin.dispose();
            };
            PhysicsEngine.prototype.getPhysicsPluginName = function () {
                return this._physicsPlugin.name;
            };
            PhysicsEngine.prototype.addImpostor = function (impostor) {
                impostor.uniqueId = this._impostors.push(impostor);
                this._physicsPlugin.generatePhysicsBody(impostor);
            };
            PhysicsEngine.prototype.removeImpostor = function (impostor) {
                var index = this._impostors.indexOf(impostor);
                if (index > -1) {
                    var removed = this._impostors.splice(index, 1);
                    if (removed.length) {
                        removed[0].physicsBody = null;
                    }
                }
            };
            PhysicsEngine.prototype.addJoint = function (mainImpostor, connectedImpostor, joint) {
                var impostorJoint = {
                    mainImpostor: mainImpostor,
                    connectedImpostor: connectedImpostor,
                    joint: joint
                };
                joint.physicsPlugin = this._physicsPlugin;
                this._joints.push(impostorJoint);
                this._physicsPlugin.generateJoint(impostorJoint);
            };
            PhysicsEngine.prototype.removeJoint = function (mainImpostor, connectedImpostor, joint) {
                var matchingJoints = this._joints.filter(function (impostorJoint) {
                    return (impostorJoint.connectedImpostor === connectedImpostor
                        && impostorJoint.joint === joint
                        && impostorJoint.mainImpostor === mainImpostor);
                });
                if (matchingJoints.length) {
                    this._physicsPlugin.removeJoint(matchingJoints[0]);
                }
            };
            PhysicsEngine.prototype._step = function (delta) {
                var _this = this;
                this._impostors.forEach(function (impostor) {
                    if (impostor.isBodyInitRequired()) {
                        _this._physicsPlugin.generatePhysicsBody(impostor);
                    }
                });
                if (delta > 0.1) {
                    delta = 0.1;
                }
                else if (delta <= 0) {
                    delta = 1.0 / 60.0;
                }
                this._physicsPlugin.executeStep(delta, this._impostors);
            };
            PhysicsEngine.prototype.getPhysicsPlugin = function () {
                return this._physicsPlugin;
            };
            PhysicsEngine.prototype.getImpostors = function () {
                return this._impostors;
            };
            PhysicsEngine.prototype.getImpostorForPhysicsObject = function (object) {
                for (var i = 0; i < this._impostors.length; ++i) {
                    if (this._impostors[i].object === object) {
                        return this._impostors[i];
                    }
                }
                return null;
            };
            PhysicsEngine.prototype.getImpostorWithPhysicsBody = function (body) {
                for (var i = 0; i < this._impostors.length; ++i) {
                    if (this._impostors[i].physicsBody === body) {
                        return this._impostors[i];
                    }
                }
                return null;
            };
            PhysicsEngine.Epsilon = 0.001;
            return PhysicsEngine;
        }());
        framework.PhysicsEngine = PhysicsEngine;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var help_v3 = new gd3d.math.vector3();
        var help_v3_1 = new gd3d.math.vector3();
        var help_quat = new gd3d.math.quaternion();
        var PhysicsImpostor = (function () {
            function PhysicsImpostor(object, type, _options) {
                var _this = this;
                if (_options === void 0) { _options = { mass: 0 }; }
                this.object = object;
                this.type = type;
                this._options = _options;
                this._bodyUpdateRequired = false;
                this._onBeforePhysicsStepCallbacks = new Array();
                this._onAfterPhysicsStepCallbacks = new Array();
                this._onPhysicsCollideCallbacks = [];
                this._deltaPosition = new gd3d.math.vector3();
                this._isDisposed = false;
                this._cacheSizeWorld = new gd3d.math.vector3();
                this.lastObjwPos = new gd3d.math.vector3();
                this.lastObjwRot = new gd3d.math.quaternion();
                this.beforeStep = function () {
                    if (!_this._physicsEngine) {
                        return;
                    }
                    var wpos = _this.object.getWorldPosition();
                    var wrot = _this.object.getWorldRotate();
                    var hasDirty = !gd3d.math.vec3Equal(wpos, _this.lastObjwPos) || !gd3d.math.quatEqual(wrot, _this.lastObjwRot);
                    gd3d.math.vec3Clone(wpos, _this.lastObjwPos);
                    gd3d.math.quatClone(wrot, _this.lastObjwRot);
                    var offset_wpos = help_v3;
                    gd3d.math.vec3Clone(_this._deltaPosition, offset_wpos);
                    gd3d.math.vec3ScaleByNum(offset_wpos, -1, offset_wpos);
                    gd3d.math.vec3Add(wpos, offset_wpos, offset_wpos);
                    if (hasDirty && !_this._options.disableBidirectionalTransformation) {
                        _this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(_this, offset_wpos, wrot);
                    }
                    _this._onBeforePhysicsStepCallbacks.forEach(function (func) {
                        func(_this);
                    });
                };
                this._freezeMask = 0;
                this.lastbodywPos = new gd3d.math.vector3();
                this.lastbodywRot = new gd3d.math.quaternion();
                this.lastEuler = new gd3d.math.vector3();
                this.lastRotMask = 0;
                this.afterStep = function () {
                    if (!_this._physicsEngine) {
                        return;
                    }
                    _this._onAfterPhysicsStepCallbacks.forEach(function (func) {
                        func(_this);
                    });
                    var lwpos = _this.lastbodywPos;
                    var lwrot = _this.lastbodywRot;
                    var posDirty = !framework.physicTool.Ivec3Equal(_this.physicsBody.position, lwpos);
                    var rotDirty = !framework.physicTool.IQuatEqual(_this.physicsBody.quaternion, lwrot);
                    if (_this._freezeMask > 0) {
                        if (posDirty) {
                            var pPos = _this._physicsBody.position;
                            var linearVelocity = _this._physicsBody.linearVelocity;
                            if (_this.getFreeze(FreezeType.Position_x)) {
                                pPos.x = lwpos.x;
                                linearVelocity.x = 0;
                            }
                            if (_this.getFreeze(FreezeType.Position_y)) {
                                pPos.y = lwpos.y;
                                linearVelocity.y = 0;
                            }
                            if (_this.getFreeze(FreezeType.Position_z)) {
                                pPos.z = lwpos.z;
                                linearVelocity.z = 0;
                            }
                        }
                        if (rotDirty) {
                            var l_x = _this.getFreeze(FreezeType.Rotation_x);
                            var l_y = _this.getFreeze(FreezeType.Rotation_y);
                            var l_z = _this.getFreeze(FreezeType.Rotation_z);
                            var pRot = _this._physicsBody.quaternion;
                            var angularVelocity = _this._physicsBody.angularVelocity;
                            if (!l_x || !l_y || !l_z) {
                                var Euler = help_v3;
                                framework.physicTool.IQuatCopy(pRot, help_quat);
                                gd3d.math.quatToEulerAngles(help_quat, Euler);
                                var lEuler = _this.lastEuler;
                                var mask_ = l_x ? 1 : 0 | l_y ? 2 : 0 | l_z ? 4 : 0;
                                if (mask_ != _this.lastRotMask) {
                                    gd3d.math.quatToEulerAngles(lwrot, lEuler);
                                }
                                _this.lastRotMask = mask_;
                                var t_x = lEuler.x;
                                var t_y = lEuler.y;
                                var t_z = lEuler.z;
                                if (_this.getFreeze(FreezeType.Rotation_x)) {
                                    angularVelocity.x = 0;
                                }
                                else {
                                    t_x = Euler.x;
                                }
                                if (_this.getFreeze(FreezeType.Rotation_y)) {
                                    angularVelocity.y = 0;
                                }
                                else {
                                    t_y = Euler.y;
                                }
                                if (_this.getFreeze(FreezeType.Rotation_z)) {
                                    angularVelocity.z = 0;
                                }
                                else {
                                    t_z = Euler.z;
                                }
                                gd3d.math.quatFromEulerAngles(t_x, t_y, t_z, help_quat);
                                framework.physicTool.IQuatCopy(help_quat, pRot);
                            }
                            else {
                                angularVelocity.x = angularVelocity.y = angularVelocity.z = 0;
                                framework.physicTool.IQuatCopy(lwrot, pRot);
                            }
                        }
                    }
                    framework.physicTool.Ivec3Copy(_this.physicsBody.position, lwpos);
                    framework.physicTool.IQuatCopy(_this.physicsBody.quaternion, lwrot);
                    if (!posDirty && !rotDirty)
                        return;
                    _this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(_this);
                    var tempv3 = help_v3;
                    gd3d.math.vec3Add(_this.object.getWorldPosition(), _this._deltaPosition, tempv3);
                    _this.object.setWorldPosition(tempv3);
                };
                this.onCollideEvent = null;
                this.onCollide = function (e) {
                    if (!_this._onPhysicsCollideCallbacks.length && !_this.onCollideEvent) {
                        return;
                    }
                    if (!_this._physicsEngine) {
                        return;
                    }
                    var otherImpostor = _this._physicsEngine.getImpostorWithPhysicsBody(e.body);
                    if (otherImpostor) {
                        if (_this.onCollideEvent) {
                            _this.onCollideEvent(_this, otherImpostor);
                        }
                        _this._onPhysicsCollideCallbacks.filter(function (obj) {
                            return obj.otherImpostors.indexOf(otherImpostor) !== -1;
                        }).forEach(function (obj) {
                            obj.callback(_this, otherImpostor);
                        });
                    }
                };
                this._physicsEngine = framework.physic;
                if (!this.object) {
                    console.error("No object was provided. A physics object is obligatory");
                    return;
                }
                if (!this._physicsEngine) {
                    console.error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
                    return;
                }
                {
                    this._options.mass = (_options.mass === void 0) ? 0 : _options.mass;
                    this._options.friction = (_options.friction === void 0) ? 0.2 : _options.friction;
                    this._options.restitution = (_options.restitution === void 0) ? 0.2 : _options.restitution;
                    this._joints = [];
                    if (!this.object.parent || (this.object.scene && this.object.parent == this.object.scene.getRoot()) || this._options.ignoreParent) {
                        this._init();
                    }
                    else if (this.object.parent && this.object.parent.physicsImpostor) {
                        console.warn("You must affect impostors to children before affecting impostor to parent.");
                    }
                    if (this.object)
                        this.object.physicsImpostor = this;
                }
            }
            Object.defineProperty(PhysicsImpostor.prototype, "isDisposed", {
                get: function () {
                    return this._isDisposed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "mass", {
                get: function () {
                    return this._physicsEngine.getPhysicsPlugin().getBodyMass(this);
                },
                set: function (value) {
                    this.setMass(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "friction", {
                get: function () {
                    return this._physicsEngine.getPhysicsPlugin().getBodyFriction(this);
                },
                set: function (value) {
                    this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "restitution", {
                get: function () {
                    return this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this);
                },
                set: function (value) {
                    this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
                },
                enumerable: true,
                configurable: true
            });
            PhysicsImpostor.prototype._init = function () {
                if (!this._physicsEngine) {
                    return;
                }
                this._physicsEngine.removeImpostor(this);
                this.physicsBody = null;
                this._parent = this._parent || this._getPhysicsParent();
                if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
                    this._physicsEngine.addImpostor(this);
                }
            };
            PhysicsImpostor.prototype._getPhysicsParent = function () {
                if (this.object && this.object.parent) {
                    return this.object.parent.physicsImpostor;
                }
                return null;
            };
            PhysicsImpostor.prototype.isBodyInitRequired = function () {
                return this._bodyUpdateRequired || !this._physicsBody;
            };
            PhysicsImpostor.prototype.setScalingUpdated = function (updated) {
                this.forceUpdate();
            };
            PhysicsImpostor.prototype.forceUpdate = function () {
                this._init();
                if (this.parent && !this._options.ignoreParent) {
                    this.parent.forceUpdate();
                }
            };
            Object.defineProperty(PhysicsImpostor.prototype, "physicsBody", {
                get: function () {
                    return this._physicsBody;
                },
                set: function (physicsBody) {
                    if (this._physicsBody && this._physicsEngine) {
                        this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
                    }
                    this._physicsBody = physicsBody;
                    this.resetUpdateFlags();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "parent", {
                get: function () {
                    return !this._options.ignoreParent && this._parent ? this._parent : null;
                },
                set: function (value) {
                    this._parent = value;
                },
                enumerable: true,
                configurable: true
            });
            PhysicsImpostor.prototype.resetUpdateFlags = function () {
                this._bodyUpdateRequired = false;
            };
            PhysicsImpostor.prototype.getObb = function () {
                if (!this.object || !(this.object instanceof framework.transform)) {
                    return null;
                }
                if (!this._obb) {
                    var go = this.object.gameObject;
                    var mf = go.getComponent("meshFilter");
                    if (!mf)
                        return null;
                    var min = help_v3;
                    var max = help_v3_1;
                    mf.getMeshOutput().calcVectexMinMax(min, max);
                    this._obb = new framework.obb();
                    this._obb.buildByMaxMin(min, max);
                }
                this._obb.update(this.object.getWorldMatrix());
                return this._obb;
            };
            PhysicsImpostor.prototype.getObjectExtendSize = function () {
                var tempObb = this.getObb();
                if (!tempObb)
                    return PhysicsImpostor.DEFAULT_OBJECT_SIZE;
                gd3d.math.vec3Clone(tempObb.halfSizeWorld, this._cacheSizeWorld);
                gd3d.math.vec3ScaleByNum(this._cacheSizeWorld, 2, this._cacheSizeWorld);
                return this._cacheSizeWorld;
            };
            PhysicsImpostor.prototype.getObjectCenter = function () {
                var tempObb = this.getObb();
                if (!tempObb)
                    return this.object.getWorldPosition();
                return tempObb.worldCenter;
            };
            PhysicsImpostor.prototype.getParam = function (paramName) {
                return this._options[paramName];
            };
            PhysicsImpostor.prototype.setParam = function (paramName, value) {
                this._options[paramName] = value;
                this._bodyUpdateRequired = true;
            };
            PhysicsImpostor.prototype.setMass = function (mass) {
                if (this.getParam("mass") !== mass) {
                    this.setParam("mass", mass);
                }
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
                }
            };
            PhysicsImpostor.prototype.getLinearVelocity = function () {
                return this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this);
            };
            PhysicsImpostor.prototype.setLinearVelocity = function (velocity) {
                this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
            };
            PhysicsImpostor.prototype.getAngularVelocity = function () {
                return this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this);
            };
            PhysicsImpostor.prototype.setAngularVelocity = function (velocity) {
                this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
            };
            PhysicsImpostor.prototype.executeNativeFunction = function (func) {
                if (this._physicsEngine) {
                    func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
                }
            };
            PhysicsImpostor.prototype.registerBeforePhysicsStep = function (func) {
                this._onBeforePhysicsStepCallbacks.push(func);
            };
            PhysicsImpostor.prototype.unregisterBeforePhysicsStep = function (func) {
                var index = this._onBeforePhysicsStepCallbacks.indexOf(func);
                if (index > -1) {
                    this._onBeforePhysicsStepCallbacks.splice(index, 1);
                }
                else {
                    console.warn("Function to remove was not found");
                }
            };
            PhysicsImpostor.prototype.registerAfterPhysicsStep = function (func) {
                this._onAfterPhysicsStepCallbacks.push(func);
            };
            PhysicsImpostor.prototype.unregisterAfterPhysicsStep = function (func) {
                var index = this._onAfterPhysicsStepCallbacks.indexOf(func);
                if (index > -1) {
                    this._onAfterPhysicsStepCallbacks.splice(index, 1);
                }
                else {
                    console.warn("Function to remove was not found");
                }
            };
            PhysicsImpostor.prototype.registerOnPhysicsCollide = function (collideAgainst, func) {
                var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
                this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
            };
            PhysicsImpostor.prototype.unregisterOnPhysicsCollide = function (collideAgainst, func) {
                var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
                var index = -1;
                var found = this._onPhysicsCollideCallbacks.some(function (cbDef, idx) {
                    if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
                        var sameList = cbDef.otherImpostors.every(function (impostor) {
                            return collidedAgainstList.indexOf(impostor) > -1;
                        });
                        if (sameList) {
                            index = idx;
                        }
                        return sameList;
                    }
                    return false;
                });
                if (found) {
                    this._onPhysicsCollideCallbacks.splice(index, 1);
                }
                else {
                    console.warn("Function to remove was not found");
                }
            };
            PhysicsImpostor.prototype.setFreeze = function (option, beSelect) {
                if (beSelect) {
                    this._freezeMask |= option;
                }
                else {
                    if (this._freezeMask & option) {
                        this._freezeMask ^= option;
                    }
                }
            };
            PhysicsImpostor.prototype.getFreeze = function (option) {
                return this._freezeMask & option;
            };
            PhysicsImpostor.prototype.applyForce = function (force, contactPoint) {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
                }
                return this;
            };
            PhysicsImpostor.prototype.applyImpulse = function (force, contactPoint) {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
                }
                return this;
            };
            PhysicsImpostor.prototype.createJoint = function (otherImpostor, jointType, jointData) {
                var joint = new framework.PhysicsJoint(jointType, jointData);
                this.addJoint(otherImpostor, joint);
                return this;
            };
            PhysicsImpostor.prototype.addJoint = function (otherImpostor, joint) {
                this._joints.push({
                    otherImpostor: otherImpostor,
                    joint: joint
                });
                if (this._physicsEngine) {
                    this._physicsEngine.addJoint(this, otherImpostor, joint);
                }
                return this;
            };
            PhysicsImpostor.prototype.sleep = function () {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().sleepBody(this);
                }
                return this;
            };
            Object.defineProperty(PhysicsImpostor.prototype, "isSleeping", {
                get: function () {
                    if (this._physicsEngine) {
                        return this._physicsEngine.getPhysicsPlugin().isSleeping(this);
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            PhysicsImpostor.prototype.wakeUp = function () {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
                }
                return this;
            };
            PhysicsImpostor.prototype.clone = function (newObject) {
                if (!newObject)
                    return null;
                return new PhysicsImpostor(newObject, this.type, this._options);
            };
            PhysicsImpostor.prototype.dispose = function () {
                var _this = this;
                if (!this._physicsEngine) {
                    return;
                }
                this._joints.forEach(function (j) {
                    if (_this._physicsEngine) {
                        _this._physicsEngine.removeJoint(_this, j.otherImpostor, j.joint);
                    }
                });
                this._physicsEngine.removeImpostor(this);
                if (this.parent) {
                    this.parent.forceUpdate();
                }
                else {
                }
                this._isDisposed = true;
            };
            PhysicsImpostor.prototype.setDeltaPosition = function (position) {
                gd3d.math.vec3Clone(position, this._deltaPosition);
            };
            PhysicsImpostor.prototype.setDeltaRotation = function (rotation) {
                if (!this._deltaRotation) {
                    this._deltaRotation = new gd3d.math.quaternion();
                }
                gd3d.math.quatClone(rotation, this._deltaRotation);
            };
            PhysicsImpostor.prototype.getBoxSizeToRef = function (result) {
                this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
                return this;
            };
            PhysicsImpostor.prototype.getRadius = function () {
                return this._physicsEngine.getPhysicsPlugin().getRadius(this);
            };
            PhysicsImpostor.prototype.kinematicSetPosition = function (position) {
                if (!this._physicsBody || !position)
                    return;
                this._physicsBody.setPosition(position);
            };
            PhysicsImpostor.prototype.kinematicSetRotation = function (rotation) {
                if (!this._physicsBody || !rotation)
                    return;
                this._physicsBody.setQuaternion(rotation);
            };
            PhysicsImpostor.DEFAULT_OBJECT_SIZE = new gd3d.math.vector3(0, 0, 0);
            PhysicsImpostor.IDENTITY_QUATERNION = new gd3d.math.quaternion();
            PhysicsImpostor._tmpVecs = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            PhysicsImpostor._tmpQuat = new gd3d.math.quaternion();
            return PhysicsImpostor;
        }());
        framework.PhysicsImpostor = PhysicsImpostor;
        var ImpostorType;
        (function (ImpostorType) {
            ImpostorType[ImpostorType["NoImpostor"] = 0] = "NoImpostor";
            ImpostorType[ImpostorType["SphereImpostor"] = 1] = "SphereImpostor";
            ImpostorType[ImpostorType["BoxImpostor"] = 2] = "BoxImpostor";
            ImpostorType[ImpostorType["PlaneImpostor"] = 3] = "PlaneImpostor";
            ImpostorType[ImpostorType["MeshImpostor"] = 4] = "MeshImpostor";
            ImpostorType[ImpostorType["CylinderImpostor"] = 7] = "CylinderImpostor";
            ImpostorType[ImpostorType["ParticleImpostor"] = 8] = "ParticleImpostor";
            ImpostorType[ImpostorType["HeightmapImpostor"] = 9] = "HeightmapImpostor";
            ImpostorType[ImpostorType["ConvexHullImpostor"] = 10] = "ConvexHullImpostor";
            ImpostorType[ImpostorType["RopeImpostor"] = 101] = "RopeImpostor";
            ImpostorType[ImpostorType["ClothImpostor"] = 102] = "ClothImpostor";
            ImpostorType[ImpostorType["SoftbodyImpostor"] = 103] = "SoftbodyImpostor";
        })(ImpostorType = framework.ImpostorType || (framework.ImpostorType = {}));
        var FreezeType;
        (function (FreezeType) {
            FreezeType[FreezeType["Position_x"] = 1] = "Position_x";
            FreezeType[FreezeType["Position_y"] = 2] = "Position_y";
            FreezeType[FreezeType["Position_z"] = 4] = "Position_z";
            FreezeType[FreezeType["Rotation_x"] = 8] = "Rotation_x";
            FreezeType[FreezeType["Rotation_y"] = 16] = "Rotation_y";
            FreezeType[FreezeType["Rotation_z"] = 32] = "Rotation_z";
        })(FreezeType = framework.FreezeType || (framework.FreezeType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PhysicsJoint = (function () {
            function PhysicsJoint(type, jointData) {
                this.type = type;
                this.jointData = jointData;
                jointData.nativeParams = jointData.nativeParams || {};
            }
            Object.defineProperty(PhysicsJoint.prototype, "physicsJoint", {
                get: function () {
                    return this._physicsJoint;
                },
                set: function (newJoint) {
                    if (this._physicsJoint) {
                    }
                    this._physicsJoint = newJoint;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PhysicsJoint.prototype, "physicsPlugin", {
                set: function (physicsPlugin) {
                    this._physicsPlugin = physicsPlugin;
                },
                enumerable: true,
                configurable: true
            });
            PhysicsJoint.prototype.executeNativeFunction = function (func) {
                func(this._physicsPlugin.world, this._physicsJoint);
            };
            PhysicsJoint.DistanceJoint = 0;
            PhysicsJoint.HingeJoint = 1;
            PhysicsJoint.BallAndSocketJoint = 2;
            PhysicsJoint.WheelJoint = 3;
            PhysicsJoint.SliderJoint = 4;
            PhysicsJoint.PrismaticJoint = 5;
            PhysicsJoint.UniversalJoint = 6;
            PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
            PhysicsJoint.PointToPointJoint = 8;
            PhysicsJoint.SpringJoint = 9;
            PhysicsJoint.LockJoint = 10;
            return PhysicsJoint;
        }());
        framework.PhysicsJoint = PhysicsJoint;
        var DistanceJoint = (function (_super) {
            __extends(DistanceJoint, _super);
            function DistanceJoint(jointData) {
                return _super.call(this, PhysicsJoint.DistanceJoint, jointData) || this;
            }
            DistanceJoint.prototype.updateDistance = function (maxDistance, minDistance) {
                this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
            };
            return DistanceJoint;
        }(PhysicsJoint));
        framework.DistanceJoint = DistanceJoint;
        var MotorEnabledJoint = (function (_super) {
            __extends(MotorEnabledJoint, _super);
            function MotorEnabledJoint(type, jointData) {
                return _super.call(this, type, jointData) || this;
            }
            MotorEnabledJoint.prototype.setMotor = function (force, maxForce) {
                this._physicsPlugin.setMotor(this, force || 0, maxForce);
            };
            MotorEnabledJoint.prototype.setLimit = function (upperLimit, lowerLimit) {
                this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
            };
            return MotorEnabledJoint;
        }(PhysicsJoint));
        framework.MotorEnabledJoint = MotorEnabledJoint;
        var HingeJoint = (function (_super) {
            __extends(HingeJoint, _super);
            function HingeJoint(jointData) {
                return _super.call(this, PhysicsJoint.HingeJoint, jointData) || this;
            }
            HingeJoint.prototype.setMotor = function (force, maxForce) {
                this._physicsPlugin.setMotor(this, force || 0, maxForce);
            };
            HingeJoint.prototype.setLimit = function (upperLimit, lowerLimit) {
                this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
            };
            return HingeJoint;
        }(MotorEnabledJoint));
        framework.HingeJoint = HingeJoint;
        var Hinge2Joint = (function (_super) {
            __extends(Hinge2Joint, _super);
            function Hinge2Joint(jointData) {
                return _super.call(this, PhysicsJoint.Hinge2Joint, jointData) || this;
            }
            Hinge2Joint.prototype.setMotor = function (force, maxForce, motorIndex) {
                if (motorIndex === void 0) { motorIndex = 0; }
                this._physicsPlugin.setMotor(this, force || 0, maxForce, motorIndex);
            };
            Hinge2Joint.prototype.setLimit = function (upperLimit, lowerLimit, motorIndex) {
                if (motorIndex === void 0) { motorIndex = 0; }
                this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
            };
            return Hinge2Joint;
        }(MotorEnabledJoint));
        framework.Hinge2Joint = Hinge2Joint;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var physicTool = (function () {
            function physicTool() {
            }
            physicTool.Ivec3Equal = function (a, b) {
                return a.x == b.x && a.y == b.y && a.z == b.z;
            };
            physicTool.IQuatEqual = function (a, b) {
                return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
            };
            physicTool.Ivec3Copy = function (from, to) {
                to.x = from.x;
                to.y = from.y;
                to.z = from.z;
            };
            physicTool.IQuatCopy = function (from, to) {
                to.x = from.x;
                to.y = from.y;
                to.z = from.z;
                to.w = from.w;
            };
            physicTool.vec3AsArray = function (vec3) {
                var result = [];
                result[0] = vec3.rawData[0];
                result[1] = vec3.rawData[1];
                result[2] = vec3.rawData[2];
                return result;
            };
            return physicTool;
        }());
        framework.physicTool = physicTool;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var HideFlags;
        (function (HideFlags) {
            HideFlags[HideFlags["None"] = 0] = "None";
            HideFlags[HideFlags["HideInHierarchy"] = 1] = "HideInHierarchy";
            HideFlags[HideFlags["HideInInspector"] = 2] = "HideInInspector";
            HideFlags[HideFlags["DontSaveInEditor"] = 4] = "DontSaveInEditor";
            HideFlags[HideFlags["NotEditable"] = 8] = "NotEditable";
            HideFlags[HideFlags["DontSaveInBuild"] = 16] = "DontSaveInBuild";
            HideFlags[HideFlags["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
            HideFlags[HideFlags["DontSave"] = 52] = "DontSave";
            HideFlags[HideFlags["HideAndDontSave"] = 61] = "HideAndDontSave";
        })(HideFlags = framework.HideFlags || (framework.HideFlags = {}));
        var nodeComponent = (function () {
            function nodeComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.comp = comp;
                this.init = init;
            }
            nodeComponent.ClassName = "nodeComponent";
            __decorate([
                gd3d.reflect.Field("INodeComponent"),
                __metadata("design:type", Object)
            ], nodeComponent.prototype, "comp", void 0);
            nodeComponent = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], nodeComponent);
            return nodeComponent;
        }());
        framework.nodeComponent = nodeComponent;
        var gameObject = (function () {
            function gameObject() {
                this.layer = framework.cullingmaskutil.maskTolayer(framework.CullingMask.default);
                this.tag = framework.StringUtil.builtinTag_Untagged;
                this.hideFlags = HideFlags.None;
                this.isStatic = false;
                this.components = [];
                this.componentsInit = [];
                this.componentsPlayed = [];
                this._visible = true;
            }
            gameObject.prototype.getScene = function () {
                return this.transform.scene;
            };
            Object.defineProperty(gameObject.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible && obj.transform.parent) {
                        obj = obj.transform.parent.gameObject;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(gameObject.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: true,
                configurable: true
            });
            ;
            gameObject.prototype.getName = function () {
                return this.transform.name;
            };
            gameObject.prototype.init = function (bePlay) {
                if (bePlay === void 0) { bePlay = false; }
                if (this.componentsInit.length > 0) {
                    for (var i = 0; i < this.componentsInit.length; i++) {
                        this.componentsInit[i].comp.start();
                        this.componentsInit[i].init = true;
                        if (bePlay)
                            this.componentsInit[i].comp.onPlay();
                        else
                            this.componentsPlayed.push(this.componentsInit[i]);
                    }
                    this.componentsInit.length = 0;
                }
                if (this.componentsPlayed.length > 0 && bePlay) {
                    this.componentsPlayed.forEach(function (item) {
                        item.comp.onPlay();
                    });
                    this.componentsPlayed.length = 0;
                }
            };
            gameObject.prototype.update = function (delta) {
                for (var _i = 0, _a = this.components; _i < _a.length; _i++) {
                    var item = _a[_i];
                    item.comp.update(delta);
                }
            };
            gameObject.prototype.addComponentDirect = function (comp) {
                this.transform.markHaveComponent();
                if (comp.gameObject != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.gameObject = this;
                var nodeObj = new nodeComponent(comp, false);
                var add = true;
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "effectbatcher") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                        this.transform.markHaveRendererComp();
                    }
                    else {
                        add = false;
                        console.warn("已经有一个渲染器的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    if (this.camera == null) {
                        this.camera = comp;
                    }
                    else {
                        add = false;
                        console.warn("已经有一个摄像机的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    if (this.light == null) {
                        this.light = comp;
                        console.warn("add light:" + this.transform.name);
                    }
                    else {
                        add = false;
                        console.warn("已经有一个灯光的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "spherecollider") == "1") {
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        add = false;
                        console.warn("已经有一个碰撞盒的组件了，不能俩");
                    }
                }
                if (add) {
                    this.components.push(nodeObj);
                    this.componentsInit.push(nodeObj);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCamera);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCanvasRender);
                }
                return comp;
            };
            gameObject.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            gameObject.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            gameObject.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this._getComponentsInChildren(type, this, components);
                return components;
            };
            gameObject.prototype._getComponentsInChildren = function (type, obj, array) {
                for (var i = 0; i < obj.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(obj.components[i].comp["__proto__"]);
                    if (cname == type) {
                        array.push(obj.components[i].comp);
                    }
                }
                for (var i_5 = 0; obj.transform.children != undefined && i_5 < obj.transform.children.length; i_5++) {
                    var _obj = obj.transform.children[i_5].gameObject;
                    this._getComponentsInChildren(type, _obj, array);
                }
            };
            gameObject.prototype.getComponentInParent = function (type) {
                var result = null;
                var _parent = this.transform.parent;
                while (result == null && _parent != null) {
                    result = _parent.gameObject.getComponent(type);
                    _parent = _parent.parent;
                }
                return result;
            };
            gameObject.prototype.addComponent = function (type) {
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("已经有一个" + type + "的组件了，不能俩");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "nodecomp": "1" });
                return this.addComponentDirect(comp);
            };
            gameObject.prototype.removeComponent = function (comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            gameObject.prototype.remove = function (comp) {
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    this.renderer = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    this.camera = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    this.light = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    this.collider = null;
                }
            };
            gameObject.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            gameObject.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    {
                        this.components[i].comp.remove();
                    }
                    this.remove(this.components[i].comp);
                }
                this.components.length = 0;
            };
            gameObject.prototype.dispose = function () {
                this.removeAllComponents();
            };
            gameObject.ClassName = "gameObject";
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("enum"),
                __metadata("design:type", Number)
            ], gameObject.prototype, "layer", void 0);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], gameObject.prototype, "tag", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], gameObject.prototype, "hideFlags", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], gameObject.prototype, "isStatic", void 0);
            __decorate([
                gd3d.reflect.Field("nodeComponent[]"),
                __metadata("design:type", Array)
            ], gameObject.prototype, "components", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Object)
            ], gameObject.prototype, "_visible", void 0);
            gameObject = __decorate([
                gd3d.reflect.SerializeType
            ], gameObject);
            return gameObject;
        }());
        framework.gameObject = gameObject;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var renderContext = (function () {
            function renderContext(webgl) {
                this.viewPortPixel = new gd3d.math.rect(0, 0, 0, 0);
                this.eyePos = new gd3d.math.vector4();
                this.matrixView = new gd3d.math.matrix();
                this.matrixProject = new gd3d.math.matrix();
                this.matrixModel = new gd3d.math.matrix();
                this._matrixWorld2Object = new gd3d.math.matrix();
                this.matrixModelViewProject = new gd3d.math.matrix;
                this.matrixModelView = new gd3d.math.matrix;
                this.matrixViewProject = new gd3d.math.matrix;
                this.floatTimer = 0;
                this.intLightCount = 0;
                this.vec4LightPos = new Float32Array(32);
                this.vec4LightDir = new Float32Array(32);
                this.vec4LightColor = new Float32Array(32);
                this.floatLightRange = new Float32Array(8);
                this.floatLightIntensity = new Float32Array(8);
                this.floatLightSpotAngleCos = new Float32Array(8);
                this._intLightCount = 0;
                this._lightCullingMask = [];
                this._vec4LightPos = new Float32Array(32);
                this._vec4LightDir = new Float32Array(32);
                this._vec4LightColor = new Float32Array(32);
                this._floatLightRange = new Float32Array(8);
                this._floatLightIntensity = new Float32Array(8);
                this._floatLightSpotAngleCos = new Float32Array(8);
                this.lightmap = null;
                this.lightmapUV = 1;
                this.lightmapOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.webgl = webgl;
            }
            Object.defineProperty(renderContext.prototype, "matrixWorld2Object", {
                get: function () {
                    gd3d.math.matrixInverse(this.matrixModel, this._matrixWorld2Object);
                    return this._matrixWorld2Object;
                },
                enumerable: true,
                configurable: true
            });
            renderContext.prototype.updateCamera = function (app, camera) {
                camera.calcViewPortPixel(app, this.viewPortPixel);
                var asp = this.viewPortPixel.w / this.viewPortPixel.h;
                camera.calcViewMatrix(this.matrixView);
                camera.calcProjectMatrix(asp, this.matrixProject);
                gd3d.math.matrixMultiply(this.matrixProject, this.matrixView, this.matrixViewProject);
                this.floatTimer = app.getTotalTime();
                var pso = camera.gameObject.transform.getWorldTranslate();
                this.eyePos.x = pso.x;
                this.eyePos.y = pso.y;
                this.eyePos.z = pso.z;
            };
            renderContext.prototype.updateLights = function (lights) {
                this._intLightCount = lights.length;
                this._lightCullingMask.length = 0;
                var dirt = gd3d.math.pool.new_vector3();
                for (var i = 0; i < lights.length; i++) {
                    this._lightCullingMask.push(lights[i].cullingMask);
                    {
                        var pos = lights[i].gameObject.transform.getWorldTranslate();
                        this._vec4LightPos[i * 4 + 0] = pos.x;
                        this._vec4LightPos[i * 4 + 1] = pos.y;
                        this._vec4LightPos[i * 4 + 2] = pos.z;
                        this._vec4LightPos[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Direction ? 0 : 1;
                        lights[i].gameObject.transform.getForwardInWorld(dirt);
                        this._vec4LightDir[i * 4 + 0] = dirt.x;
                        this._vec4LightDir[i * 4 + 1] = dirt.y;
                        this._vec4LightDir[i * 4 + 2] = dirt.z;
                        this._vec4LightDir[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Point ? 0 : 1;
                        this._floatLightSpotAngleCos[i] = lights[i].spotAngelCos;
                        this._vec4LightColor[i * 4 + 0] = lights[i].color.r;
                        this._vec4LightColor[i * 4 + 1] = lights[i].color.g;
                        this._vec4LightColor[i * 4 + 2] = lights[i].color.b;
                        this._vec4LightColor[i * 4 + 3] = lights[i].color.a;
                        this._floatLightRange[i] = lights[i].range;
                        this._floatLightIntensity[i] = lights[i].intensity;
                    }
                }
                gd3d.math.pool.delete_vector3(dirt);
            };
            renderContext.prototype.updateOverlay = function () {
                gd3d.math.matrixMakeIdentity(this.matrixModelViewProject);
            };
            renderContext.prototype.updateModel = function (model) {
                gd3d.math.matrixClone(model.getWorldMatrix(), this.matrixModel);
                gd3d.math.matrixMultiply(this.matrixViewProject, this.matrixModel, this.matrixModelViewProject);
            };
            renderContext.prototype.updateModeTrail = function () {
                gd3d.math.matrixClone(this.matrixView, this.matrixModelView);
                gd3d.math.matrixClone(this.matrixViewProject, this.matrixModelViewProject);
            };
            renderContext.prototype.updateLightMask = function (layer) {
                this.intLightCount = 0;
                if (this._intLightCount == 0)
                    return;
                var num = 1 << layer;
                var indexList = [];
                for (var i = 0; i < this._lightCullingMask.length; i++) {
                    var mask = this._lightCullingMask[i];
                    if (mask & num)
                        indexList.push(i);
                }
                this.intLightCount = indexList.length;
                for (var i = 0; i < indexList.length; i++) {
                    var idx = indexList[i];
                    this.floatLightSpotAngleCos[i] = this._floatLightSpotAngleCos[idx];
                    this.floatLightRange[i] = this._floatLightRange[idx];
                    this.floatLightIntensity[i] = this._floatLightIntensity[idx];
                    this.vec4LightPos[i * 4 + 0] = this._vec4LightPos[idx * 4 + 0];
                    this.vec4LightPos[i * 4 + 1] = this._vec4LightPos[idx * 4 + 1];
                    this.vec4LightPos[i * 4 + 2] = this._vec4LightPos[idx * 4 + 2];
                    this.vec4LightPos[i * 4 + 3] = this._vec4LightPos[idx * 4 + 3];
                    this.vec4LightDir[i * 4 + 0] = this._vec4LightDir[idx * 4 + 0];
                    this.vec4LightDir[i * 4 + 1] = this._vec4LightDir[idx * 4 + 1];
                    this.vec4LightDir[i * 4 + 2] = this._vec4LightDir[idx * 4 + 2];
                    this.vec4LightDir[i * 4 + 3] = this._vec4LightDir[idx * 4 + 3];
                    this.vec4LightColor[i * 4 + 0] = this._vec4LightColor[idx * 4 + 0];
                    this.vec4LightColor[i * 4 + 1] = this._vec4LightColor[idx * 4 + 1];
                    this.vec4LightColor[i * 4 + 2] = this._vec4LightColor[idx * 4 + 2];
                    this.vec4LightColor[i * 4 + 3] = this._vec4LightColor[idx * 4 + 3];
                }
            };
            return renderContext;
        }());
        framework.renderContext = renderContext;
        var RenderLayerEnum;
        (function (RenderLayerEnum) {
            RenderLayerEnum[RenderLayerEnum["Common"] = 0] = "Common";
            RenderLayerEnum[RenderLayerEnum["Transparent"] = 1] = "Transparent";
            RenderLayerEnum[RenderLayerEnum["Overlay"] = 2] = "Overlay";
        })(RenderLayerEnum = framework.RenderLayerEnum || (framework.RenderLayerEnum = {}));
        var renderList = (function () {
            function renderList() {
                this.renderLayers = [];
                var common = new renderLayer(false);
                var transparent = new renderLayer(true);
                var overlay = new renderLayer(true);
                this.renderLayers.push(common);
                this.renderLayers.push(transparent);
                this.renderLayers.push(overlay);
            }
            renderList.prototype.clear = function () {
                for (var i = 0; i < this.renderLayers.length; i++) {
                    this.renderLayers[i].list.length = 0;
                }
            };
            renderList.prototype.addRenderer = function (renderer) {
                if (renderer.layer == RenderLayerEnum.Common) {
                    this.renderLayers[0].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Transparent) {
                    this.renderLayers[1].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Overlay) {
                    this.renderLayers[2].list.push(renderer);
                }
            };
            return renderList;
        }());
        framework.renderList = renderList;
        var renderLayer = (function () {
            function renderLayer(_sort) {
                if (_sort === void 0) { _sort = false; }
                this.needSort = false;
                this.list = [];
                this.needSort = _sort;
            }
            return renderLayer;
        }());
        framework.renderLayer = renderLayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var scene = (function () {
            function scene(app) {
                this.renderCameras = [];
                this._mainCamera = null;
                this.renderContext = [];
                this.renderLights = [];
                this.lightmaps = [];
                this.RealCameraNumber = 0;
                this.app = app;
                this.webgl = app.webgl;
                this.assetmgr = app.getAssetMgr();
                this.rootNode = new framework.transform();
                this.rootNode.scene = this;
                this.renderList = new framework.renderList();
            }
            scene.prototype.addScreenSpaceOverlay = function (overlay) {
                if (!overlay)
                    return;
                if (!this._overlay2d)
                    this._overlay2d = [];
                if (this._overlay2d.indexOf(overlay) != -1)
                    return;
                this._overlay2d.push(overlay);
                this.sortOverLays(this._overlay2d);
            };
            scene.prototype.removeScreenSpaceOverlay = function (overlay) {
                if (!overlay || !this._overlay2d)
                    return;
                var idx = this._overlay2d.indexOf(overlay);
                if (idx != -1)
                    this._overlay2d.splice(idx, 1);
                this.sortOverLays(this._overlay2d);
            };
            Object.defineProperty(scene.prototype, "mainCamera", {
                get: function () {
                    if (this._mainCamera == null) {
                        this._mainCamera = this.renderCameras[0];
                    }
                    return this._mainCamera;
                },
                set: function (_camera) {
                    for (var i in this.renderCameras) {
                        if (this.renderCameras[i] == _camera) {
                            this._mainCamera = _camera;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            scene.prototype.update = function (delta) {
                this.renderCameras.length = 0;
                this.renderLights.length = 0;
                this.renderList.clear();
                this.updateScene(this.rootNode, delta);
                if (this.onLateUpdate)
                    this.onLateUpdate(delta);
                if (framework.physic) {
                    framework.physic._step(delta);
                }
                if (this.renderCameras.length > 1) {
                    this.renderCameras.sort(function (a, b) {
                        return a.order - b.order;
                    });
                }
                this.RealCameraNumber = 0;
                for (var i = 0; i < this.renderCameras.length; i++) {
                    gd3d.render.glDrawPass.resetLastState();
                    this._renderCamera(i);
                }
                this.updateSceneOverLay(delta);
                if (this.RealCameraNumber == 0) {
                    this.webgl.clearColor(0, 0, 0, 1);
                    this.webgl.clearDepth(1.0);
                    this.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
                }
                this.webgl.flush();
                if (framework.DrawCallInfo.BeActived) {
                    framework.DrawCallInfo.inc.showPerFrame();
                    framework.DrawCallInfo.inc.reset();
                }
            };
            scene.prototype.updateSceneOverLay = function (delta) {
                var _this = this;
                if (!this._overlay2d || this._overlay2d.length < 1)
                    return;
                var targetcamera = this.mainCamera;
                if (!this._overlay2d || !targetcamera)
                    return;
                var mainCamIdx = this.renderCameras.indexOf(targetcamera);
                if (mainCamIdx == -1) {
                    var cname = targetcamera.gameObject.getName();
                    var oktag = false;
                    for (var i = 0; i < this.renderCameras.length; i++) {
                        var cam = this.renderCameras[i];
                        if (cam && cam.gameObject.getName() == cname) {
                            targetcamera = this.mainCamera = cam;
                            oktag = true;
                            break;
                        }
                    }
                    if (!oktag) {
                        this._mainCamera = null;
                        targetcamera = this.mainCamera;
                    }
                }
                mainCamIdx = this.renderCameras.indexOf(targetcamera);
                if (!targetcamera)
                    return;
                if (this._overlay2d) {
                    this._overlay2d.forEach(function (overlay) {
                        if (overlay) {
                            overlay.start(targetcamera);
                            overlay.update(delta);
                            overlay.render(_this.renderContext[mainCamIdx], _this.assetmgr, targetcamera);
                        }
                    });
                }
            };
            scene.prototype._renderCamera = function (camindex) {
                var cam = this.renderCameras[camindex];
                var context = this.renderContext[camindex];
                if (this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") < 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    var overLays = cam.getOverLays();
                    for (var i = 0; i < overLays.length; i++) {
                        if (cam.CullingMask & framework.CullingMask.ui) {
                            overLays[i].render(context, this.assetmgr, cam);
                        }
                    }
                }
                else if (!this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") >= 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    if (this.app.be2dstate) {
                        var overLays = cam.getOverLays();
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
                if (!this.app.bePlay && this.app.be2dstate) {
                    if (camindex == this.app.curcameraindex) {
                        var overLays = cam.getOverLays();
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
            };
            scene.prototype.sortOverLays = function (lays) {
                if (!lays || lays.length < 1)
                    return;
                lays.sort(function (a, b) {
                    return a.sortOrder - b.sortOrder;
                });
            };
            scene.prototype.updateScene = function (node, delta) {
                if (this.app.bePlay) {
                    this.objupdate(node, delta);
                }
                else {
                    this.objupdateInEditor(node, delta);
                }
            };
            scene.prototype.objupdateInEditor = function (node, delta) {
                node.gameObject.init();
                if (node.gameObject.renderer != null) {
                    node.gameObject.renderer.update(delta);
                }
                var c = node.gameObject.camera;
                if (c != null) {
                    node.gameObject.camera.update(delta);
                }
                this.collectCameraAndLight(node);
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.objupdateInEditor(node.children[i], delta);
                    }
                }
            };
            scene.prototype.objupdate = function (node, delta) {
                if (node.hasComponent == false && node.hasComponentChild == false)
                    return;
                node.gameObject.init(this.app.bePlay);
                if (node.gameObject.components.length > 0) {
                    node.gameObject.update(delta);
                    this.collectCameraAndLight(node);
                }
                if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var item = _a[_i];
                        this.objupdate(item, delta);
                    }
                }
            };
            scene.prototype.collectCameraAndLight = function (node) {
                var c = node.gameObject.camera;
                if (c != null && c.gameObject.visibleInScene) {
                    this.renderCameras.push(c);
                }
                while (this.renderContext.length < this.renderCameras.length) {
                    this.renderContext.push(new framework.renderContext(this.webgl));
                }
                var l = node.gameObject.light;
                if (l != null && node.gameObject.visible) {
                    this.renderLights.push(l);
                }
            };
            scene.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            scene.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            scene.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            scene.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            scene.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            scene.prototype.getChildByName = function (name) {
                var res = this.rootNode.find(name);
                return res;
            };
            scene.prototype.getRoot = function () {
                return this.rootNode;
            };
            scene.prototype.pickAll = function (ray, outInfos, isPickMesh, root, layermask) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                if (root === void 0) { root = this.getRoot(); }
                if (layermask === void 0) { layermask = NaN; }
                if (!outInfos || !ray)
                    return false;
                var isHited = this.doPick(ray, true, isPickMesh, root, outInfos, layermask);
                return isHited;
            };
            scene.prototype.pick = function (ray, outInfo, isPickMesh, root, layermask) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                if (root === void 0) { root = this.getRoot(); }
                if (layermask === void 0) { layermask = NaN; }
                if (!outInfo || !ray)
                    return false;
                var isHited = this.doPick(ray, false, isPickMesh, root, outInfo, layermask);
                return isHited;
            };
            scene.prototype.doPick = function (ray, pickall, isPickMesh, root, out, layermask) {
                if (layermask === void 0) { layermask = NaN; }
                var ishited = false;
                var pickedList = new Array();
                if (isPickMesh) {
                    ishited = this.pickMesh(ray, root, pickedList, layermask);
                }
                else {
                    ishited = this.pickCollider(ray, root, pickedList, layermask);
                }
                if (pickedList.length == 0)
                    return ishited;
                if (pickall) {
                    out.length = 0;
                    pickedList.forEach(function (element) {
                        out.push(element);
                    });
                }
                else {
                    var index = 0;
                    for (var i = 1; i < pickedList.length; i++) {
                        if (pickedList[i].distance < pickedList[index].distance)
                            index = i;
                    }
                    var temp = pickedList.splice(index, 1);
                    out.cloneFrom(temp[0]);
                    pickedList.forEach(function (element) {
                        gd3d.math.pool.delete_pickInfo(element);
                    });
                    pickedList.length = 0;
                }
                return ishited;
            };
            scene.prototype.pickMesh = function (ray, tran, pickedList, layermask) {
                if (layermask === void 0) { layermask = NaN; }
                var ishited = false;
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return ishited;
                    var canDo = true;
                    if (!isNaN(layermask) && (layermask & (1 << tran.gameObject.layer)) == 0)
                        canDo = false;
                    if (canDo) {
                        var meshFilter = tran.gameObject.getComponent("meshFilter");
                        if (meshFilter != null) {
                            var mesh = meshFilter.getMeshOutput();
                            if (mesh) {
                                var pinfo = gd3d.math.pool.new_pickInfo();
                                var bool_1 = mesh.intersects(ray, tran.getWorldMatrix(), pinfo);
                                if (bool_1) {
                                    ishited = true;
                                    pickedList.push(pinfo);
                                    pinfo.pickedtran = tran;
                                }
                            }
                        }
                        else {
                            var skinmesh = tran.gameObject.getComponent("skinnedMeshRenderer");
                            if (skinmesh != null) {
                                var pinfo = gd3d.math.pool.new_pickInfo();
                                var bool = skinmesh.intersects(ray, pinfo);
                                if (bool) {
                                    ishited = true;
                                    pickedList.push(pinfo);
                                    pinfo.pickedtran = tran;
                                }
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        var bool_2 = this.pickMesh(ray, tran.children[i], pickedList, layermask);
                        if (!ishited)
                            ishited = bool_2;
                    }
                }
                return ishited;
            };
            scene.prototype.pickCollider = function (ray, tran, pickedList, layermask) {
                if (layermask === void 0) { layermask = NaN; }
                var ishited = false;
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return ishited;
                    if (tran.gameObject.collider != null) {
                        var canDo = true;
                        if (!isNaN(layermask) && (layermask & (1 << tran.gameObject.layer)) == 0)
                            canDo = false;
                        if (canDo) {
                            var pinfo = gd3d.math.pool.new_pickInfo();
                            var bool = ray.intersectCollider(tran, pinfo);
                            if (bool) {
                                ishited = true;
                                pickedList.push(pinfo);
                                pinfo.pickedtran = tran;
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        var bool_3 = this.pickCollider(ray, tran.children[i], pickedList, layermask);
                        if (!ishited)
                            ishited = bool_3;
                    }
                }
                return ishited;
            };
            scene.prototype.enablePhysics = function (gravity, plugin) {
                if (framework.physic) {
                    return true;
                }
                if (!plugin)
                    plugin = new framework.OimoJSPlugin();
                try {
                    framework.physic = new framework.PhysicsEngine(gravity, plugin);
                    return true;
                }
                catch (e) {
                    console.error(e.message);
                    return false;
                }
            };
            scene.prototype.enable2DPhysics = function () {
                framework.physic2D = new framework.physicEngine2D();
            };
            return scene;
        }());
        framework.scene = scene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var uniformSetter = (function () {
            function uniformSetter() {
            }
            uniformSetter.initAutouniform = function () {
                this.autoUniformDic["glstate_matrix_model"] = function (context) {
                    return context.matrixModel;
                };
                this.autoUniformDic["glstate_matrix_world2object"] = function (context) {
                    return context.matrixWorld2Object;
                };
                this.autoUniformDic["glstate_matrix_view"] = function (context) {
                    return context.matrixView;
                };
                this.autoUniformDic["glstate_matrix_project"] = function (context) {
                    return context.matrixProject;
                };
                this.autoUniformDic["glstate_matrix_modelview"] = function (context) {
                    return context.matrixModelView;
                };
                this.autoUniformDic["glstate_matrix_viewproject"] = function (context) {
                    return context.matrixViewProject;
                };
                this.autoUniformDic["glstate_matrix_mvp"] = function (context) {
                    return context.matrixModelViewProject;
                };
                this.autoUniformDic["glstate_timer"] = function (context) {
                    return context.floatTimer;
                };
                this.autoUniformDic["glstate_lightcount"] = function (context) {
                    return context.intLightCount;
                };
                this.autoUniformDic["glstate_vec4_lightposs"] = function (context) {
                    return context.vec4LightPos;
                };
                this.autoUniformDic["glstate_vec4_lightdirs"] = function (context) {
                    return context.vec4LightDir;
                };
                this.autoUniformDic["glstate_vec4_lightcolors"] = function (context) {
                    return context.vec4LightColor;
                };
                this.autoUniformDic["glstate_float_lightrange"] = function (context) {
                    return context.floatLightRange;
                };
                this.autoUniformDic["glstate_float_lightintensity"] = function (context) {
                    return context.floatLightIntensity;
                };
                this.autoUniformDic["glstate_float_spotangelcoss"] = function (context) {
                    return context.floatLightSpotAngleCos;
                };
                this.autoUniformDic["glstate_eyepos"] = function (context) {
                    return context.eyePos;
                };
                this.autoUniformDic["_LightmapTex"] = function (context) {
                    return context.lightmap;
                };
                this.autoUniformDic["glstate_lightmapOffset"] = function (context) {
                    return context.lightmapOffset;
                };
                this.autoUniformDic["glstate_fog_start"] = function (context) {
                    return context.fog._Start;
                };
                this.autoUniformDic["glstate_fog_end"] = function (context) {
                    return context.fog._End;
                };
                this.autoUniformDic["glstate_fog_color"] = function (context) {
                    return context.fog._Color;
                };
                this.autoUniformDic["glstate_vec4_bones"] = function (context) {
                    return context.vec4_bones;
                };
                this.autoUniformDic["glstate_matrix_bones"] = function (context) {
                    return context.matrix_bones;
                };
            };
            uniformSetter.autoUniformDic = {};
            return uniformSetter;
        }());
        framework.uniformSetter = uniformSetter;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var taskstate = (function () {
            function taskstate() {
                this.finish = false;
                this.error = false;
                this.message = null;
                this.cancel = false;
                this.taskCall = null;
                this.taskInterface = null;
            }
            return taskstate;
        }());
        framework.taskstate = taskstate;
        var taskMgr = (function () {
            function taskMgr() {
                this.tasks = [];
                this.laststate = null;
            }
            taskMgr.prototype.addTaskCall = function (task) {
                var st = new taskstate();
                st.taskCall = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.addTask = function (task) {
                var st = new taskstate();
                st.taskInterface = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.move = function (delta) {
                if (this.laststate != null && this.laststate.cancel) {
                    return;
                }
                if (this.laststate != null && this.laststate.finish == false) {
                    return;
                }
                var task = this.tasks.shift();
                if (task == null) {
                    return;
                }
                var state = new taskstate();
                var laststate = this.laststate;
                this.laststate = state;
                if (task.taskInterface == null) {
                    task.taskCall(laststate, state);
                }
                else {
                    task.taskInterface.move(delta, laststate, state);
                }
            };
            taskMgr.prototype.cancel = function () {
                if (this.laststate != null) {
                    this.laststate.cancel = true;
                }
            };
            return taskMgr;
        }());
        framework.taskMgr = taskMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var threading;
    (function (threading) {
        var gdPromise = (function () {
            function gdPromise(executor) {
                var _this = this;
                this.execQueue = new Array();
                setTimeout(function () {
                    executor(_this.resolve.bind(_this), _this.reject.bind(_this));
                }, 0);
            }
            gdPromise.prototype.resolve = function (value) {
                try {
                    while (this.execQueue.length > 0)
                        this.execQueue.shift()(value);
                }
                catch (e) {
                    this.reject(e);
                }
            };
            gdPromise.prototype.reject = function (reason) {
                console.error(reason);
                if (this.catchMethod)
                    return this.catchMethod(reason);
            };
            gdPromise.prototype.then = function (thenCall) {
                this.execQueue.push(thenCall);
                return this;
            };
            gdPromise.prototype.catch = function (callbcack) {
                this.catchMethod = callbcack;
                return this;
            };
            return gdPromise;
        }());
        threading.gdPromise = gdPromise;
    })(threading = gd3d.threading || (gd3d.threading = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var threading;
    (function (threading) {
        var thread = (function () {
            function thread() {
                var _this = this;
                this.callID = 0;
                this.callMap = {};
                if (!thread.workerInstance) {
                    this.worker = new Worker("lib/th.js");
                    this.worker.onmessage = function (e) {
                        _this.OnMessage(e);
                    };
                    this.worker.onerror = function (e) {
                        console.error(e);
                    };
                }
                else {
                    this.worker = thread.workerInstance;
                }
            }
            Object.defineProperty(thread, "Instance", {
                get: function () {
                    if (!thread.instance)
                        thread.instance = new thread();
                    return thread.instance;
                },
                enumerable: true,
                configurable: true
            });
            thread.prototype.OnMessage = function (e) {
                if (e.data && this.callMap[e.data.id]) {
                    this.callMap[e.data.id].callback(e.data.result);
                    delete this.callMap[e.data.id];
                }
            };
            thread.prototype.Call = function (name, data, callback) {
                this.worker.postMessage({
                    handle: name,
                    data: data,
                    id: ++this.callID
                });
                this.callMap[this.callID] = { callback: callback };
            };
            return thread;
        }());
        threading.thread = thread;
    })(threading = gd3d.threading || (gd3d.threading = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var aabb = (function () {
            function aabb(_minimum, _maximum) {
                this.opmin = new gd3d.math.vector3();
                this.opmax = new gd3d.math.vector3();
                this._center = new gd3d.math.vector3();
                this.srcmin = gd3d.math.pool.clone_vector3(_minimum);
                this.srcmax = gd3d.math.pool.clone_vector3(_maximum);
                this.minimum = gd3d.math.pool.clone_vector3(_minimum);
                this.maximum = gd3d.math.pool.clone_vector3(_maximum);
            }
            aabb.prototype.update = function (worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmin);
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmax);
                if (worldmatrix.rawData[0] > 0) {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmin.x;
                }
                if (worldmatrix.rawData[1] > 0) {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmin.y;
                }
                if (worldmatrix.rawData[2] > 0) {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmin.z;
                }
                if (worldmatrix.rawData[4] > 0) {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmin.x;
                }
                if (worldmatrix.rawData[5] > 0) {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmin.y;
                }
                if (worldmatrix.rawData[6] > 0) {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmin.z;
                }
                if (worldmatrix.rawData[8] > 0) {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmin.x;
                }
                if (worldmatrix.rawData[9] > 0) {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmin.y;
                }
                if (worldmatrix.rawData[10] > 0) {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmin.z;
                }
                this.minimum = gd3d.math.pool.clone_vector3(this.opmin);
                this.maximum = gd3d.math.pool.clone_vector3(this.opmax);
            };
            aabb.prototype.addVector3 = function (vec) {
                gd3d.math.vec3Max(this.maximum, vec, this.maximum);
                gd3d.math.vec3Max(this.minimum, vec, this.minimum);
            };
            aabb.prototype.containsVector3 = function (vec) {
                return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                    (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                    (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
            };
            aabb.prototype.intersectAABB = function (aabb) {
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                return true;
            };
            aabb.prototype.addAABB = function (aabb) {
                if (aabb != null) {
                    gd3d.math.vec3Max(this.maximum, aabb.maximum, this.maximum);
                    gd3d.math.vec3Min(this.minimum, aabb.minimum, this.minimum);
                }
            };
            Object.defineProperty(aabb.prototype, "center", {
                get: function () {
                    gd3d.math.vec3Add(this.maximum, this.minimum, this._center);
                    gd3d.math.vec3ScaleByNum(this._center, 0.5, this._center);
                    return this._center;
                },
                enumerable: true,
                configurable: true
            });
            aabb.prototype.clear = function () {
                gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
                gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
            };
            aabb.prototype.clone = function () {
                var _min = gd3d.math.pool.clone_vector3(this.minimum);
                var _max = gd3d.math.pool.clone_vector3(this.maximum);
                var aabb = new gd3d.framework.aabb(_min, _max);
                return aabb;
            };
            aabb.prototype.cloneTo = function (to) {
                gd3d.math.vec3Clone(this.minimum, to.minimum);
                gd3d.math.vec3Clone(this.minimum, to.srcmin);
                gd3d.math.vec3Clone(this.maximum, to.maximum);
                gd3d.math.vec3Clone(this.maximum, to.srcmax);
            };
            aabb.prototype.getVec3 = function (vecs) {
                vecs[0] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1].z = this.maximum.z;
                vecs[2] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[2].x = this.maximum.x;
                vecs[3] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[3].y = this.minimum.y;
                vecs[4] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[4].y = this.maximum.y;
                vecs[5] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[5].x = this.minimum.x;
                vecs[6] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[6].z = this.minimum.z;
                vecs[7] = gd3d.math.pool.clone_vector3(this.maximum);
            };
            return aabb;
        }());
        framework.aabb = aabb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var helpV2_0 = new gd3d.math.vector2();
        var helpV2_1 = new gd3d.math.vector2();
        var helpV3_0 = new gd3d.math.vector3();
        var helpV3_1 = new gd3d.math.vector3();
        var collision = (function () {
            function collision() {
            }
            collision.obbVsObb = function (a, b) {
                if (!a || !b)
                    return false;
                var box0 = a;
                var box1 = b;
                var box0_dirs = box0.directions;
                var box1_dirs = box1.directions;
                if (!this.obbOverLap(box0_dirs[0], box0, box1))
                    return false;
                if (!this.obbOverLap(box0_dirs[1], box0, box1))
                    return false;
                if (!this.obbOverLap(box0_dirs[2], box0, box1))
                    return false;
                if (!this.obbOverLap(box1_dirs[0], box0, box1))
                    return false;
                if (!this.obbOverLap(box1_dirs[1], box0, box1))
                    return false;
                if (!this.obbOverLap(box1_dirs[2], box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[0], box1_dirs[0], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[0], box1_dirs[1], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[0], box1_dirs[2], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[1], box1_dirs[0], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[1], box1_dirs[1], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[1], box1_dirs[2], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[2], box1_dirs[0], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[2], box1_dirs[1], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0_dirs[2], box1_dirs[2], helpV3_0);
                if (!this.obbOverLap(helpV3_0, box0, box1))
                    return false;
                return true;
            };
            collision.sphereVsSphere = function (a, b) {
                if (!a || !b)
                    return false;
                var dis = gd3d.math.vec3Distance(a.center, b.center);
                return dis <= a.radius + b.radius;
            };
            collision.obbVsSphere = function (a, b) {
                if (!a || !b)
                    return false;
                var a_dirs = a.directions;
                if (!this.obb_SphereOverLap(a_dirs[0], a, b))
                    return false;
                if (!this.obb_SphereOverLap(a_dirs[1], a, b))
                    return false;
                if (!this.obb_SphereOverLap(a_dirs[2], a, b))
                    return false;
                var axis = helpV3_0;
                gd3d.math.vec3Subtract(a.worldCenter, b.center, axis);
                gd3d.math.vec3Normalize(axis, axis);
                if (!this.obb_SphereOverLap(axis, a, b))
                    return false;
                gd3d.math.vec3Cross(a_dirs[0], axis, helpV3_1);
                if (!this.obb_SphereOverLap(helpV3_1, a, b))
                    return false;
                gd3d.math.vec3Cross(a_dirs[1], axis, helpV3_1);
                if (!this.obb_SphereOverLap(helpV3_1, a, b))
                    return false;
                gd3d.math.vec3Cross(a_dirs[2], axis, helpV3_1);
                if (!this.obb_SphereOverLap(helpV3_1, a, b))
                    return false;
                return true;
            };
            collision.obb_SphereOverLap = function (axis, box0, sphere) {
                box0.computeExtentsByAxis(axis, helpV2_0);
                sphere.computeExtentsByAxis(axis, helpV2_1);
                return this.extentsOverlap(helpV2_0, helpV2_1);
            };
            collision.obbOverLap = function (axis, box0, box1) {
                box0.computeExtentsByAxis(axis, helpV2_0);
                box1.computeExtentsByAxis(axis, helpV2_1);
                return this.extentsOverlap(helpV2_0, helpV2_1);
            };
            collision.extentsOverlap = function (a, b) {
                return !(a.x > b.y || b.x > a.y);
            };
            return collision;
        }());
        framework.collision = collision;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var helpv3 = new gd3d.math.vector3();
        var helpv3_1 = new gd3d.math.vector3();
        var obb = (function () {
            function obb() {
                this._directions = [];
                this._halfSizeWorld = new gd3d.math.vector3();
                this._vectorsWorld = new Array();
                this._worldCenter = new gd3d.math.vector3();
                this._worldMatrix = new gd3d.math.matrix();
                this.vectors = new Array();
                this.dirtyMap = {};
            }
            Object.defineProperty(obb.prototype, "vectorsWorld", {
                get: function () {
                    var needInit = this._vectorsWorld.length < 1;
                    if (needInit) {
                        for (var i = 0; i < 8; i++) {
                            this._vectorsWorld.push(new gd3d.math.vector3());
                        }
                    }
                    if (this.dirtyMap[obb.tag_wVectors] || needInit) {
                        var wMtx = this.getWorldMatrix();
                        for (var i = 0; i < 8; i++) {
                            gd3d.math.matrixTransformVector3(this.vectors[i], wMtx, this._vectorsWorld[i]);
                        }
                        this.dirtyMap[obb.tag_wVectors] = false;
                    }
                    return this._vectorsWorld;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(obb.prototype, "worldCenter", {
                get: function () {
                    if (this.dirtyMap[obb.tag_wCenter]) {
                        gd3d.math.matrixTransformVector3(this.center, this._worldMatrix, this._worldCenter);
                        this.dirtyMap[obb.tag_wCenter] = false;
                    }
                    return this._worldCenter;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(obb.prototype, "halfSizeWorld", {
                get: function () {
                    if (this.dirtyMap[obb.tag_wHalfSize]) {
                        var wVects = this.vectorsWorld;
                        var wMin = helpv3;
                        var wMax = helpv3_1;
                        gd3d.math.vec3SetAll(wMin, Number.MAX_VALUE);
                        gd3d.math.vec3SetAll(wMax, -Number.MAX_VALUE);
                        for (var i = 0; i < 8; i++) {
                            var p = wVects[i];
                            wMin.x = p.x < wMin.x ? p.x : wMin.x;
                            wMin.y = p.y < wMin.y ? p.y : wMin.y;
                            wMin.z = p.z < wMin.z ? p.z : wMin.z;
                            wMax.x = p.x > wMax.x ? p.x : wMax.x;
                            wMax.y = p.y > wMax.y ? p.y : wMax.y;
                            wMax.z = p.z > wMax.z ? p.z : wMax.z;
                        }
                        gd3d.math.vec3Subtract(wMax, wMin, this._halfSizeWorld);
                        gd3d.math.vec3ScaleByNum(this._halfSizeWorld, 0.5, this._halfSizeWorld);
                        this.dirtyMap[obb.tag_wHalfSize] = false;
                    }
                    return this._halfSizeWorld;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(obb.prototype, "directions", {
                get: function () {
                    if (this.dirtyMap[obb.tag_directions]) {
                        gd3d.math.matrixGetVector3ByOffset(this._worldMatrix, 0, this._directions[0]);
                        gd3d.math.matrixGetVector3ByOffset(this._worldMatrix, 4, this._directions[1]);
                        gd3d.math.matrixGetVector3ByOffset(this._worldMatrix, 8, this._directions[2]);
                        this.dirtyMap[obb.tag_directions] = false;
                    }
                    return this._directions;
                },
                enumerable: true,
                configurable: true
            });
            obb.prototype.getWorldMatrix = function () {
                return this._worldMatrix;
            };
            obb.prototype.buildByMaxMin = function (minimum, maximum) {
                this.vectors[0] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1].z = maximum.z;
                this.vectors[2] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[2].x = maximum.x;
                this.vectors[3] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[3].y = minimum.y;
                this.vectors[4] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[4].y = maximum.y;
                this.vectors[5] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[5].x = minimum.x;
                this.vectors[6] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[6].z = minimum.z;
                this.vectors[7] = gd3d.math.pool.clone_vector3(maximum);
                this.center = new gd3d.math.vector3();
                gd3d.math.vec3Add(maximum, minimum, this.center);
                gd3d.math.vec3ScaleByNum(this.center, 0.5, this.center);
                this.halfsize = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(maximum, minimum, this.halfsize);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                this._directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            };
            obb.prototype.buildByCenterSize = function (center, size) {
                this.center = gd3d.math.pool.clone_vector3(center);
                this.halfsize = gd3d.math.pool.clone_vector3(size);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                var hsx = this.halfsize.x;
                var hsy = this.halfsize.y;
                var hsz = this.halfsize.z;
                var cenx = this.center.x;
                var ceny = this.center.y;
                var cenz = this.center.z;
                this.vectors[0] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz - hsz);
                this.vectors[1] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz + hsz);
                this.vectors[2] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz - hsz);
                this.vectors[3] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz + hsz);
                this.vectors[4] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz - hsz);
                this.vectors[5] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz + hsz);
                this.vectors[6] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz - hsz);
                this.vectors[7] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz + hsz);
                this._directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            };
            obb.prototype.update = function (worldmatrix) {
                var _this = this;
                if (!worldmatrix)
                    return;
                var isDirty = !gd3d.math.matrixEqual(this._worldMatrix, worldmatrix);
                if (!isDirty) {
                    return;
                }
                else {
                    gd3d.math.matrixClone(worldmatrix, this._worldMatrix);
                    obb.tags.forEach(function (tag) {
                        _this.dirtyMap[tag] = true;
                    });
                }
            };
            obb.prototype.intersects = function (bound) {
                if (!bound)
                    return false;
                if (bound instanceof obb) {
                    return framework.collision.obbVsObb(bound, this);
                }
                else if (bound instanceof framework.spherestruct) {
                    return framework.collision.obbVsSphere(this, bound);
                }
            };
            obb.prototype.computeExtentsByAxis = function (axis, out) {
                var p = gd3d.math.vec3Dot(this.worldCenter, axis);
                var dirs = this.directions;
                var size = this.halfSizeWorld;
                var r0 = Math.abs(gd3d.math.vec3Dot(dirs[0], axis)) * size.x;
                var r1 = Math.abs(gd3d.math.vec3Dot(dirs[1], axis)) * size.y;
                var r2 = Math.abs(gd3d.math.vec3Dot(dirs[2], axis)) * size.z;
                var r = r0 + r1 + r2;
                out.x = p - r;
                out.y = p + r;
            };
            obb.prototype.clone = function () {
                var _obb = new obb();
                _obb.center = gd3d.math.pool.clone_vector3(this.center);
                _obb.halfsize = this.halfsize;
                for (var key in this._directions) {
                    _obb._directions[key] = gd3d.math.pool.clone_vector3(this._directions[key]);
                }
                _obb._worldMatrix = gd3d.math.pool.clone_matrix(this._worldMatrix);
                _obb._halfSizeWorld = gd3d.math.pool.clone_vector3(this._halfSizeWorld);
                _obb._worldCenter = gd3d.math.pool.clone_vector3(this._worldCenter);
                _obb.vectors = [];
                _obb._vectorsWorld = [];
                for (var i = 0; i < 8; i++) {
                    _obb.vectors[i] = this.vectors[i];
                    _obb._vectorsWorld[i] = this._vectorsWorld[i];
                }
                _obb.dirtyMap = {};
                for (var key in this.dirtyMap) {
                    _obb.dirtyMap[key] = this.dirtyMap[key];
                }
                return _obb;
            };
            obb.prototype.dispose = function () {
                this.vectors.length = 0;
                this._directions.length = 0;
                this.dirtyMap = null;
                this._halfSizeWorld = null;
                this._vectorsWorld.length = 0;
                this._worldCenter = null;
                this._worldMatrix = null;
            };
            obb.tag_wCenter = "tag_wCenter";
            obb.tag_wVectors = "tag_wVectors";
            obb.tag_wHalfSize = "tag_wHalfSize";
            obb.tag_directions = "tag_directions";
            obb.tags = [obb.tag_wCenter, obb.tag_wVectors, obb.tag_wHalfSize, obb.tag_directions];
            return obb;
        }());
        framework.obb = obb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var obb2d = (function () {
            function obb2d() {
            }
            Object.defineProperty(obb2d.prototype, "size", {
                get: function () { return this._size; },
                set: function (size) {
                    if (!size || !this._size)
                        return;
                    gd3d.math.vec2Clone(size, this._size);
                    this.halfWidth = this._size.x / 2;
                    this.halfHeight = this._size.y / 2;
                },
                enumerable: true,
                configurable: true
            });
            obb2d.prototype.buildByCenterSize = function (center, width, height) {
                this.center = gd3d.math.pool.clone_vector2(center);
                this.offset = gd3d.math.pool.new_vector2();
                this.scale = gd3d.math.pool.new_vector2();
                this.rotate = new gd3d.math.angelref();
                this._size = new gd3d.math.vector2(width, height);
                this.halfWidth = width / 2;
                this.halfHeight = height / 2;
                this.directions = [new gd3d.math.vector2(), new gd3d.math.vector2()];
            };
            obb2d.prototype.update = function (canvasWorldMtx) {
                gd3d.math.matrix3x2Decompose(canvasWorldMtx, this.scale, this.rotate, this.center);
                var tranOffset = gd3d.math.pool.new_vector2();
                var scaleRotateMtx = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Clone(canvasWorldMtx, scaleRotateMtx);
                scaleRotateMtx.rawData[4] = scaleRotateMtx.rawData[5] = 0;
                gd3d.math.matrix3x2TransformVector2(scaleRotateMtx, this.offset, tranOffset);
                gd3d.math.vec2Add(this.center, tranOffset, this.center);
                this.directions[0].x = canvasWorldMtx.rawData[0];
                this.directions[0].y = canvasWorldMtx.rawData[1];
                this.directions[1].x = canvasWorldMtx.rawData[2];
                this.directions[1].y = canvasWorldMtx.rawData[3];
                gd3d.math.pool.delete_vector2(tranOffset);
                gd3d.math.pool.delete_matrix3x2(scaleRotateMtx);
            };
            obb2d.prototype.intersects = function (_obb) {
                if (_obb == null)
                    return false;
                var box0 = this;
                var box1 = _obb;
                if (!this.axisOverlap(box0.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[1], box0, box1))
                    return false;
                return true;
            };
            obb2d.prototype.computeBoxExtents = function (axis, box) {
                var p = gd3d.math.vec2Dot(box.center, axis);
                var r0 = Math.abs(gd3d.math.vec2Dot(box.directions[0], axis)) * box.halfWidth;
                var r1 = Math.abs(gd3d.math.vec2Dot(box.directions[1], axis)) * box.halfHeight;
                var r = r0 + r1;
                var result = gd3d.math.pool.new_vector2();
                result.x = p - r;
                result.y = p + r;
                return result;
            };
            obb2d.prototype.axisOverlap = function (axis, box0, box1) {
                var result0 = this.computeBoxExtents(axis, box0);
                var result1 = this.computeBoxExtents(axis, box1);
                return this.extentsOverlap(result0.x, result0.y, result1.x, result1.y);
            };
            obb2d.prototype.extentsOverlap = function (min0, max0, min1, max1) {
                return !(min0 > max1 || min1 > max0);
            };
            obb2d.prototype.clone = function () {
                var _obb = new obb2d();
                _obb.center = gd3d.math.pool.clone_vector2(this.center);
                _obb._size = gd3d.math.pool.clone_vector2(this._size);
                _obb.halfWidth = this.halfWidth;
                _obb.halfHeight = this.halfHeight;
                _obb.scale = gd3d.math.pool.clone_vector2(this.scale);
                _obb.rotate = new gd3d.math.angelref();
                _obb.rotate.v = this.rotate.v;
                for (var key in this.directions) {
                    _obb.directions[key] = gd3d.math.pool.clone_vector2(this.directions[key]);
                }
                return _obb;
            };
            obb2d.prototype.dispose = function () {
                if (this.center)
                    gd3d.math.pool.delete_vector2(this.center);
                if (this._size)
                    gd3d.math.pool.delete_vector2(this._size);
                if (this.scale)
                    gd3d.math.pool.delete_vector2(this.scale);
                if (this.directions) {
                    this.directions.forEach(function (dir) {
                        if (dir)
                            gd3d.math.pool.delete_vector2(dir);
                    });
                    this.directions.length = 0;
                }
            };
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2)
            ], obb2d.prototype, "offset", void 0);
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2),
                __metadata("design:paramtypes", [gd3d.math.vector2])
            ], obb2d.prototype, "size", null);
            return obb2d;
        }());
        framework.obb2d = obb2d;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pickinfo = (function () {
            function pickinfo(_bu, _bv, _distance) {
                if (_bu === void 0) { _bu = 0; }
                if (_bv === void 0) { _bv = 0; }
                if (_distance === void 0) { _distance = 0; }
                this.normal = new gd3d.math.vector3();
                this.distance = 0;
                this.hitposition = new gd3d.math.vector3();
                this.bu = 0;
                this.bv = 0;
                this.faceId = -1;
                this.subMeshId = 0;
                this.distance = _distance;
                this.bu = _bu;
                this.bv = _bv;
            }
            pickinfo.prototype.init = function () {
                this.pickedtran = null;
                this.hitposition.x = this.hitposition.y = this.hitposition.z = this.distance = this.bu = this.bv = this.subMeshId = 0;
                this.faceId = -1;
            };
            pickinfo.prototype.cloneFrom = function (from) {
                gd3d.math.vec3Clone(from.normal, this.normal);
                this.pickedtran = from.pickedtran;
                gd3d.math.vec3Clone(from.hitposition, this.hitposition);
                this.distance = from.distance;
                this.bu = from.bu;
                this.bv = from.bv;
                this.subMeshId = from.subMeshId;
                this.faceId = from.faceId;
            };
            return pickinfo;
        }());
        framework.pickinfo = pickinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var nodePool = (function () {
            function nodePool() {
            }
            nodePool.new_node = function (bounds, level) {
                if (level === void 0) { level = 0; }
                var n = this.nodelist.pop();
                if (n) {
                    n.bounds = bounds;
                    n.level = level;
                }
                else
                    n = new qtNode(bounds, level);
                return n;
            };
            nodePool.delete_node = function (n) {
                if (!n)
                    return;
                n.level = 0;
                n.nodes.length = n.objects.length = 0;
                gd3d.math.pool.delete_rect(n.bounds);
                this.nodelist.push(n);
            };
            nodePool.nodelist = [];
            return nodePool;
        }());
        var qtNode = (function () {
            function qtNode(bounds, level) {
                if (level === void 0) { level = 0; }
                this.objects = [];
                this.nodes = [];
                this.level = isNaN(level) || level < 0 ? 0 : level;
                this.bounds = bounds;
            }
            qtNode.prototype.split = function () {
                var level = this.level;
                var bounds = this.bounds;
                var sWidth = bounds.w / 2;
                var sHeight = bounds.h / 2;
                var x = bounds.x;
                var y = bounds.y;
                var cx = x + sWidth;
                var cy = y + sHeight;
                var r_0 = gd3d.math.pool.new_rect(cx, y, sWidth, sHeight);
                var r_1 = gd3d.math.pool.new_rect(x, y, sWidth, sHeight);
                var r_2 = gd3d.math.pool.new_rect(x, cy, sWidth, sHeight);
                var r_3 = gd3d.math.pool.new_rect(cx, cy, sWidth, sHeight);
                this.nodes.push(nodePool.new_node(r_0, level + 1), nodePool.new_node(r_1, level + 1), nodePool.new_node(r_2, level + 1), nodePool.new_node(r_3, level + 1));
            };
            qtNode.prototype.clear = function () {
                var nodes = this.nodes;
                this.objects.splice(0, this.objects.length);
                while (nodes.length) {
                    var subnode = nodes.shift();
                    subnode.clear();
                    nodePool.delete_node(subnode);
                }
            };
            qtNode.prototype.getIndex = function (rect, checkIsInner) {
                if (checkIsInner === void 0) { checkIsInner = false; }
                var bounds = this.bounds;
                var cx = bounds.x + (bounds.w / 2);
                var cy = bounds.y + (bounds.h / 2);
                var onTop = (bounds.y + rect.h) <= cy;
                var onBottom = rect.y > cy;
                var onLeft = (bounds.x + rect.w) <= cx;
                var onRight = rect.x > cx;
                if (checkIsInner &&
                    (Math.abs(rect.x - bounds.x) + (rect.w / 2) > (bounds.w / 2) ||
                        Math.abs(rect.y - bounds.y) + (rect.h / 2) > (bounds.h / 2))) {
                    return -1;
                }
                if (onTop) {
                    if (onRight) {
                        return 0;
                    }
                    else if (onLeft) {
                        return 1;
                    }
                }
                else if (onBottom) {
                    if (onLeft) {
                        return 2;
                    }
                    else if (onRight) {
                        return 3;
                    }
                }
                return -1;
            };
            qtNode.prototype.insert = function (rect, maxObjNum, maxLevel) {
                var objs = this.objects;
                var index;
                if (this.nodes.length) {
                    index = this.getIndex(rect, true);
                    if (index != -1) {
                        this.nodes[index].insert(rect, maxObjNum, maxLevel);
                        return;
                    }
                }
                objs.push(rect);
                if (!this.nodes.length &&
                    this.objects.length > maxObjNum &&
                    this.level < maxLevel) {
                    this.split();
                    for (var i = objs.length - 1; i >= 0; i--) {
                        index = this.getIndex(objs[i], true);
                        if (index !== -1) {
                            this.nodes[index].insert(objs.splice(i, 1)[0], maxObjNum, maxLevel);
                        }
                    }
                }
            };
            qtNode.prototype.concatToArr = function (targetArr, addArr) {
                if (!targetArr || !addArr)
                    return;
                addArr.forEach(function (sub) {
                    if (sub)
                        targetArr.push(sub);
                });
            };
            qtNode.prototype.retrieve = function (rect, outRects) {
                var arr;
                var index;
                if (this.level === 0)
                    outRects.length = 0;
                this.concatToArr(outRects, this.objects);
                if (this.nodes.length) {
                    index = this.getIndex(rect);
                    if (index !== -1) {
                        this.nodes[index].retrieve(rect, outRects);
                    }
                    else {
                        var cx = this.bounds.x + (this.bounds.w / 2);
                        var cy = this.bounds.y + (this.bounds.h / 2);
                        arr = this.rectCarve(rect, cx, cy);
                        for (var i = arr.length - 1; i >= 0; i--) {
                            index = this.getIndex(arr[i]);
                            if (index != -1) {
                                this.nodes[index].retrieve(rect, outRects);
                            }
                        }
                        arr.forEach(function (element) {
                            if (element)
                                gd3d.math.pool.delete_rect(element);
                        });
                    }
                }
            };
            qtNode.prototype.rectCarve = function (src, cx, cy) {
                var result = [];
                var temps = [];
                var dX = cx - src.x;
                var dY = cy - src.y;
                var carveX = dX > 0 && dX < src.w;
                var carveY = dY > 0 && dY < src.h;
                if (carveX && carveY) {
                    temps = this.rectCarve(src, cx, src.y);
                    while (temps.length) {
                        var temp = temps.pop();
                        this.concatToArr(result, this.rectCarve(temp, src.x, cy));
                    }
                }
                else if (carveX) {
                    result.push(gd3d.math.pool.new_rect(src.x, src.y, dX, src.h), gd3d.math.pool.new_rect(cx, src.y, src.w - dX, src.h));
                }
                else if (carveY) {
                    result.push(gd3d.math.pool.new_rect(src.x, src.y, src.w, dY), gd3d.math.pool.new_rect(src.x, cy, src.w, src.h - dY));
                }
                return result;
            };
            return qtNode;
        }());
        var quadTree = (function () {
            function quadTree(bounds, maxObjNum, maxLevel) {
                if (maxObjNum === void 0) { maxObjNum = 5; }
                if (maxLevel === void 0) { maxLevel = 5; }
                this.cacheArr = [];
                this.rootNode = new qtNode(bounds, 0);
                this.MAX_OBJECTS = maxObjNum;
                this.MAX_LEVELS = maxLevel;
            }
            quadTree.prototype.insert = function (rect) {
                this.rootNode.insert(rect, this.MAX_OBJECTS, this.MAX_LEVELS);
            };
            quadTree.prototype.retrieve = function (bounds, outRects) {
                if (!bounds || !outRects)
                    return;
                outRects.length = 0;
                this.rootNode.retrieve(bounds, outRects);
            };
            quadTree.prototype.clear = function () {
                if (!this.rootNode)
                    return;
                this.rootNode.clear();
            };
            return quadTree;
        }());
        framework.quadTree = quadTree;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ray = (function () {
            function ray(_origin, _dir) {
                this.origin = new gd3d.math.vector3();
                this.direction = new gd3d.math.vector3();
                this.set(_origin, _dir);
            }
            ray.prototype.set = function (_origin, _dir) {
                gd3d.math.vec3Clone(_origin, this.origin);
                gd3d.math.vec3Clone(_dir, this.direction);
            };
            ray.prototype.intersectAABB = function (_aabb) {
                return this.intersectBoxMinMax(_aabb.minimum, _aabb.maximum);
            };
            ray.prototype.intersectPlaneTransform = function (tran, outInfo) {
                var ishided = false;
                var panelpoint = tran.getWorldTranslate();
                var forward = gd3d.math.pool.new_vector3();
                tran.getForwardInWorld(forward);
                var hitposition = gd3d.math.pool.new_vector3();
                ishided = this.intersectPlane(panelpoint, forward, hitposition);
                if (ishided) {
                    gd3d.math.vec3Clone(hitposition, outInfo.hitposition);
                    outInfo.distance = gd3d.math.vec3Distance(outInfo.hitposition, this.origin);
                    outInfo.pickedtran = tran;
                }
                gd3d.math.pool.delete_vector3(forward);
                gd3d.math.pool.delete_vector3(hitposition);
                return ishided;
            };
            ray.prototype.intersectPlane = function (planePoint, planeNormal, outHitPoint) {
                var vp1 = planeNormal.x;
                var vp2 = planeNormal.y;
                var vp3 = planeNormal.z;
                var n1 = planePoint.x;
                var n2 = planePoint.y;
                var n3 = planePoint.z;
                var v1 = this.direction.x;
                var v2 = this.direction.y;
                var v3 = this.direction.z;
                var m1 = this.origin.x;
                var m2 = this.origin.y;
                var m3 = this.origin.z;
                var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
                if (vpt === 0) {
                    return false;
                }
                else {
                    var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                    outHitPoint.x = m1 + v1 * t;
                    outHitPoint.y = m2 + v2 * t;
                    outHitPoint.z = m3 + v3 * t;
                    return true;
                }
            };
            ray.prototype.intersectCollider = function (tran, outInfo) {
                var ishided = false;
                var _collider = tran.gameObject.collider;
                var lastDistance = Number.MAX_VALUE;
                if (_collider instanceof framework.boxcollider) {
                    var obb_1 = _collider.getBound();
                    if (!obb_1)
                        return ishided;
                    if (!ray.tempVecs) {
                        ray.tempVecs = [];
                        for (var i = 0; i < 8; i++) {
                            ray.tempVecs.push(new gd3d.math.vector3());
                        }
                    }
                    var wVects = obb_1.vectorsWorld;
                    for (var i = 0; i < 8; i++) {
                        gd3d.math.vec3Clone(wVects[i], ray.tempVecs[i]);
                    }
                    if (!ray.tempMData)
                        ray.tempMData = new gd3d.render.meshData();
                    gd3d.render.meshData.genBoxByArray(ray.tempVecs, ray.tempMData);
                    var data = ray.tempMData;
                    for (var index = 0; index < data.trisindex.length; index += 3) {
                        var p0 = data.pos[data.trisindex[index]];
                        var p1 = data.pos[data.trisindex[index + 1]];
                        var p2 = data.pos[data.trisindex[index + 2]];
                        var tempinfo = gd3d.math.pool.new_pickInfo();
                        var bool = this.intersectsTriangle(p0, p1, p2, tempinfo);
                        if (bool) {
                            if (tempinfo.distance < 0)
                                continue;
                            if (lastDistance > tempinfo.distance) {
                                ishided = true;
                                outInfo.cloneFrom(tempinfo);
                                outInfo.pickedtran = tran;
                                lastDistance = outInfo.distance;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(this.direction, outInfo.distance, tdir);
                                gd3d.math.vec3Add(this.origin, tdir, outInfo.hitposition);
                                gd3d.math.pool.delete_vector3(tdir);
                            }
                        }
                        gd3d.math.pool.delete_pickInfo(tempinfo);
                    }
                }
                else if (_collider instanceof framework.meshcollider) {
                    var mesh_3 = _collider.getBound();
                    if (mesh_3 != null) {
                        ishided = mesh_3.intersects(this, tran.getWorldMatrix(), outInfo);
                    }
                }
                else if (_collider instanceof framework.canvasRenderer) {
                    ishided = this.intersectPlaneTransform(tran, outInfo);
                }
                return ishided;
            };
            ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
                var d = 0.0;
                var maxValue = Number.MAX_VALUE;
                var inv;
                var min;
                var max;
                var temp;
                if (Math.abs(this.direction.x) < 0.0000001) {
                    if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.x;
                    min = (minimum.x - this.origin.x) * inv;
                    max = (maximum.x - this.origin.x) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.y) < 0.0000001) {
                    if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.y;
                    min = (minimum.y - this.origin.y) * inv;
                    max = (maximum.y - this.origin.y) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.z) < 0.0000001) {
                    if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.z;
                    min = (minimum.z - this.origin.z) * inv;
                    max = (maximum.z - this.origin.z) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                return true;
            };
            ray.prototype.intersectsSphere = function (center, radius) {
                var center_ori = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(center, this.origin, center_ori);
                var raydist = gd3d.math.vec3Dot(this.direction, center_ori);
                if (orilen2 < rad2)
                    return true;
                if (raydist < 0)
                    return false;
                var orilen2 = gd3d.math.vec3SqrLength(center_ori);
                gd3d.math.pool.delete_vector3(center_ori);
                var rad2 = radius * radius;
                var d = rad2 - (orilen2 - raydist * raydist);
                if (d < 0)
                    return false;
                return true;
            };
            ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2, outInfo) {
                var _edge1 = gd3d.math.pool.new_vector3();
                var _edge2 = gd3d.math.pool.new_vector3();
                var _pvec = gd3d.math.pool.new_vector3();
                var _tvec = gd3d.math.pool.new_vector3();
                var _qvec = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(vertex1, vertex0, _edge1);
                gd3d.math.vec3Subtract(vertex2, vertex0, _edge2);
                gd3d.math.vec3Cross(this.direction, _edge2, _pvec);
                var det = gd3d.math.vec3Dot(_edge1, _pvec);
                if (det === 0) {
                    return false;
                }
                var invdet = 1 / det;
                gd3d.math.vec3Subtract(this.origin, vertex0, _tvec);
                var bu = gd3d.math.vec3Dot(_tvec, _pvec) * invdet;
                if (bu < 0 || bu > 1.0) {
                    return false;
                }
                gd3d.math.vec3Cross(_tvec, _edge1, _qvec);
                var bv = gd3d.math.vec3Dot(this.direction, _qvec) * invdet;
                if (bv < 0 || bu + bv > 1.0) {
                    return false;
                }
                var distance = gd3d.math.vec3Dot(_edge2, _qvec) * invdet;
                outInfo.init();
                outInfo.bu = bu;
                outInfo.bv = bv;
                outInfo.distance = distance;
                gd3d.math.vec3Cross(_edge1, _edge2, outInfo.normal);
                gd3d.math.vec3Normalize(outInfo.normal, outInfo.normal);
                gd3d.math.pool.delete_vector3(_edge1);
                gd3d.math.pool.delete_vector3(_edge2);
                gd3d.math.pool.delete_vector3(_pvec);
                gd3d.math.pool.delete_vector3(_tvec);
                gd3d.math.pool.delete_vector3(_qvec);
                return true;
            };
            return ray;
        }());
        framework.ray = ray;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var tweenUtil = (function () {
            function tweenUtil() {
            }
            tweenUtil.GetEaseProgress = function (ease_type, linear_progress) {
                switch (ease_type) {
                    case tweenMethod.Linear:
                        return linear_progress;
                    case tweenMethod.ExpoEaseOut:
                        return tweenUtil.ExpoEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.ExpoEaseIn:
                        return tweenUtil.ExpoEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ExpoEaseOutIn:
                        return tweenUtil.ExpoEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ExpoEaseInOut:
                        return tweenUtil.ExpoEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseOut:
                        return tweenUtil.CircEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseIn:
                        return tweenUtil.CircEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseOutIn:
                        return tweenUtil.CircEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseInOut:
                        return tweenUtil.CircEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseOut:
                        return tweenUtil.QuadEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseIn:
                        return tweenUtil.QuadEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseOutIn:
                        return tweenUtil.QuadEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseInOut:
                        return tweenUtil.QuadEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseOut:
                        return tweenUtil.SineEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseIn:
                        return tweenUtil.SineEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseOutIn:
                        return tweenUtil.SineEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseInOut:
                        return tweenUtil.SineEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseOut:
                        return tweenUtil.CubicEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseIn:
                        return tweenUtil.CubicEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseOutIn:
                        return tweenUtil.CubicEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseInOut:
                        return tweenUtil.CubicEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseOut:
                        return tweenUtil.QuartEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseIn:
                        return tweenUtil.QuartEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseOutIn:
                        return tweenUtil.QuartEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseInOut:
                        return tweenUtil.QuartEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseOut:
                        return tweenUtil.QuintEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseIn:
                        return tweenUtil.QuintEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseOutIn:
                        return tweenUtil.QuintEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseInOut:
                        return tweenUtil.QuintEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseOut:
                        return tweenUtil.ElasticEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseIn:
                        return tweenUtil.ElasticEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseOutIn:
                        return tweenUtil.ElasticEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseInOut:
                        return tweenUtil.ElasticEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseOut:
                        return tweenUtil.BounceEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseIn:
                        return tweenUtil.BounceEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseOutIn:
                        return tweenUtil.BounceEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseInOut:
                        return tweenUtil.BounceEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseOut:
                        return tweenUtil.BackEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseIn:
                        return tweenUtil.BackEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseOutIn:
                        return tweenUtil.BackEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseInOut:
                        return tweenUtil.BackEaseInOut(linear_progress, 0, 1, 1);
                    default:
                        return linear_progress;
                }
            };
            tweenUtil.Linear = function (t, b, c, d) {
                return c * t / d + b;
            };
            tweenUtil.ExpoEaseOut = function (t, b, c, d) {
                return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
            };
            tweenUtil.ExpoEaseIn = function (t, b, c, d) {
                return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
            };
            tweenUtil.ExpoEaseInOut = function (t, b, c, d) {
                if (t == 0)
                    return b;
                if (t == d)
                    return b + c;
                if ((t /= d / 2) < 1)
                    return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
                return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
            };
            tweenUtil.ExpoEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.ExpoEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.ExpoEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.CircEaseOut = function (t, b, c, d) {
                return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
            };
            tweenUtil.CircEaseIn = function (t, b, c, d) {
                return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
            };
            tweenUtil.CircEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
                return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
            };
            tweenUtil.CircEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.CircEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.CircEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.QuadEaseOut = function (t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b;
            };
            tweenUtil.QuadEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t + b;
            };
            tweenUtil.QuadEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t + b;
                return -c / 2 * ((--t) * (t - 2) - 1) + b;
            };
            tweenUtil.QuadEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.QuadEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.QuadEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.SineEaseOut = function (t, b, c, d) {
                return c * Math.sin(t / d * (Math.PI / 2)) + b;
            };
            tweenUtil.SineEaseIn = function (t, b, c, d) {
                return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
            };
            tweenUtil.SineEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * (Math.sin(Math.PI * t / 2)) + b;
                return -c / 2 * (Math.cos(Math.PI * --t / 2) - 2) + b;
            };
            tweenUtil.SineEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.SineEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.SineEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.CubicEaseOut = function (t, b, c, d) {
                return c * ((t = t / d - 1) * t * t + 1) + b;
            };
            tweenUtil.CubicEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * t + b;
            };
            tweenUtil.CubicEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t + 2) + b;
            };
            tweenUtil.CubicEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.CubicEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.CubicEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.QuartEaseOut = function (t, b, c, d) {
                return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            };
            tweenUtil.QuartEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * t * t + b;
            };
            tweenUtil.QuartEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t * t + b;
                return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
            };
            tweenUtil.QuartEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.QuartEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.QuartEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.QuintEaseOut = function (t, b, c, d) {
                return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
            };
            tweenUtil.QuintEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * t * t * t + b;
            };
            tweenUtil.QuintEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
            };
            tweenUtil.QuintEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.QuintEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.QuintEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.ElasticEaseOut = function (t, b, c, d) {
                if ((t /= d) == 1)
                    return b + c;
                var p = d * 0.3;
                var s = p / 4;
                return (c * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
            };
            tweenUtil.ElasticEaseIn = function (t, b, c, d) {
                if ((t /= d) == 1)
                    return b + c;
                var p = d * 0.3;
                var s = p / 4;
                return -(c * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            };
            tweenUtil.ElasticEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) == 2)
                    return b + c;
                var p = d * (0.3 * 1.5);
                var s = p / 4;
                if (t < 1)
                    return -0.5 * (c * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
                return c * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
            };
            tweenUtil.ElasticEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.ElasticEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.ElasticEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.BounceEaseOut = function (t, b, c, d) {
                if ((t /= d) < (1 / 2.75))
                    return c * (7.5625 * t * t) + b;
                else if (t < (2 / 2.75))
                    return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
                else if (t < (2.5 / 2.75))
                    return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
                else
                    return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
            };
            tweenUtil.BounceEaseIn = function (t, b, c, d) {
                return c - tweenUtil.BounceEaseOut(d - t, 0, c, d) + b;
            };
            tweenUtil.BounceEaseInOut = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
                else
                    return tweenUtil.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            };
            tweenUtil.BounceEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.BounceEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.BounceEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            tweenUtil.BackEaseOut = function (t, b, c, d) {
                return c * ((t = t / d - 1) * t * ((1.70158 + 1) * t + 1.70158) + 1) + b;
            };
            tweenUtil.BackEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * ((1.70158 + 1) * t - 1.70158) + b;
            };
            tweenUtil.BackEaseInOut = function (t, b, c, d) {
                var s = 1.70158;
                if ((t /= d / 2) < 1)
                    return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
                return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
            };
            tweenUtil.BackEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.BackEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.BackEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            return tweenUtil;
        }());
        framework.tweenUtil = tweenUtil;
        var tweenMethod;
        (function (tweenMethod) {
            tweenMethod[tweenMethod["Linear"] = 0] = "Linear";
            tweenMethod[tweenMethod["ExpoEaseOut"] = 1] = "ExpoEaseOut";
            tweenMethod[tweenMethod["ExpoEaseIn"] = 2] = "ExpoEaseIn";
            tweenMethod[tweenMethod["ExpoEaseInOut"] = 3] = "ExpoEaseInOut";
            tweenMethod[tweenMethod["ExpoEaseOutIn"] = 4] = "ExpoEaseOutIn";
            tweenMethod[tweenMethod["CircEaseOut"] = 5] = "CircEaseOut";
            tweenMethod[tweenMethod["CircEaseIn"] = 6] = "CircEaseIn";
            tweenMethod[tweenMethod["CircEaseInOut"] = 7] = "CircEaseInOut";
            tweenMethod[tweenMethod["CircEaseOutIn"] = 8] = "CircEaseOutIn";
            tweenMethod[tweenMethod["QuadEaseOut"] = 9] = "QuadEaseOut";
            tweenMethod[tweenMethod["QuadEaseIn"] = 10] = "QuadEaseIn";
            tweenMethod[tweenMethod["QuadEaseInOut"] = 11] = "QuadEaseInOut";
            tweenMethod[tweenMethod["QuadEaseOutIn"] = 12] = "QuadEaseOutIn";
            tweenMethod[tweenMethod["SineEaseOut"] = 13] = "SineEaseOut";
            tweenMethod[tweenMethod["SineEaseIn"] = 14] = "SineEaseIn";
            tweenMethod[tweenMethod["SineEaseInOut"] = 15] = "SineEaseInOut";
            tweenMethod[tweenMethod["SineEaseOutIn"] = 16] = "SineEaseOutIn";
            tweenMethod[tweenMethod["CubicEaseOut"] = 17] = "CubicEaseOut";
            tweenMethod[tweenMethod["CubicEaseIn"] = 18] = "CubicEaseIn";
            tweenMethod[tweenMethod["CubicEaseInOut"] = 19] = "CubicEaseInOut";
            tweenMethod[tweenMethod["CubicEaseOutIn"] = 20] = "CubicEaseOutIn";
            tweenMethod[tweenMethod["QuartEaseOut"] = 21] = "QuartEaseOut";
            tweenMethod[tweenMethod["QuartEaseIn"] = 22] = "QuartEaseIn";
            tweenMethod[tweenMethod["QuartEaseInOut"] = 23] = "QuartEaseInOut";
            tweenMethod[tweenMethod["QuartEaseOutIn"] = 24] = "QuartEaseOutIn";
            tweenMethod[tweenMethod["QuintEaseOut"] = 25] = "QuintEaseOut";
            tweenMethod[tweenMethod["QuintEaseIn"] = 26] = "QuintEaseIn";
            tweenMethod[tweenMethod["QuintEaseInOut"] = 27] = "QuintEaseInOut";
            tweenMethod[tweenMethod["QuintEaseOutIn"] = 28] = "QuintEaseOutIn";
            tweenMethod[tweenMethod["ElasticEaseOut"] = 29] = "ElasticEaseOut";
            tweenMethod[tweenMethod["ElasticEaseIn"] = 30] = "ElasticEaseIn";
            tweenMethod[tweenMethod["ElasticEaseInOut"] = 31] = "ElasticEaseInOut";
            tweenMethod[tweenMethod["ElasticEaseOutIn"] = 32] = "ElasticEaseOutIn";
            tweenMethod[tweenMethod["BounceEaseOut"] = 33] = "BounceEaseOut";
            tweenMethod[tweenMethod["BounceEaseIn"] = 34] = "BounceEaseIn";
            tweenMethod[tweenMethod["BounceEaseInOut"] = 35] = "BounceEaseInOut";
            tweenMethod[tweenMethod["BounceEaseOutIn"] = 36] = "BounceEaseOutIn";
            tweenMethod[tweenMethod["BackEaseOut"] = 37] = "BackEaseOut";
            tweenMethod[tweenMethod["BackEaseIn"] = 38] = "BackEaseIn";
            tweenMethod[tweenMethod["BackEaseInOut"] = 39] = "BackEaseInOut";
            tweenMethod[tweenMethod["BackEaseOutIn"] = 40] = "BackEaseOutIn";
        })(tweenMethod = framework.tweenMethod || (framework.tweenMethod = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var CullingMask;
        (function (CullingMask) {
            CullingMask[CullingMask["nothing"] = 0] = "nothing";
            CullingMask[CullingMask["default"] = 1] = "default";
            CullingMask[CullingMask["transparentFx"] = 2] = "transparentFx";
            CullingMask[CullingMask["IgnoreRaycast"] = 4] = "IgnoreRaycast";
            CullingMask[CullingMask["editor"] = 8] = "editor";
            CullingMask[CullingMask["water"] = 16] = "water";
            CullingMask[CullingMask["ui"] = 32] = "ui";
            CullingMask[CullingMask["preview"] = 64] = "preview";
            CullingMask[CullingMask["builtin_0"] = 1] = "builtin_0";
            CullingMask[CullingMask["builtin_1"] = 2] = "builtin_1";
            CullingMask[CullingMask["builtin_2"] = 4] = "builtin_2";
            CullingMask[CullingMask["builtin_3"] = 8] = "builtin_3";
            CullingMask[CullingMask["builtin_4"] = 16] = "builtin_4";
            CullingMask[CullingMask["builtin_5"] = 32] = "builtin_5";
            CullingMask[CullingMask["builtin_6"] = 64] = "builtin_6";
            CullingMask[CullingMask["builtin_7"] = 128] = "builtin_7";
            CullingMask[CullingMask["modelbeforeui"] = 256] = "modelbeforeui";
            CullingMask[CullingMask["user_8"] = 256] = "user_8";
            CullingMask[CullingMask["user_9"] = 512] = "user_9";
            CullingMask[CullingMask["user_10"] = 1024] = "user_10";
            CullingMask[CullingMask["user_11"] = 2048] = "user_11";
            CullingMask[CullingMask["user_12"] = 4096] = "user_12";
            CullingMask[CullingMask["user_13"] = 8192] = "user_13";
            CullingMask[CullingMask["user_14"] = 16384] = "user_14";
            CullingMask[CullingMask["user_15"] = 32768] = "user_15";
            CullingMask[CullingMask["user_16"] = 65536] = "user_16";
            CullingMask[CullingMask["user_17"] = 131072] = "user_17";
            CullingMask[CullingMask["user_18"] = 262144] = "user_18";
            CullingMask[CullingMask["user_19"] = 524288] = "user_19";
            CullingMask[CullingMask["user_20"] = 1048576] = "user_20";
            CullingMask[CullingMask["user_21"] = 2097152] = "user_21";
            CullingMask[CullingMask["user_22"] = 4194304] = "user_22";
            CullingMask[CullingMask["user_23"] = 8388608] = "user_23";
            CullingMask[CullingMask["user_24"] = 16777216] = "user_24";
            CullingMask[CullingMask["user_25"] = 33554432] = "user_25";
            CullingMask[CullingMask["user_26"] = 67108864] = "user_26";
            CullingMask[CullingMask["user_27"] = 134217728] = "user_27";
            CullingMask[CullingMask["user_28"] = 268435456] = "user_28";
            CullingMask[CullingMask["user_29"] = 536870912] = "user_29";
            CullingMask[CullingMask["user_30"] = 1073741824] = "user_30";
            CullingMask[CullingMask["user_31"] = 2147483648] = "user_31";
            CullingMask[CullingMask["everything"] = 4294967295] = "everything";
        })(CullingMask = framework.CullingMask || (framework.CullingMask = {}));
        var cullingmaskutil = (function () {
            function cullingmaskutil() {
            }
            cullingmaskutil.maskTolayer = function (mask) {
                return Math.log(mask) / Math.log(2);
            };
            cullingmaskutil.layerToMask = function (layer) {
                return 1 << layer;
            };
            return cullingmaskutil;
        }());
        framework.cullingmaskutil = cullingmaskutil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EnumUtil = (function () {
            function EnumUtil() {
            }
            EnumUtil.getEnumObjByType = function (enumType) {
                var index = enumType.indexOf("gd3d.framework.");
                if (index == 0)
                    enumType = enumType.substr(15);
                return eval("{result:" + enumType + "}");
            };
            return EnumUtil;
        }());
        framework.EnumUtil = EnumUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NumberUtil = (function () {
            function NumberUtil() {
            }
            NumberUtil.KEY_A = 65;
            NumberUtil.KEY_D = 68;
            NumberUtil.KEY_E = 69;
            NumberUtil.KEY_Q = 81;
            NumberUtil.KEY_R = 82;
            NumberUtil.KEY_S = 83;
            NumberUtil.KEY_W = 87;
            NumberUtil.KEY_a = 97;
            NumberUtil.KEY_d = 100;
            NumberUtil.KEY_e = 101;
            NumberUtil.KEY_q = 113;
            NumberUtil.KEY_r = 114;
            NumberUtil.KEY_s = 115;
            NumberUtil.KEY_w = 119;
            return NumberUtil;
        }());
        framework.NumberUtil = NumberUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RegexpUtil = (function () {
            function RegexpUtil() {
            }
            RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
            RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
            return RegexpUtil;
        }());
        framework.RegexpUtil = RegexpUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var StringUtil = (function () {
            function StringUtil() {
            }
            StringUtil.replaceAll = function (srcStr, fromStr, toStr) {
                return srcStr.replace(new RegExp(fromStr, 'gm'), toStr);
            };
            StringUtil.trimAll = function (str) {
                str += "";
                var result = str.replace(/(^\s+)|(\s+$)/g, "");
                result = result.replace(/\s/g, "");
                return result;
            };
            StringUtil.firstCharToLowerCase = function (str) {
                var firstChar = str.substr(0, 1).toLowerCase();
                var other = str.substr(1);
                return firstChar + other;
            };
            StringUtil.isNullOrEmptyObject = function (obj) {
                if (!obj)
                    return true;
                for (var n in obj) {
                    return false;
                }
                return true;
            };
            StringUtil.builtinTag_Untagged = "Untagged";
            StringUtil.builtinTag_Player = "Player";
            StringUtil.builtinTag_EditorOnly = "EditorOnly";
            StringUtil.builtinTag_MainCamera = "MainCamera";
            StringUtil.COMPONENT_CAMERA = "camera";
            StringUtil.COMPONENT_BOXCOLLIDER = "boxcollider";
            StringUtil.COMPONENT_LIGHT = "light";
            StringUtil.COMPONENT_MESHFILTER = "meshFilter";
            StringUtil.COMPONENT_MESHRENDER = "meshRenderer";
            StringUtil.COMPONENT_EFFECTSYSTEM = "effectSystem";
            StringUtil.COMPONENT_LABEL = "label";
            StringUtil.COMPONENT_uirect = "uirect";
            StringUtil.COMPONENT_IMAGE = "image2D";
            StringUtil.COMPONENT_RAWIMAGE = "rawImage2D";
            StringUtil.COMPONENT_BUTTON = "button";
            StringUtil.COMPONENT_SKINMESHRENDER = "skinnedMeshRenderer";
            StringUtil.COMPONENT_AUDIOPLAYER = "AudioPlayer";
            StringUtil.COMPONENT_CAMERACONTROLLER = "cameraController";
            StringUtil.COMPONENT_CANVASRENDER = "canvasRenderer";
            StringUtil.UIStyle_RangeFloat = "rangeFloat";
            StringUtil.UIStyle_Enum = "enum";
            StringUtil.RESOURCES_MESH_CUBE = "cube";
            return StringUtil;
        }());
        framework.StringUtil = StringUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var textureutil = (function () {
            function textureutil() {
            }
            textureutil.loadUtil = function (path) {
                var sc1 = document.createElement("script");
                var sc2 = document.createElement("script");
                sc1.src = path + "lib/webgl-util.js";
                sc2.src = path + "";
                document.body.appendChild(sc1);
                document.body.appendChild(sc2);
            };
            return textureutil;
        }());
        framework.textureutil = textureutil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PrimitiveType;
        (function (PrimitiveType) {
            PrimitiveType[PrimitiveType["Sphere"] = 0] = "Sphere";
            PrimitiveType[PrimitiveType["Capsule"] = 1] = "Capsule";
            PrimitiveType[PrimitiveType["Cylinder"] = 2] = "Cylinder";
            PrimitiveType[PrimitiveType["Cube"] = 3] = "Cube";
            PrimitiveType[PrimitiveType["Plane"] = 4] = "Plane";
            PrimitiveType[PrimitiveType["Quad"] = 5] = "Quad";
            PrimitiveType[PrimitiveType["Pyramid"] = 6] = "Pyramid";
        })(PrimitiveType = framework.PrimitiveType || (framework.PrimitiveType = {}));
        var Primitive2DType;
        (function (Primitive2DType) {
            Primitive2DType[Primitive2DType["RawImage2D"] = 0] = "RawImage2D";
            Primitive2DType[Primitive2DType["Image2D"] = 1] = "Image2D";
            Primitive2DType[Primitive2DType["Label"] = 2] = "Label";
            Primitive2DType[Primitive2DType["Button"] = 3] = "Button";
        })(Primitive2DType = framework.Primitive2DType || (framework.Primitive2DType = {}));
        var TransformUtil = (function () {
            function TransformUtil() {
            }
            TransformUtil.CreatePrimitive = function (type, app) {
                var objName = PrimitiveType[type];
                var trans = new framework.transform();
                trans.name = objName;
                var mesh = trans.gameObject.addComponent("meshFilter");
                var smesh = app.getAssetMgr().getDefaultMesh(objName.toLowerCase());
                mesh.mesh = smesh;
                var renderer = trans.gameObject.addComponent("meshRenderer");
                renderer.materials = [];
                renderer.materials.push(new framework.material());
                renderer.materials[0].setShader(app.getAssetMgr().getShader("shader/def"));
                return trans;
            };
            TransformUtil.Create2DPrimitive = function (type, app) {
                var objName = Primitive2DType[type];
                var componentName = framework.StringUtil.firstCharToLowerCase(objName);
                var t2d = new framework.transform2D();
                t2d.name = objName;
                var i2dComp = t2d.addComponent(componentName);
                t2d.pivot.x = 0;
                t2d.pivot.y = 0;
                switch (type) {
                    case Primitive2DType.RawImage2D:
                        TransformUtil.create2D_rawImage(i2dComp, app);
                        break;
                    case Primitive2DType.Image2D:
                        TransformUtil.create2D_image2D(i2dComp, app);
                        break;
                    case Primitive2DType.Label:
                        TransformUtil.create2D_label(i2dComp, app);
                        break;
                    case Primitive2DType.Button:
                        TransformUtil.create2D_button(i2dComp, app);
                        break;
                }
                return t2d;
            };
            TransformUtil.create2D_rawImage = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.image = app.getAssetMgr().getDefaultTexture("white");
            };
            TransformUtil.create2D_image2D = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
            };
            TransformUtil.create2D_label = function (label, app) {
                label.transform.width = 150;
                label.transform.height = 50;
                label.text = "label";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                var _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, function (s) {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, function (s1) {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                label.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    label.transform.markDirty();
                }
            };
            TransformUtil.create2D_button = function (btn, app) {
                btn.transform.width = 150;
                btn.transform.height = 50;
                var img = btn.transform.addComponent("image2D");
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
                img.imageType = gd3d.framework.ImageType.Sliced;
                btn.targetImage = img;
                btn.transition = gd3d.framework.TransitionType.ColorTint;
                var lab = new gd3d.framework.transform2D();
                lab.name = "label";
                lab.width = 150;
                lab.height = 50;
                lab.pivot.x = 0;
                lab.pivot.y = 0;
                lab.localTranslate.y = -10;
                var label = lab.addComponent("label");
                label.text = "button";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                btn.transform.addChild(lab);
                var _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, function (s) {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, function (s1) {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                btn.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    btn.transform.markDirty();
                }
            };
            return TransformUtil;
        }());
        framework.TransformUtil = TransformUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var WebGLDebugUtils = (function () {
            function WebGLDebugUtils() {
                this.glEnums = null;
            }
            WebGLDebugUtils.prototype.log = function (msg) {
                if (window.console && window.console.log) {
                    window.console.log(msg);
                }
            };
            WebGLDebugUtils.prototype.init = function (ctx) {
                if (this.glEnums == null) {
                    this.glEnums = {};
                    for (var propertyName in ctx) {
                        if (typeof ctx[propertyName] == 'number') {
                            this.glEnums[ctx[propertyName]] = propertyName;
                        }
                    }
                }
            };
            WebGLDebugUtils.prototype.checkInit = function () {
                if (this.glEnums == null) {
                    throw 'WebGLDebugUtils.init(ctx) not called';
                }
            };
            WebGLDebugUtils.prototype.mightBeEnum = function (value) {
                this.checkInit();
                return (this.glEnums[value] !== undefined);
            };
            WebGLDebugUtils.prototype.glEnumToString = function (value) {
                this.checkInit();
                var name = this.glEnums[value];
                return (name !== undefined) ? name :
                    ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
            };
            WebGLDebugUtils.prototype.glFunctionArgToString = function (functionName, argumentIndex, value) {
                var funcInfo = WebGLDebugUtils.glValidEnumContexts[functionName];
                if (funcInfo !== undefined) {
                    if (funcInfo[argumentIndex]) {
                        return this.glEnumToString(value);
                    }
                }
                return value.toString();
            };
            WebGLDebugUtils.prototype.makeDebugContext = function (ctx, opt_onErrorFunc) {
                var _this = this;
                if (opt_onErrorFunc === void 0) { opt_onErrorFunc = null; }
                this.init(ctx);
                opt_onErrorFunc = opt_onErrorFunc ||
                    (function (err, functionName, args) {
                        var argStr = "";
                        for (var ii = 0; ii < args.length; ++ii) {
                            argStr += ((ii == 0) ? '' : ', ') +
                                _this.glFunctionArgToString(functionName, ii, args[ii]);
                        }
                        console.error("WebGL error " + _this.glEnumToString(err) + " in " + functionName +
                            "(" + argStr + ")");
                    });
                var glErrorShadow = {};
                function makeErrorWrapper(ctx, functionName) {
                    return function () {
                        var result = ctx[functionName].apply(ctx, arguments);
                        var err = ctx.getError();
                        if (err != 0) {
                            glErrorShadow[err] = true;
                            opt_onErrorFunc(err, functionName, arguments);
                        }
                        return result;
                    };
                }
                var wrapper = {};
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper[propertyName] = ctx[propertyName];
                    }
                }
                wrapper["getError"] = function () {
                    for (var err in glErrorShadow) {
                        if (glErrorShadow[err]) {
                            glErrorShadow[err] = false;
                            return err;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                console.error(" i am ---makeDebugContext-");
                return wrapper;
            };
            WebGLDebugUtils.prototype.resetToInitialState = function (ctx) {
                var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
                var tmp = ctx.createBuffer();
                ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
                for (var ii = 0; ii < numAttribs; ++ii) {
                    ctx.disableVertexAttribArray(ii);
                    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
                    ctx.vertexAttrib1f(ii, 0);
                }
                ctx.deleteBuffer(tmp);
                var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
                for (var ii = 0; ii < numTextureUnits; ++ii) {
                    ctx.activeTexture(ctx.TEXTURE0 + ii);
                    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
                    ctx.bindTexture(ctx.TEXTURE_2D, null);
                }
                ctx.activeTexture(ctx.TEXTURE0);
                ctx.useProgram(null);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
                ctx.disable(ctx.BLEND);
                ctx.disable(ctx.CULL_FACE);
                ctx.disable(ctx.DEPTH_TEST);
                ctx.disable(ctx.DITHER);
                ctx.disable(ctx.SCISSOR_TEST);
                ctx.blendColor(0, 0, 0, 0);
                ctx.blendEquation(ctx.FUNC_ADD);
                ctx.blendFunc(ctx.ONE, ctx.ZERO);
                ctx.clearColor(0, 0, 0, 0);
                ctx.clearDepth(1);
                ctx.clearStencil(-1);
                ctx.colorMask(true, true, true, true);
                ctx.cullFace(ctx.BACK);
                ctx.depthFunc(ctx.LESS);
                ctx.depthMask(true);
                ctx.depthRange(0, 1);
                ctx.frontFace(ctx.CCW);
                ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
                ctx.lineWidth(1);
                ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
                ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
                    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
                }
                ctx.polygonOffset(0, 0);
                ctx.sampleCoverage(1, false);
                ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
                ctx.stencilMask(0xFFFFFFFF);
                ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
                ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
                ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);
                while (ctx.getError())
                    ;
            };
            WebGLDebugUtils.prototype.makeLostContextSimulatingContext = function (ctx) {
                var wrapper_ = {};
                var contextId_ = 1;
                var contextLost_ = false;
                var resourceId_ = 0;
                var resourceDb_ = [];
                var onLost_ = undefined;
                var onRestored_ = undefined;
                var nextOnRestored_ = undefined;
                var glErrorShadow_ = {};
                function isWebGLObject(obj) {
                    return (obj instanceof WebGLBuffer ||
                        obj instanceof WebGLFramebuffer ||
                        obj instanceof WebGLProgram ||
                        obj instanceof WebGLRenderbuffer ||
                        obj instanceof WebGLShader ||
                        obj instanceof WebGLTexture);
                }
                function checkResources(args) {
                    for (var ii = 0; ii < args.length; ++ii) {
                        var arg = args[ii];
                        if (isWebGLObject(arg)) {
                            return arg.__webglDebugContextLostId__ == contextId_;
                        }
                    }
                    return true;
                }
                function clearErrors() {
                    var k = Object.keys(glErrorShadow_);
                    for (var ii = 0; ii < k.length; ++ii) {
                        delete glErrorShadow_[k[ii]];
                    }
                }
                function makeLostContextWrapper(ctx, functionName) {
                    var f = ctx[functionName];
                    return function () {
                        if (!contextLost_) {
                            if (!checkResources(arguments)) {
                                glErrorShadow_[ctx.INVALID_OPERATION] = true;
                                return;
                            }
                            var result = f.apply(ctx, arguments);
                            return result;
                        }
                    };
                }
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper_[propertyName] = ctx[propertyName];
                    }
                }
                function makeWebGLContextEvent(statusMessage) {
                    return { statusMessage: statusMessage };
                }
                function freeResources() {
                    for (var ii = 0; ii < resourceDb_.length; ++ii) {
                        var resource = resourceDb_[ii];
                        if (resource instanceof WebGLBuffer) {
                            ctx.deleteBuffer(resource);
                        }
                    }
                }
                wrapper_["loseContext"] = function () {
                    if (!contextLost_) {
                        contextLost_ = true;
                        ++contextId_;
                        while (ctx.getError())
                            ;
                        clearErrors();
                        glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;
                        setTimeout(function () {
                            if (onLost_) {
                                onLost_(makeWebGLContextEvent("context lost"));
                            }
                        }, 0);
                    }
                };
                wrapper_["restoreContext"] = function () {
                    if (contextLost_) {
                        if (onRestored_) {
                            setTimeout(function () {
                                freeResources();
                                this.resetToInitialState(ctx);
                                contextLost_ = false;
                                if (onRestored_) {
                                    var callback = onRestored_;
                                    onRestored_ = nextOnRestored_;
                                    nextOnRestored_ = undefined;
                                    callback(makeWebGLContextEvent("context restored"));
                                }
                            }, 0);
                        }
                        else {
                            throw "You can not restore the context without a listener";
                        }
                    }
                };
                wrapper_["getError"] = function () {
                    if (!contextLost_) {
                        var err;
                        while (err = ctx.getError()) {
                            glErrorShadow_[err] = true;
                        }
                    }
                    for (var key in glErrorShadow_) {
                        if (glErrorShadow_[key]) {
                            delete glErrorShadow_[key];
                            return key;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                var creationFunctions = [
                    "createBuffer",
                    "createFramebuffer",
                    "createProgram",
                    "createRenderbuffer",
                    "createShader",
                    "createTexture"
                ];
                for (var ii = 0; ii < creationFunctions.length; ++ii) {
                    var functionName = creationFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            var obj = f.apply(ctx, arguments);
                            obj.__webglDebugContextLostId__ = contextId_;
                            resourceDb_.push(obj);
                            return obj;
                        };
                    }(ctx[functionName]);
                }
                var functionsThatShouldReturnNull = [
                    "getActiveAttrib",
                    "getActiveUniform",
                    "getBufferParameter",
                    "getContextAttributes",
                    "getAttachedShaders",
                    "getFramebufferAttachmentParameter",
                    "getParameter",
                    "getProgramParameter",
                    "getProgramInfoLog",
                    "getRenderbufferParameter",
                    "getShaderParameter",
                    "getShaderInfoLog",
                    "getShaderSource",
                    "getTexParameter",
                    "getUniform",
                    "getUniformLocation",
                    "getVertexAttrib"
                ];
                for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
                    var functionName = functionsThatShouldReturnNull[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                var isFunctions = [
                    "isBuffer",
                    "isEnabled",
                    "isFramebuffer",
                    "isProgram",
                    "isRenderbuffer",
                    "isShader",
                    "isTexture"
                ];
                for (var ii = 0; ii < isFunctions.length; ++ii) {
                    var functionName = isFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return false;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                wrapper_["checkFramebufferStatus"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return ctx.FRAMEBUFFER_UNSUPPORTED;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["checkFramebufferStatus"]);
                wrapper_["getAttribLocation"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return -1;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getAttribLocation"]);
                wrapper_["getVertexAttribOffset"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return 0;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getVertexAttribOffset"]);
                wrapper_["isContextLost"] = function () {
                    return contextLost_;
                };
                function wrapEvent(listener) {
                    if (typeof (listener) == "function") {
                        return listener;
                    }
                    else {
                        return function (info) {
                            listener.handleEvent(info);
                        };
                    }
                }
                wrapper_["registerOnContextLostListener"] = function (listener) {
                    onLost_ = wrapEvent(listener);
                };
                wrapper_["registerOnContextRestoredListener"] = function (listener) {
                    if (contextLost_) {
                        nextOnRestored_ = wrapEvent(listener);
                    }
                    else {
                        onRestored_ = wrapEvent(listener);
                    }
                };
                return wrapper_;
            };
            WebGLDebugUtils.glValidEnumContexts = {
                'enable': { 0: true },
                'disable': { 0: true },
                'getParameter': { 0: true },
                'drawArrays': { 0: true },
                'drawElements': { 0: true, 2: true },
                'createShader': { 0: true },
                'getShaderParameter': { 1: true },
                'getProgramParameter': { 1: true },
                'getVertexAttrib': { 1: true },
                'vertexAttribPointer': { 2: true },
                'bindTexture': { 0: true },
                'activeTexture': { 0: true },
                'getTexParameter': { 0: true, 1: true },
                'texParameterf': { 0: true, 1: true },
                'texParameteri': { 0: true, 1: true, 2: true },
                'texImage2D': { 0: true, 2: true, 6: true, 7: true },
                'texSubImage2D': { 0: true, 6: true, 7: true },
                'copyTexImage2D': { 0: true, 2: true },
                'copyTexSubImage2D': { 0: true },
                'generateMipmap': { 0: true },
                'bindBuffer': { 0: true },
                'bufferData': { 0: true, 2: true },
                'bufferSubData': { 0: true },
                'getBufferParameter': { 0: true, 1: true },
                'pixelStorei': { 0: true, 1: true },
                'readPixels': { 4: true, 5: true },
                'bindRenderbuffer': { 0: true },
                'bindFramebuffer': { 0: true },
                'checkFramebufferStatus': { 0: true },
                'framebufferRenderbuffer': { 0: true, 1: true, 2: true },
                'framebufferTexture2D': { 0: true, 1: true, 2: true },
                'getFramebufferAttachmentParameter': { 0: true, 1: true, 2: true },
                'getRenderbufferParameter': { 0: true, 1: true },
                'renderbufferStorage': { 0: true, 1: true },
                'clear': { 0: true },
                'depthFunc': { 0: true },
                'blendFunc': { 0: true, 1: true },
                'blendFuncSeparate': { 0: true, 1: true, 2: true, 3: true },
                'blendEquation': { 0: true },
                'blendEquationSeparate': { 0: true, 1: true },
                'stencilFunc': { 0: true },
                'stencilFuncSeparate': { 0: true, 1: true },
                'stencilMaskSeparate': { 0: true },
                'stencilOp': { 0: true, 1: true, 2: true },
                'stencilOpSeparate': { 0: true, 1: true, 2: true, 3: true },
                'cullFace': { 0: true },
                'frontFace': { 0: true },
            };
            return WebGLDebugUtils;
        }());
        framework.WebGLDebugUtils = WebGLDebugUtils;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var WebGLUtils = (function () {
            function WebGLUtils() {
                this.GET_A_WEBGL_BROWSER = '' +
                    'This page requires a browser that supports WebGL.<br/>' +
                    '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';
                this.OTHER_PROBLEM = '' +
                    "It doesn't appear your computer can support WebGL.<br/>" +
                    '<a href="http://get.webgl.org">Click here for more information.</a>';
                if (!window.requestAnimationFrame) {
                    var tempwin = window;
                    window.requestAnimationFrame =
                        tempwin.requestAnimationFrame ||
                            tempwin.webkitRequestAnimationFrame ||
                            tempwin.mozRequestAnimationFrame ||
                            tempwin.oRequestAnimationFrame ||
                            tempwin.msRequestAnimationFrame ||
                            function (callback, element) {
                                window.setTimeout(callback, 1000 / 60);
                            };
                }
                if (!window.cancelAnimationFrame) {
                    var tempwin = window;
                    window.cancelAnimationFrame = (tempwin.cancelRequestAnimationFrame ||
                        window.webkitCancelAnimationFrame || tempwin.webkitCancelRequestAnimationFrame ||
                        tempwin.mozCancelAnimationFrame || tempwin.mozCancelRequestAnimationFrame ||
                        tempwin.msCancelAnimationFrame || tempwin.msCancelRequestAnimationFrame ||
                        tempwin.oCancelAnimationFrame || tempwin.oCancelRequestAnimationFrame ||
                        window.clearTimeout);
                }
            }
            WebGLUtils.prototype.makeFailHTML = function (msg) {
                return '' +
                    '<div style="margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;">' + msg + '</div>';
            };
            ;
            WebGLUtils.prototype.setupWebGL = function (canvas, opt_attribs, opt_onError) {
                var _this = this;
                if (opt_attribs === void 0) { opt_attribs = null; }
                if (opt_onError === void 0) { opt_onError = null; }
                var handleCreationError = function (msg) {
                    var container = document.getElementsByTagName("body")[0];
                    if (container) {
                        var str = WebGLRenderingContext ?
                            _this.OTHER_PROBLEM :
                            _this.GET_A_WEBGL_BROWSER;
                        if (msg) {
                            str += "<br/><br/>Status: " + msg;
                        }
                        container.innerHTML = _this.makeFailHTML(str);
                    }
                };
                opt_onError = opt_onError || handleCreationError;
                if (canvas.addEventListener) {
                    canvas.addEventListener("webglcontextcreationerror", function (event) {
                        opt_onError(event.statusMessage);
                    }, false);
                }
                var context = this.create3DContext(canvas, opt_attribs);
                if (!context) {
                    if (!WebGLRenderingContext) {
                        opt_onError("");
                    }
                    else {
                        opt_onError("");
                    }
                }
                return context;
            };
            WebGLUtils.prototype.create3DContext = function (canvas, opt_attribs) {
                var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                var context = null;
                for (var ii = 0; ii < names.length; ++ii) {
                    try {
                        context = canvas.getContext(names[ii], opt_attribs);
                    }
                    catch (e) { }
                    if (context) {
                        break;
                    }
                }
                return context;
            };
            return WebGLUtils;
        }());
        framework.WebGLUtils = WebGLUtils;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var loadRetryMgr = (function () {
            function loadRetryMgr() {
            }
            return loadRetryMgr;
        }());
        function xhrLoad(url, fun, onprocess, responseType, loadedFun) {
            if (onprocess === void 0) { onprocess = null; }
            var req = new XMLHttpRequest();
            var isLoaded = false;
            req.open("GET", url);
            req.responseType = responseType;
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        loadedFun(req);
                        isLoaded = true;
                    }
                    else {
                        switch (req.status) {
                            case 404:
                                fun(null, new Error("got a 404:" + url));
                                break;
                        }
                    }
                }
            };
            req.onprogress = function (ev) {
                if (onprocess)
                    onprocess(ev.loaded, ev.total);
            };
            req.onerror = function (ev) {
                fun(null, new Error("URL : " + url + " \n onerr on req: "));
            };
            req.onloadend = function () {
                if (!isLoaded) {
                    if (!loadRetryMgr.urlCaseDic)
                        loadRetryMgr.urlCaseDic = {};
                    var dic = loadRetryMgr.urlCaseDic;
                    dic[url] = isNaN(dic[url]) || dic[url] < 0 ? 0 : dic[url];
                    if (dic[url] >= 2) {
                        dic[url] = 0;
                        fun(null, new Error("load this url fail  ：" + url), true);
                    }
                    else {
                        gd3d.io.xhrLoad(url, fun, onprocess, responseType, loadedFun);
                        dic[url]++;
                    }
                }
            };
            try {
                req.send();
            }
            catch (err) {
                fun(null, err);
            }
        }
        io.xhrLoad = xhrLoad;
        function loadText(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            if (gd3d.framework.assetMgr.useBinJs) {
                url = gd3d.framework.assetMgr.correctTxtFileName(url);
            }
            gd3d.io.xhrLoad(url, fun, onprocess, "text", function (req) {
                fun(req.responseText, null);
            });
        }
        io.loadText = loadText;
        function loadArrayBuffer(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            if (gd3d.framework.assetMgr.useBinJs) {
                url = gd3d.framework.assetMgr.correctFileName(url);
            }
            gd3d.io.xhrLoad(url, fun, onprocess, "arraybuffer", function (req) {
                fun(req.response, null);
            });
        }
        io.loadArrayBuffer = loadArrayBuffer;
        function loadBlob(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            gd3d.io.xhrLoad(url, fun, onprocess, "blob", function (req) {
                fun(req.response, null);
            });
        }
        io.loadBlob = loadBlob;
        function loadImg(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            gd3d.io.xhrLoad(url, fun, onprocess, "blob", function (req) {
                var blob = req.response;
                var img = document.createElement("img");
                img.crossOrigin = "";
                img.onload = function (e) {
                    window.URL.revokeObjectURL(img.src);
                    fun(img, null);
                };
                img.onerror = function (e) {
                    fun(null, new Error("error when blob to img:" + url));
                };
                try {
                    img.src = window.URL.createObjectURL(blob);
                }
                catch (e) {
                    fun(null, e);
                }
            });
        }
        io.loadImg = loadImg;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        var pool = (function () {
            function pool() {
            }
            pool.collect_all = function () {
                pool.collect_vector4();
                pool.collect_vector3();
                pool.collect_vector2();
                pool.collect_matrix();
                pool.collect_quaternion();
                pool.collect_color();
                pool.collect_pickInfo();
            };
            Object.defineProperty(pool, "vector4_one", {
                get: function () {
                    if (pool._vector4_one == null) {
                        pool._vector4_one = new math.vector4(1, 1, 1, 1);
                    }
                    return pool._vector4_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector4 = function (x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 0; }
                if (pool.unused_vector4.length > 0) {
                    var v4 = pool.unused_vector4.pop();
                    v4.x = x;
                    v4.y = y;
                    v4.z = z;
                    v4.w = w;
                    return v4;
                }
                else
                    return new math.vector4(x, y, z, w);
            };
            pool.clone_vector4 = function (src) {
                if (pool.unused_vector4.length > 0) {
                    var v = pool.unused_vector4.pop();
                    v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector4(src.x, src.y, src.z);
            };
            pool.delete_vector4 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector4) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_vector4.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector4吗？");
            };
            pool.collect_vector4 = function () {
                pool.unused_vector4.length = 0;
            };
            Object.defineProperty(pool, "color_one", {
                get: function () {
                    if (pool._color_one == null) {
                        pool._color_one = new math.color(1, 1, 1, 1);
                    }
                    return pool._color_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_color = function (r, g, b, a) {
                if (r === void 0) { r = 0; }
                if (g === void 0) { g = 0; }
                if (b === void 0) { b = 0; }
                if (a === void 0) { a = 0; }
                if (pool.unused_color.length > 0) {
                    var c = pool.unused_color.pop();
                    c.r = r;
                    c.g = g;
                    c.b = b;
                    c.a = a;
                    return c;
                }
                else
                    return new math.color(r, g, b, a);
            };
            pool.delete_color = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.color) {
                    v.r = v.g = v.b = 0;
                    v.a = 1;
                    pool.unused_color.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是color吗？");
            };
            pool.collect_color = function () {
                pool.unused_color.length = 0;
            };
            Object.defineProperty(pool, "vector3_up", {
                get: function () {
                    if (pool._vector3_up == null) {
                        pool._vector3_up = new math.vector3(0, 1, 0);
                    }
                    pool._vector3_up.y = 1;
                    pool._vector3_up.x = pool._vector3_up.z = 0;
                    return pool._vector3_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_right", {
                get: function () {
                    if (pool._vector3_right == null) {
                        pool._vector3_right = new math.vector3(1, 0, 0);
                    }
                    pool._vector3_right.x = 1;
                    pool._vector3_right.y = pool._vector3_right.z = 0;
                    return pool._vector3_right;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_forward", {
                get: function () {
                    if (pool._vector3_forward == null) {
                        pool._vector3_forward = new math.vector3(0, 0, 1);
                    }
                    pool._vector3_forward.x = pool._vector3_forward.y = 0;
                    pool._vector3_forward.z = 1;
                    return pool._vector3_forward;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_zero", {
                get: function () {
                    if (pool._vector3_zero == null) {
                        pool._vector3_zero = new math.vector3(0, 0, 0);
                    }
                    pool._vector3_zero.x = pool._vector3_zero.y = pool._vector3_zero.z = 0;
                    return pool._vector3_zero;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_one", {
                get: function () {
                    if (pool._vector3_one == null) {
                        pool._vector3_one = new math.vector3(1, 1, 1);
                    }
                    pool._vector3_one.x = pool._vector3_one.y = pool._vector3_one.z = 1;
                    return pool._vector3_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector3 = function (x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (pool.unused_vector3.length > 0) {
                    var v3 = pool.unused_vector3.pop();
                    v3.x = x;
                    v3.y = y;
                    v3.z = z;
                    return v3;
                }
                else
                    return new math.vector3(x, y, z);
            };
            pool.clone_vector3 = function (src) {
                if (pool.unused_vector3.length > 0) {
                    var v = pool.unused_vector3.pop();
                    v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector3(src.x, src.y, src.z);
            };
            pool.delete_vector3 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector3) {
                    v.x = v.y = v.z = 0;
                    pool.unused_vector3.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector3吗？");
            };
            pool.delete_vector3Array = function (vs) {
                for (var i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        this.delete_vector3(vs[i]);
                    }
                }
                vs.length = 0;
            };
            pool.collect_vector3 = function () {
                pool.unused_vector3.length = 0;
            };
            Object.defineProperty(pool, "vector2_zero", {
                get: function () {
                    if (pool._vector2_zero == null) {
                        pool._vector2_zero = new math.vector2(0, 0);
                    }
                    pool._vector2_zero.x = pool._vector2_zero.y = 1;
                    return pool._vector2_zero;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector2_up", {
                get: function () {
                    if (pool._vector2_up == null) {
                        pool._vector2_up = new math.vector2(0, 1);
                    }
                    pool._vector2_up.x = 0;
                    pool._vector2_up.y = 1;
                    return pool._vector2_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector2_right", {
                get: function () {
                    if (pool._vector2_right == null) {
                        pool._vector2_right = new math.vector2(1, 0);
                    }
                    pool._vector2_right.x = 1;
                    pool._vector2_right.y = 0;
                    return pool._vector2_right;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector2 = function (x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (pool.unused_vector2.length > 0) {
                    var v2 = pool.unused_vector2.pop();
                    v2.x = x;
                    v2.y = y;
                    return v2;
                }
                else
                    return new math.vector2(x, y);
            };
            pool.clone_vector2 = function (src) {
                if (pool.unused_vector2.length > 0) {
                    var v = pool.unused_vector2.pop();
                    if (src.rawData.length > v.rawData.length) {
                        src.rawData[0] = v.rawData[0];
                        src.rawData[1] = v.rawData[1];
                    }
                    else
                        v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector2(src.x, src.y);
            };
            pool.delete_vector2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector2) {
                    v.x = v.y = 0;
                    pool.unused_vector2.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector2吗？");
            };
            pool.delete_vector2Array = function (vs) {
                for (var i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        this.delete_vector2(vs[i]);
                    }
                }
                vs.length = 0;
            };
            pool.collect_vector2 = function () {
                pool.unused_vector2.length = 0;
            };
            pool.new_matrix3x2 = function () {
                if (pool.unused_matrix3x2.length > 0)
                    return pool.unused_matrix3x2.pop();
                else
                    return new math.matrix3x2();
            };
            pool.clone_matrix3x2 = function (src) {
                var v = pool.new_matrix3x2();
                v.rawData.set(src.rawData);
                return v;
            };
            pool.delete_matrix3x2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix3x2) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 1;
                    v.rawData[4] = 0;
                    v.rawData[5] = 0;
                    pool.unused_matrix3x2.push(v);
                }
                else {
                    console.error("kindding me?确定你要回收的是matrix3x2吗？");
                }
            };
            pool.collect_matrix3x2 = function () {
                pool.unused_matrix3x2.length = 0;
            };
            pool.new_matrix = function () {
                if (pool.unused_matrix.length > 0)
                    return pool.unused_matrix.pop();
                else
                    return new math.matrix();
            };
            pool.clone_matrix = function (src) {
                var v = pool.new_matrix();
                v.rawData.set(src.rawData);
                return v;
            };
            pool.delete_matrix = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 0;
                    v.rawData[5] = 1;
                    v.rawData[6] = 0;
                    v.rawData[7] = 0;
                    v.rawData[8] = 0;
                    v.rawData[9] = 0;
                    v.rawData[10] = 1;
                    v.rawData[11] = 0;
                    v.rawData[12] = 0;
                    v.rawData[13] = 0;
                    v.rawData[14] = 0;
                    v.rawData[15] = 1;
                    pool.unused_matrix.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是matrix吗？");
            };
            pool.collect_matrix = function () {
                pool.unused_matrix.length = 0;
            };
            pool.new_quaternion = function (x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 1; }
                if (pool.unused_quaternion.length > 0) {
                    var q = pool.unused_quaternion.pop();
                    q.x = x;
                    q.y = y;
                    q.z = z;
                    q.w = w;
                    return q;
                }
                else
                    return new math.quaternion(x, y, z, w);
            };
            pool.clone_quaternion = function (src) {
                if (pool.unused_quaternion.length > 0) {
                    var v = pool.unused_quaternion.pop();
                    v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.quaternion(src.x, src.y, src.z, src.w);
            };
            pool.delete_quaternion = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.quaternion) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_quaternion.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是quaternion吗？");
            };
            pool.collect_quaternion = function () {
                pool.unused_quaternion.length = 0;
            };
            pool.new_pickInfo = function (bu, bv, distance) {
                if (bu === void 0) { bu = 0; }
                if (bv === void 0) { bv = 0; }
                if (distance === void 0) { distance = 0; }
                if (pool.unused_pickInfo.length > 0) {
                    var pk = pool.unused_pickInfo.pop();
                    pk.bu = bu;
                    pk.bv = bv;
                    pk.distance = distance;
                    return pk;
                }
                else
                    return new gd3d.framework.pickinfo(bu, bv, distance);
            };
            pool.delete_pickInfo = function (v) {
                if (v == null)
                    return;
                if (v instanceof gd3d.framework.pickinfo) {
                    v.init();
                    pool.unused_pickInfo.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是pickInfo吗？");
            };
            pool.collect_pickInfo = function () {
                pool.unused_pickInfo.length = 0;
            };
            pool.new_rect = function (x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                if (pool.unused_rect.length > 0) {
                    var r = pool.unused_rect.pop();
                    r.x = x;
                    r.y = y;
                    r.w = w;
                    r.h = h;
                    return r;
                }
                else
                    return new math.rect(x, y, w, h);
            };
            pool.clone_rect = function (src) {
                if (pool.unused_rect.length > 0) {
                    var v = pool.unused_rect.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.w = src.w;
                    v.h = src.h;
                    return v;
                }
                else
                    return new math.rect(src.x, src.y, src.w, src.h);
            };
            pool.delete_rect = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.rect) {
                    v.x = v.y = v.w = v.h = 0;
                    pool.unused_rect.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是rect吗？");
            };
            pool.collect_rect = function () {
                pool.unused_rect.length = 0;
            };
            pool.unused_vector4 = [];
            pool.unused_color = [];
            pool.unused_vector3 = [];
            pool.unused_vector2 = [];
            pool.unused_matrix3x2 = [];
            pool.unused_matrix = [];
            pool.identityMat = new math.matrix();
            pool.unused_quaternion = [];
            pool.unused_pickInfo = [];
            pool.unused_rect = [];
            return pool;
        }());
        math.pool = pool;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var caps = (function () {
            function caps() {
            }
            return caps;
        }());
        render.caps = caps;
        var webglkit = (function () {
            function webglkit() {
            }
            webglkit.SetMaxVertexAttribArray = function (webgl, count) {
                for (var i = count; i < webglkit._maxVertexAttribArray; i++) {
                    webgl.disableVertexAttribArray(i);
                }
                webglkit._maxVertexAttribArray = count;
            };
            webglkit.GetTextureNumber = function (webgl, index) {
                webglkit.initConst(webgl);
                return webglkit._texNumber[index];
            };
            webglkit.initConst = function (webgl) {
                if (webglkit._texNumber == null) {
                    webglkit._texNumber = [];
                    webglkit._texNumber.push(webgl.TEXTURE0);
                    webglkit._texNumber.push(webgl.TEXTURE1);
                    webglkit._texNumber.push(webgl.TEXTURE2);
                    webglkit._texNumber.push(webgl.TEXTURE3);
                    webglkit._texNumber.push(webgl.TEXTURE4);
                    webglkit._texNumber.push(webgl.TEXTURE5);
                    webglkit._texNumber.push(webgl.TEXTURE6);
                    webglkit._texNumber.push(webgl.TEXTURE7);
                    webglkit._texNumber.push(webgl.TEXTURE8);
                    webglkit._texNumber.push(webgl.TEXTURE9);
                    webglkit._texNumber.push(webgl.TEXTURE10);
                    webglkit._texNumber.push(webgl.TEXTURE11);
                    webglkit._texNumber.push(webgl.TEXTURE12);
                    webglkit._texNumber.push(webgl.TEXTURE13);
                    webglkit._texNumber.push(webgl.TEXTURE14);
                    webglkit._texNumber.push(webgl.TEXTURE15);
                    webglkit.LEQUAL = webgl.LEQUAL;
                    webglkit.NEVER = webgl.NEVER;
                    webglkit.EQUAL = webgl.EQUAL;
                    webglkit.GEQUAL = webgl.GEQUAL;
                    webglkit.NOTEQUAL = webgl.NOTEQUAL;
                    webglkit.LESS = webgl.LESS;
                    webglkit.GREATER = webgl.GREATER;
                    webglkit.ALWAYS = webgl.ALWAYS;
                    webglkit.FUNC_ADD = webgl.FUNC_ADD;
                    webglkit.FUNC_SUBTRACT = webgl.FUNC_SUBTRACT;
                    webglkit.FUNC_REVERSE_SUBTRACT = webgl.FUNC_REVERSE_SUBTRACT;
                    webglkit.ONE = webgl.ONE;
                    webglkit.ZERO = webgl.ZERO;
                    webglkit.SRC_ALPHA = webgl.SRC_ALPHA;
                    webglkit.SRC_COLOR = webgl.SRC_COLOR;
                    webglkit.ONE_MINUS_SRC_ALPHA = webgl.ONE_MINUS_SRC_ALPHA;
                    webglkit.ONE_MINUS_SRC_COLOR = webgl.ONE_MINUS_SRC_COLOR;
                    webglkit.ONE_MINUS_DST_ALPHA = webgl.ONE_MINUS_DST_ALPHA;
                    webglkit.ONE_MINUS_DST_COLOR = webgl.ONE_MINUS_DST_COLOR;
                    if (webgl.getExtension) {
                        webglkit.caps.standardDerivatives = (webgl.getExtension('OES_standard_derivatives') !== null);
                        webglkit.caps.pvrtcExtension = webgl.getExtension('WEBGL_compressed_texture_pvrtc');
                        webglkit.caps.atcExtension = webgl.getExtension('WEBGL_compressed_texture_atc');
                    }
                }
            };
            webglkit._maxVertexAttribArray = 0;
            webglkit._texNumber = null;
            webglkit.caps = new caps();
            return webglkit;
        }());
        render.webglkit = webglkit;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var ShowFaceStateEnum;
        (function (ShowFaceStateEnum) {
            ShowFaceStateEnum[ShowFaceStateEnum["ALL"] = 0] = "ALL";
            ShowFaceStateEnum[ShowFaceStateEnum["CCW"] = 1] = "CCW";
            ShowFaceStateEnum[ShowFaceStateEnum["CW"] = 2] = "CW";
        })(ShowFaceStateEnum = render.ShowFaceStateEnum || (render.ShowFaceStateEnum = {}));
        var DrawModeEnum;
        (function (DrawModeEnum) {
            DrawModeEnum[DrawModeEnum["VboTri"] = 0] = "VboTri";
            DrawModeEnum[DrawModeEnum["VboLine"] = 1] = "VboLine";
            DrawModeEnum[DrawModeEnum["EboTri"] = 2] = "EboTri";
            DrawModeEnum[DrawModeEnum["EboLine"] = 3] = "EboLine";
        })(DrawModeEnum = render.DrawModeEnum || (render.DrawModeEnum = {}));
        var BlendModeEnum;
        (function (BlendModeEnum) {
            BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
            BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
            BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
            BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
            BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
        })(BlendModeEnum = render.BlendModeEnum || (render.BlendModeEnum = {}));
        var glDrawPass = (function () {
            function glDrawPass() {
                this.state_showface = ShowFaceStateEnum.CCW;
                this.state_zwrite = false;
                this.state_ztest = false;
                this.state_ztest_method = render.webglkit.LEQUAL;
                this.state_blend = false;
                this.state_blendEquation = 0;
                this.state_blendSrcRGB = 0;
                this.state_blendDestRGB = 0;
                this.state_blendSrcAlpha = 0;
                this.state_blendDestALpha = 0;
            }
            glDrawPass.prototype.setProgram = function (program, uniformDefault) {
                if (uniformDefault === void 0) { uniformDefault = false; }
                this.program = program;
                this.mapuniforms = program.mapUniform;
            };
            glDrawPass.prototype.setAlphaBlend = function (mode) {
                this.state_blendMode = mode;
                if (mode == BlendModeEnum.Add) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Add_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Close) {
                    this.state_blend = false;
                }
            };
            glDrawPass.resetLastState = function () {
                this.lastShowFace = -1;
                this.lastZWrite = null;
                this.lastZTest = null;
                this.lastZTestMethod = -1;
                this.lastBlend = null;
                this.lastBlendMode = null;
            };
            glDrawPass.prototype.use = function (webgl, applyUniForm) {
                if (applyUniForm === void 0) { applyUniForm = true; }
                if (this.state_showface != glDrawPass.lastShowFace) {
                    glDrawPass.lastShowFace = this.state_showface;
                    if (this.state_showface == ShowFaceStateEnum.ALL) {
                        webgl.disable(webgl.CULL_FACE);
                    }
                    else {
                        if (this.state_showface == ShowFaceStateEnum.CCW) {
                            webgl.frontFace(webgl.CCW);
                        }
                        else {
                            webgl.frontFace(webgl.CW);
                        }
                        webgl.cullFace(webgl.BACK);
                        webgl.enable(webgl.CULL_FACE);
                    }
                }
                if (this.state_zwrite != glDrawPass.lastZWrite) {
                    glDrawPass.lastZWrite = this.state_zwrite;
                    if (this.state_zwrite) {
                        webgl.depthMask(true);
                    }
                    else {
                        webgl.depthMask(false);
                    }
                }
                if (this.state_ztest != glDrawPass.lastZTest) {
                    glDrawPass.lastZTest = this.state_ztest;
                    if (this.state_ztest) {
                        webgl.enable(webgl.DEPTH_TEST);
                    }
                    else {
                        webgl.disable(webgl.DEPTH_TEST);
                    }
                }
                if (this.state_ztest && glDrawPass.lastZTestMethod != this.state_ztest_method) {
                    glDrawPass.lastZTestMethod = this.state_ztest_method;
                    webgl.depthFunc(this.state_ztest_method);
                }
                if (this.state_blend != glDrawPass.lastBlend) {
                    glDrawPass.lastBlend = this.state_blend;
                    if (this.state_blend) {
                        webgl.enable(webgl.BLEND);
                    }
                    else {
                        webgl.disable(webgl.BLEND);
                    }
                }
                if (this.state_blend && glDrawPass.lastBlendMode != this.state_blendMode) {
                    glDrawPass.lastBlendMode = this.state_blendMode;
                    webgl.blendEquation(this.state_blendEquation);
                    webgl.blendFuncSeparate(this.state_blendSrcRGB, this.state_blendDestRGB, this.state_blendSrcAlpha, this.state_blendDestALpha);
                }
                this.program.use(webgl);
            };
            glDrawPass.prototype.draw = function (webgl, mesh, drawmode, drawindexindex, drawbegin, drawcount) {
                if (drawmode === void 0) { drawmode = DrawModeEnum.EboTri; }
                if (drawindexindex === void 0) { drawindexindex = 0; }
                if (drawbegin === void 0) { drawbegin = 0; }
                if (drawcount === void 0) { drawcount = -1; }
                this.use(webgl);
                mesh.bind(webgl, this.program, drawindexindex);
                if (drawmode == DrawModeEnum.VboTri) {
                    mesh.drawArrayTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.VboLine) {
                    mesh.drawArrayLines(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboTri) {
                    mesh.drawElementTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboLine) {
                    mesh.drawElementLines(webgl, drawbegin, drawcount);
                }
            };
            glDrawPass.prototype.getCurDrawState = function () {
                var res = "";
                res = this.formate(this.state_showface.toString(), res);
                res = this.formate(this.state_zwrite.toString(), res);
                res = this.formate(this.state_ztest.toString(), res);
                if (this.state_ztest) {
                    res = this.formate(this.state_ztest_method.toString(), res);
                }
                else {
                    res = this.formate("ztestnone", res);
                }
                res = this.formate(this.state_blend.toString(), res);
                if (this.state_blend) {
                    res = this.formate(this.state_blendEquation.toString(), res);
                }
                else {
                    res = this.formate("blendnone", res);
                }
                return res;
            };
            glDrawPass.prototype.getCurBlendVal = function () {
                var res = "";
                res = this.formate(this.state_blendSrcRGB.toString(), res);
                res = this.formate(this.state_blendDestRGB.toString(), res);
                res = this.formate(this.state_blendSrcAlpha.toString(), res);
                res = this.formate(this.state_blendDestALpha.toString(), res);
                return res;
            };
            glDrawPass.prototype.formate = function (str, out) {
                return out += str + "_";
            };
            glDrawPass.lastShowFace = -1;
            glDrawPass.lastZWrite = null;
            glDrawPass.lastZTest = null;
            glDrawPass.lastZTestMethod = -1;
            glDrawPass.lastBlend = null;
            glDrawPass.lastBlendMode = null;
            return glDrawPass;
        }());
        render.glDrawPass = glDrawPass;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var VertexFormatMask;
        (function (VertexFormatMask) {
            VertexFormatMask[VertexFormatMask["Position"] = 1] = "Position";
            VertexFormatMask[VertexFormatMask["Normal"] = 2] = "Normal";
            VertexFormatMask[VertexFormatMask["Tangent"] = 4] = "Tangent";
            VertexFormatMask[VertexFormatMask["Color"] = 8] = "Color";
            VertexFormatMask[VertexFormatMask["UV0"] = 16] = "UV0";
            VertexFormatMask[VertexFormatMask["UV1"] = 32] = "UV1";
            VertexFormatMask[VertexFormatMask["BlendIndex4"] = 64] = "BlendIndex4";
            VertexFormatMask[VertexFormatMask["BlendWeight4"] = 128] = "BlendWeight4";
            VertexFormatMask[VertexFormatMask["ColorEX"] = 256] = "ColorEX";
        })(VertexFormatMask = render.VertexFormatMask || (render.VertexFormatMask = {}));
        var number4 = (function () {
            function number4() {
            }
            return number4;
        }());
        render.number4 = number4;
        var MeshTypeEnum;
        (function (MeshTypeEnum) {
            MeshTypeEnum[MeshTypeEnum["Static"] = 0] = "Static";
            MeshTypeEnum[MeshTypeEnum["Dynamic"] = 1] = "Dynamic";
            MeshTypeEnum[MeshTypeEnum["Stream"] = 2] = "Stream";
        })(MeshTypeEnum = render.MeshTypeEnum || (render.MeshTypeEnum = {}));
        var drawInfo = (function () {
            function drawInfo() {
                this.triCount = 0;
                this.vboCount = 0;
                this.renderCount = 0;
            }
            Object.defineProperty(drawInfo, "ins", {
                get: function () {
                    if (drawInfo._ins == null)
                        drawInfo._ins = new drawInfo();
                    return drawInfo._ins;
                },
                enumerable: true,
                configurable: true
            });
            return drawInfo;
        }());
        render.drawInfo = drawInfo;
        var glMesh = (function () {
            function glMesh() {
                this.bindIndex = -1;
                this.vertexFormat = VertexFormatMask.Position;
            }
            glMesh.prototype.initBuffer = function (webgl, vf, vertexCount, mode) {
                if (mode === void 0) { mode = MeshTypeEnum.Static; }
                if (this.vbo != null)
                    throw new Error("you can only initbuffer once.");
                if (mode == MeshTypeEnum.Static)
                    this.mode = webgl.STATIC_DRAW;
                else if (mode == MeshTypeEnum.Dynamic)
                    this.mode = webgl.DYNAMIC_DRAW;
                else if (mode == MeshTypeEnum.Stream)
                    this.mode = webgl.STREAM_DRAW;
                this.vertexFormat = vf;
                this.vertexCount = vertexCount;
                if (vertexCount > 0) {
                    this.vertexByteSize = render.meshData.calcByteSize(vf);
                    this.vbo = webgl.createBuffer();
                    webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                    webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
                }
                this.indexCounts = [];
                this.ebos = [];
            };
            glMesh.prototype.addIndex = function (webgl, indexcount) {
                var index = this.ebos.length;
                var _ebo = webgl.createBuffer();
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, _ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
                this.ebos.push(_ebo);
                this.indexCounts.push(indexcount);
                return index;
            };
            glMesh.prototype.resetVboSize = function (webgl, vertexCount) {
                this.vertexCount = vertexCount;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
            };
            glMesh.prototype.resetEboSize = function (webgl, eboindex, indexcount) {
                this.indexCounts[eboindex] = indexcount;
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
            };
            glMesh.prototype.dispose = function (webgl) {
                webgl.deleteBuffer(this.vbo);
                this.vbo = null;
                if (this.ebos) {
                    for (var i = 0; i < this.ebos.length; i++)
                        webgl.deleteBuffer(this.ebos[i]);
                    this.ebos.length = 0;
                }
            };
            glMesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.vertexByteSize * this.vertexCount;
                for (var k in this.indexCounts) {
                    total += this.indexCounts[k] * 2;
                }
                return total;
            };
            glMesh.prototype.bindVboBuffer = function (webgl) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
            };
            glMesh.prototype.bind = function (webgl, shadercode, bindEbo) {
                if (bindEbo === void 0) { bindEbo = 0; }
                this.bindIndex = bindEbo;
                if (bindEbo >= 0) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[bindEbo]);
                }
                var total = this.vertexByteSize;
                var seek = 0;
                var channel = 0;
                {
                    if (shadercode.posPos >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posPos);
                        webgl.vertexAttribPointer(shadercode.posPos, 3, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                if (this.vertexFormat & VertexFormatMask.Normal) {
                    if (shadercode.posNormal >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posNormal);
                        webgl.vertexAttribPointer(shadercode.posNormal, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posNormal >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posNormal);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Tangent) {
                    if (shadercode.posTangent >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posTangent);
                        webgl.vertexAttribPointer(shadercode.posTangent, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posTangent >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posTangent);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Color) {
                    if (shadercode.posColor >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColor);
                        webgl.vertexAttribPointer(shadercode.posColor, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColor >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColor);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV0) {
                    if (shadercode.posUV0 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV0);
                        webgl.vertexAttribPointer(shadercode.posUV0, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV0 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV0);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV1) {
                    if (shadercode.posUV2 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV2);
                        webgl.vertexAttribPointer(shadercode.posUV2, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV2 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV2);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendIndex4) {
                    if (shadercode.posBlendIndex4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendIndex4);
                        webgl.vertexAttribPointer(shadercode.posBlendIndex4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendIndex4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendIndex4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendWeight4) {
                    if (shadercode.posBlendWeight4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendWeight4);
                        webgl.vertexAttribPointer(shadercode.posBlendWeight4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendWeight4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendWeight4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.ColorEX) {
                    if (shadercode.posColorEx >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColorEx);
                        webgl.vertexAttribPointer(shadercode.posColorEx, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColorEx >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColorEx);
                    channel++;
                }
                render.webglkit.SetMaxVertexAttribArray(webgl, channel);
            };
            glMesh.prototype.uploadVertexSubData = function (webgl, varray, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferSubData(webgl.ARRAY_BUFFER, offset, varray);
            };
            glMesh.prototype.uploadVertexData = function (webgl, varray) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, varray, this.mode);
            };
            glMesh.prototype.uploadIndexSubData = function (webgl, eboindex, data, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, offset, data);
            };
            glMesh.prototype.uploadIndexData = function (webgl, eboindex, data) {
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, data, this.mode);
            };
            glMesh.prototype.drawArrayTris = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.vertexCount / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.TRIANGLES, start, count);
            };
            glMesh.prototype.drawArrayLines = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.vertexCount / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.LINES, start, count);
            };
            glMesh.prototype.drawElementTris = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawElements(webgl.TRIANGLES, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            glMesh.prototype.drawElementLines = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawElements(webgl.LINES, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            return glMesh;
        }());
        render.glMesh = glMesh;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var meshData = (function () {
            function meshData() {
            }
            meshData.addQuadPos = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
            };
            meshData.addQuadPos_Quad = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
                data.trisindex.push(istart + 2);
            };
            meshData.addQuadVec3ByValue = function (array, value) {
                for (var i = 0; i < 4; i++) {
                    var v = gd3d.math.pool.clone_vector3(value);
                    array.push(v);
                }
            };
            meshData.addQuadVec3 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.addQuadVec2 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.genQuad = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, 0),
                    new gd3d.math.vector3(-half, -half, 0),
                    new gd3d.math.vector3(half, half, 0),
                    new gd3d.math.vector3(half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(1, 0)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genQuad_forparticle = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(0, half, 0),
                    new gd3d.math.vector3(0, -half, 0),
                    new gd3d.math.vector3(2 * half, half, 0),
                    new gd3d.math.vector3(2 * half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genPlaneCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, 0, half),
                    new gd3d.math.vector3(-half, 0, -half),
                    new gd3d.math.vector3(half, 0, half),
                    new gd3d.math.vector3(half, 0, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genCylinderCCW = function (height, radius, segment) {
                if (segment === void 0) { segment = 20; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var normal = new gd3d.math.vector3(0, 1, 0);
                for (var s = 0; s < 4; s++) {
                    var y = (s < 2 ? 0.5 : -0.5) * height;
                    if (s == 0)
                        normal = new gd3d.math.vector3(0, 1, 0);
                    else if (s == 3)
                        normal = new gd3d.math.vector3(0, -1, 0);
                    for (var i = 0; i < segment; i++) {
                        var r = i / segment * Math.PI * 2;
                        var x = Math.sin(r);
                        var z = Math.cos(r);
                        if (s == 1 || s == 2)
                            normal = new gd3d.math.vector3(x, 0, z);
                        data.pos.push(new gd3d.math.vector3(x * radius, y, z * radius));
                        var vn = gd3d.math.pool.clone_vector3(normal);
                        data.normal.push(vn);
                        if (s == 0 || s == 3) {
                            data.uv.push(new gd3d.math.vector2(x / 2 + 0.5, z / 2 + 0.5));
                        }
                        else {
                            data.uv.push(new gd3d.math.vector2(i / segment, y < 0 ? 0 : 1));
                        }
                    }
                }
                var itop = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, 0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, 1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                var ibottom = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, -0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, -1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                for (var i = 0; i < segment; i++) {
                    data.trisindex.push(itop);
                    data.trisindex.push(i == segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1);
                    data.trisindex.push(segment * 0 + i + 0);
                    data.trisindex.push(ibottom);
                    data.trisindex.push(segment * 3 + i + 0);
                    data.trisindex.push(i == segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1);
                    var t = segment * 1 + i;
                    var t2 = i == segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                    var b = segment * 2 + i;
                    var b2 = i == segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                    data.trisindex.push(t);
                    data.trisindex.push(t2);
                    data.trisindex.push(b);
                    data.trisindex.push(t2);
                    data.trisindex.push(b2);
                    data.trisindex.push(b);
                }
                return data;
            };
            meshData.genPyramid = function (height, halfsize) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var vec1 = new gd3d.math.vector3();
                var vec2 = new gd3d.math.vector3();
                var vec3 = new gd3d.math.vector3();
                var vec4 = new gd3d.math.vector3();
                var vec5 = new gd3d.math.vector3(0, -1, 0);
                var uvxx = new gd3d.math.vector2(0.5, 0.5);
                var uv00 = new gd3d.math.vector2(0, 0);
                var uv01 = new gd3d.math.vector2(0, 1);
                var uv10 = new gd3d.math.vector2(1, 0);
                var uv11 = new gd3d.math.vector2(1, 1);
                var ipos = 0;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(halfsize, height, halfsize), new gd3d.math.vector3(halfsize, -height, -halfsize), vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.uv.push(uv00);
                data.uv.push(uvxx);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(-halfsize, height, halfsize), new gd3d.math.vector3(halfsize, -height, halfsize), vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.uv.push(uv01);
                data.uv.push(uvxx);
                data.uv.push(uv11);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(-halfsize, height, -halfsize), new gd3d.math.vector3(-halfsize, -height, halfsize), vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.uv.push(uv11);
                data.uv.push(uvxx);
                data.uv.push(uv10);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(halfsize, height, -halfsize), new gd3d.math.vector3(-halfsize, -height, -halfsize), vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.uv.push(uv10);
                data.uv.push(uvxx);
                data.uv.push(uv00);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.uv.push(uv00);
                data.uv.push(uv10);
                data.uv.push(uv11);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                data.trisindex.push(ipos + 3);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos);
                ipos += 4;
                return data;
            };
            meshData.genSphereCCW = function (radius, widthSegments, heightSegments) {
                if (radius === void 0) { radius = 1; }
                if (widthSegments === void 0) { widthSegments = 24; }
                if (heightSegments === void 0) { heightSegments = 12; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                widthSegments = Math.max(3, Math.floor(widthSegments));
                heightSegments = Math.max(2, Math.floor(heightSegments));
                var ix, iy;
                var index = 0;
                var grid = [];
                var vertex = new gd3d.math.vector3();
                var normal = new gd3d.math.vector3();
                for (iy = 0; iy <= heightSegments; iy++) {
                    var verticesRow = [];
                    var v = iy / heightSegments;
                    for (ix = 0; ix <= widthSegments; ix++) {
                        var u = ix / widthSegments;
                        vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        vertex.y = radius * Math.cos(v * Math.PI);
                        vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        data.pos.push(gd3d.math.pool.clone_vector3(vertex));
                        normal = gd3d.math.pool.clone_vector3(vertex);
                        var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                        if (num > Number.MIN_VALUE) {
                            normal.x = normal.x / num;
                            normal.y = normal.y / num;
                            normal.z = normal.z / num;
                        }
                        else {
                            normal.x = 0;
                            normal.y = 0;
                            normal.z = 0;
                        }
                        data.normal.push(normal);
                        var uv = new gd3d.math.vector2(1 - u, v);
                        data.uv.push(uv);
                        verticesRow.push(index++);
                    }
                    grid.push(verticesRow);
                }
                for (iy = 0; iy < heightSegments; iy++) {
                    for (ix = 0; ix < widthSegments; ix++) {
                        var a = grid[iy][ix + 1];
                        var b = grid[iy][ix];
                        var c = grid[iy + 1][ix];
                        var d = grid[iy + 1][ix + 1];
                        if (iy !== 0)
                            data.trisindex.push(a, d, b);
                        if (iy !== heightSegments - 1)
                            data.trisindex.push(b, d, c);
                    }
                }
                return data;
            };
            meshData.genBoxCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(half, half, half),
                    new gd3d.math.vector3(half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(0, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, -half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                return data;
            };
            meshData.genBoxByArray = function (array, outData) {
                if (!outData)
                    return;
                outData.pos = [];
                outData.trisindex = [];
                outData.normal = [];
                outData.tangent = [];
                outData.uv = [];
                meshData.addQuadVec3ByValue(outData.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(outData, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(outData.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(outData, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(outData.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(outData, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(outData.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(outData, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(outData.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(outData, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(outData.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(outData, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new gd3d.math.vector3(0, 0, 1));
            };
            meshData.genBoxByArray_Quad = function (array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos_Quad(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                return data;
            };
            meshData.genCircleLineCCW = function (radius, segment, wide) {
                if (segment === void 0) { segment = 64; }
                if (wide === void 0) { wide = 0.05; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                for (var i = 0; i < segment; i++) {
                    var r1 = Math.PI * 2 * i / segment;
                    var x1 = Math.sin(r1) * radius;
                    var z1 = Math.cos(r1) * radius;
                    var r2 = Math.PI * 2 * (i + 1) / segment;
                    var x2 = Math.sin(r2) * radius;
                    var z2 = Math.cos(r2) * radius;
                    meshData.addQuadPos(data, [
                        new gd3d.math.vector3(x2, wide, z2),
                        new gd3d.math.vector3(x1, wide, z1),
                        new gd3d.math.vector3(x2, -wide, z2),
                        new gd3d.math.vector3(x1, -wide, z1)
                    ]);
                }
                return data;
            };
            meshData.prototype.caclByteLength = function () {
                var len = 0;
                if (this.pos != undefined)
                    len += 12;
                if (this.color != undefined)
                    len += 16;
                if (this.normal != undefined)
                    len += 12;
                if (this.tangent != undefined)
                    len += 12;
                if (this.uv != undefined)
                    len += 8;
                if (this.uv2 != undefined)
                    len += 8;
                if (this.blendIndex != undefined)
                    len += 16;
                if (this.blendWeight != undefined)
                    len += 16;
                if (this.colorex != undefined)
                    len += 16;
                if (this.trisindex != undefined)
                    len += 12;
                len *= this.pos.length;
                return len;
            };
            meshData.calcByteSize = function (vf) {
                var total = 0;
                if (vf & render.VertexFormatMask.Position)
                    total += 12;
                if (vf & render.VertexFormatMask.Normal)
                    total += 12;
                if (vf & render.VertexFormatMask.Tangent)
                    total += 12;
                if (vf & render.VertexFormatMask.Color)
                    total += 16;
                if (vf & render.VertexFormatMask.UV0)
                    total += 8;
                if (vf & render.VertexFormatMask.UV1)
                    total += 8;
                if (vf & render.VertexFormatMask.BlendIndex4)
                    total += 16;
                if (vf & render.VertexFormatMask.BlendWeight4)
                    total += 16;
                if (vf & render.VertexFormatMask.ColorEX)
                    total += 16;
                return total;
            };
            meshData.prototype.genVertexDataArray = function (vf) {
                var vertexCount = this.pos.length;
                var total = meshData.calcByteSize(vf) / 4;
                var varray = new Float32Array(total * vertexCount);
                for (var i = 0; i < vertexCount; i++) {
                    var nseek = 0;
                    varray[i * total + nseek] = this.pos[i].x;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].y;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].z;
                    nseek++;
                    if (vf & render.VertexFormatMask.Normal) {
                        if (this.normal == undefined || this.normal.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.normal[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Tangent) {
                        if (this.tangent == undefined || this.tangent.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.tangent[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Color) {
                        if (this.color == undefined || this.color.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.color[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].a;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV0) {
                        if (this.uv == undefined || this.uv.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV1) {
                        if (this.uv2 == undefined || this.uv2.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv2[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv2[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendIndex4) {
                        if (this.blendIndex == undefined || this.blendIndex.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendIndex[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendWeight4) {
                        if (this.blendWeight == undefined || this.blendWeight.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendWeight[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.ColorEX) {
                        if (this.colorex == undefined || this.colorex.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.colorex[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].a;
                            nseek++;
                        }
                    }
                }
                return varray;
            };
            meshData.prototype.genIndexDataArray = function () {
                return new Uint16Array(this.trisindex);
            };
            meshData.prototype.genIndexDataArrayTri2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 3) | 0); i++) {
                    line.push(this.trisindex[i * 3 + 0]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 0]);
                }
                return new Uint16Array(line);
            };
            meshData.prototype.genIndexDataArrayQuad2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 4) | 0); i++) {
                    line.push(this.trisindex[i * 4 + 0]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 3]);
                }
                return new Uint16Array(line);
            };
            meshData.cloneByObj = function (target) {
                var md = new meshData();
                target.originVF = md.originVF;
                if (target.pos) {
                    md.pos = [];
                    target.pos.forEach(function (element, idx) {
                        md.pos[idx] = new gd3d.math.vector3();
                        md.pos[idx].x = element.x;
                        md.pos[idx].y = element.y;
                        md.pos[idx].z = element.z;
                    });
                }
                if (target.color) {
                    md.color = [];
                    target.color.forEach(function (element, idx) {
                        md.color[idx] = new gd3d.math.color();
                        md.color[idx].r = element.r;
                        md.color[idx].g = element.g;
                        md.color[idx].b = element.b;
                        md.color[idx].a = element.a;
                    });
                }
                if (target.colorex) {
                    md.colorex = [];
                    target.colorex.forEach(function (element, idx) {
                        md.colorex[idx] = new gd3d.math.color();
                        md.colorex[idx].r = element.r;
                        md.colorex[idx].g = element.g;
                        md.colorex[idx].b = element.b;
                        md.colorex[idx].a = element.a;
                    });
                }
                if (target.uv) {
                    md.uv = [];
                    target.uv.forEach(function (element, idx) {
                        md.uv[idx] = new gd3d.math.vector2();
                        md.uv[idx].x = element.x;
                        md.uv[idx].y = element.y;
                    });
                }
                if (target.uv2) {
                    md.uv2 = [];
                    target.uv2.forEach(function (element, idx) {
                        md.uv2[idx] = new gd3d.math.vector2();
                        md.uv2[idx].x = element.x;
                        md.uv2[idx].y = element.y;
                    });
                }
                if (target.normal) {
                    md.normal = [];
                    target.normal.forEach(function (element, idx) {
                        md.normal[idx] = new gd3d.math.vector3();
                        md.normal[idx].x = element.x;
                        md.normal[idx].y = element.y;
                        md.normal[idx].z = element.z;
                    });
                }
                if (target.tangent) {
                    md.tangent = [];
                    target.tangent.forEach(function (element, idx) {
                        md.tangent[idx] = new gd3d.math.vector3();
                        md.tangent[idx].x = element.x;
                        md.tangent[idx].y = element.y;
                        md.tangent[idx].z = element.z;
                    });
                }
                if (target.blendIndex) {
                    md.blendIndex = [];
                    target.blendIndex.forEach(function (element, idx) {
                        md.blendIndex[idx] = new render.number4();
                        md.blendIndex[idx].v0 = element.v0;
                        md.blendIndex[idx].v1 = element.v1;
                        md.blendIndex[idx].v2 = element.v2;
                        md.blendIndex[idx].v3 = element.v3;
                    });
                }
                if (target.blendWeight) {
                    md.blendWeight = [];
                    target.blendWeight.forEach(function (element, idx) {
                        md.blendWeight[idx] = new render.number4();
                        md.blendWeight[idx].v0 = element.v0;
                        md.blendWeight[idx].v1 = element.v1;
                        md.blendWeight[idx].v2 = element.v2;
                        md.blendWeight[idx].v3 = element.v3;
                    });
                }
                if (target.trisindex) {
                    md.trisindex = [];
                    target.trisindex.forEach(function (element) {
                        md.trisindex.push(element);
                    });
                }
                return md;
            };
            return meshData;
        }());
        render.meshData = meshData;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var staticMeshRenderer = (function () {
            function staticMeshRenderer() {
                this.eboIndex = 0;
                this.drawMode = render.DrawModeEnum.EboTri;
                this.drawbegin = 0;
                this.drawcount = -1;
            }
            staticMeshRenderer.prototype.draw = function (webgl) {
                this.material.use(webgl);
                this.mesh.bind(webgl, this.material.program, this.eboIndex);
                if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, this.drawbegin, this.drawcount);
                }
            };
            return staticMeshRenderer;
        }());
        render.staticMeshRenderer = staticMeshRenderer;
        var batchRenderer = (function () {
            function batchRenderer() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            batchRenderer.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == render.DrawModeEnum.EboLine || drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            batchRenderer.prototype.begin = function (webgl, mat) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curmaterial = mat;
            };
            batchRenderer.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0, len = this.dataForVbo.length; i < len; ++i) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0, len = vbodata.length; i < len; ++i) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == render.DrawModeEnum.VboLine || this.drawMode == render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0, len = this.dataForEbo.length; i < len; ++i) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0, len = ebodata.length; i < len; ++i) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            batchRenderer.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexData(webgl, this.dataForVbo.slice(0, this.vboCount));
                if (this.eboCount > 0)
                    this.mesh.uploadIndexData(webgl, 0, this.dataForEbo.slice(0, this.eboCount));
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curmaterial.use(webgl);
                this.mesh.bind(webgl, this.curmaterial.program, (this.drawMode == render.DrawModeEnum.EboLine || this.drawMode == render.DrawModeEnum.EboTri) ? 0 : -1);
                if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            return batchRenderer;
        }());
        render.batchRenderer = batchRenderer;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var shaderUniform = (function () {
            function shaderUniform() {
            }
            shaderUniform.initApplyUnifmFunc = function () {
                var _this = this;
                this.applyuniformFunc[render.UniformTypeEnum.Float] = function (location, value) {
                    _this.webgl.uniform1f(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Floatv] = function (location, value) {
                    _this.webgl.uniform1fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4] = function (location, value) {
                    _this.webgl.uniform4f(location, value.x, value.y, value.z, value.w);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4v] = function (location, value) {
                    _this.webgl.uniform4fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4] = function (location, value) {
                    _this.webgl.uniformMatrix4fv(location, false, value.rawData);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4v] = function (location, value) {
                    _this.webgl.uniformMatrix4fv(location, false, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Texture] = function (location, value) {
                    var tex = value.glTexture.texture;
                    _this.webgl.activeTexture(render.webglkit.GetTextureNumber(_this.webgl, _this.texindex));
                    _this.webgl.bindTexture(_this.webgl.TEXTURE_2D, tex);
                    _this.webgl.uniform1i(location, _this.texindex);
                    _this.texindex++;
                };
                this.applyuniformFunc[render.UniformTypeEnum.CubeTexture] = function (location, value) {
                    var tex = value.glTexture.texture;
                    _this.webgl.activeTexture(render.webglkit.GetTextureNumber(_this.webgl, _this.texindex));
                    _this.webgl.bindTexture(_this.webgl.TEXTURE_CUBE_MAP, tex);
                    _this.webgl.uniform1i(location, _this.texindex);
                    _this.texindex++;
                };
            };
            shaderUniform.texindex = 0;
            shaderUniform.applyuniformFunc = {};
            return shaderUniform;
        }());
        render.shaderUniform = shaderUniform;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var UniformTypeEnum;
        (function (UniformTypeEnum) {
            UniformTypeEnum[UniformTypeEnum["Texture"] = 0] = "Texture";
            UniformTypeEnum[UniformTypeEnum["Float"] = 1] = "Float";
            UniformTypeEnum[UniformTypeEnum["Floatv"] = 2] = "Floatv";
            UniformTypeEnum[UniformTypeEnum["Float4"] = 3] = "Float4";
            UniformTypeEnum[UniformTypeEnum["Float4v"] = 4] = "Float4v";
            UniformTypeEnum[UniformTypeEnum["Float4x4"] = 5] = "Float4x4";
            UniformTypeEnum[UniformTypeEnum["Float4x4v"] = 6] = "Float4x4v";
            UniformTypeEnum[UniformTypeEnum["CubeTexture"] = 7] = "CubeTexture";
        })(UniformTypeEnum = render.UniformTypeEnum || (render.UniformTypeEnum = {}));
        var uniform = (function () {
            function uniform() {
            }
            return uniform;
        }());
        render.uniform = uniform;
        var ShaderTypeEnum;
        (function (ShaderTypeEnum) {
            ShaderTypeEnum[ShaderTypeEnum["VS"] = 0] = "VS";
            ShaderTypeEnum[ShaderTypeEnum["FS"] = 1] = "FS";
        })(ShaderTypeEnum = render.ShaderTypeEnum || (render.ShaderTypeEnum = {}));
        var glShader = (function () {
            function glShader(name, type, shader, code) {
                this.name = name;
                this.type = type;
                this.shader = shader;
            }
            return glShader;
        }());
        render.glShader = glShader;
        var glProgram = (function () {
            function glProgram(vs, fs, program) {
                this.posPos = -1;
                this.posNormal = -1;
                this.posTangent = -1;
                this.posColor = -1;
                this.posUV0 = -1;
                this.posUV2 = -1;
                this.posBlendIndex4 = -1;
                this.posBlendWeight4 = -1;
                this.posColorEx = -1;
                this.mapUniform = {};
                this.vs = vs;
                this.fs = fs;
                this.program = program;
            }
            glProgram.prototype.initAttribute = function (webgl) {
                this.posPos = webgl.getAttribLocation(this.program, "_glesVertex");
                this.posColor = webgl.getAttribLocation(this.program, "_glesColor");
                this.posUV0 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord0");
                this.posUV2 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord1");
                this.posNormal = webgl.getAttribLocation(this.program, "_glesNormal");
                this.posTangent = webgl.getAttribLocation(this.program, "_glesTangent");
                this.posBlendIndex4 = webgl.getAttribLocation(this.program, "_glesBlendIndex4");
                this.posBlendWeight4 = webgl.getAttribLocation(this.program, "_glesBlendWeight4");
                this.posColorEx = webgl.getAttribLocation(this.program, "_glesColorEx");
            };
            glProgram.prototype.use = function (webgl) {
                webgl.useProgram(this.program);
            };
            glProgram.prototype.initUniforms = function (webgl) {
                var numUniforms = webgl.getProgramParameter(this.program, webgl.ACTIVE_UNIFORMS);
                for (var i = 0; i < numUniforms; i++) {
                    var uniformInfo = webgl.getActiveUniform(this.program, i);
                    if (!uniformInfo)
                        break;
                    var name = uniformInfo.name;
                    if (name.substr(-3) === "[0]") {
                        name = name.substr(0, name.length - 3);
                    }
                    var location = webgl.getUniformLocation(this.program, uniformInfo.name);
                    var type = uniformInfo.type;
                    var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
                    var _uniform = new uniform();
                    _uniform.name = name;
                    _uniform.location = location;
                    this.mapUniform[name] = _uniform;
                    if (type === webgl.FLOAT && isArray) {
                        _uniform.type = UniformTypeEnum.Floatv;
                    }
                    else if (type === webgl.FLOAT) {
                        _uniform.type = UniformTypeEnum.Float;
                    }
                    else if (type === webgl.FLOAT_VEC4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4v;
                    }
                    else if (type === webgl.FLOAT_VEC4) {
                        _uniform.type = UniformTypeEnum.Float4;
                    }
                    else if (type === webgl.FLOAT_MAT4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4x4v;
                    }
                    else if (type === webgl.FLOAT_MAT4) {
                        _uniform.type = UniformTypeEnum.Float4x4;
                    }
                    else if (type === webgl.SAMPLER_2D) {
                        _uniform.type = UniformTypeEnum.Texture;
                    }
                    else if (type === webgl.SAMPLER_CUBE) {
                        _uniform.type = UniformTypeEnum.CubeTexture;
                    }
                    else {
                        console.log("Unifrom parse Erorr : not have this type!");
                    }
                }
            };
            return glProgram;
        }());
        render.glProgram = glProgram;
        var shaderPool = (function () {
            function shaderPool() {
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
                this.mapVSString = {};
                this.mapFSString = {};
            }
            shaderPool.prototype.disposeVS = function (webgl, id) {
                webgl.deleteShader(this.mapVS[id].shader);
            };
            shaderPool.prototype.disposeFS = function (webgl, id) {
                webgl.deleteShader(this.mapFS[id].shader);
            };
            shaderPool.prototype.disposeProgram = function (webgl, id) {
                webgl.deleteProgram(this.mapProgram[id].program);
            };
            shaderPool.prototype.disposeAll = function (webgl) {
                for (var key in this.mapVS) {
                    this.disposeVS(webgl, key);
                }
                for (var key in this.mapFS) {
                    this.disposeFS(webgl, key);
                }
                for (var key in this.mapProgram) {
                    this.disposeProgram(webgl, key);
                }
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
            };
            shaderPool.prototype.compileVS = function (webgl, name, code) {
                var vs = webgl.createShader(webgl.VERTEX_SHADER);
                webgl.shaderSource(vs, code);
                webgl.compileShader(vs);
                var r1 = webgl.getShaderParameter(vs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a vs:" + name + " error!!!" + webgl.getShaderInfoLog(vs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(vs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.VS, vs, code);
                this.mapVS[name] = s;
                return s;
            };
            shaderPool.prototype.compileFS = function (webgl, name, code) {
                var fs = webgl.createShader(webgl.FRAGMENT_SHADER);
                webgl.shaderSource(fs, code);
                webgl.compileShader(fs);
                var r1 = webgl.getShaderParameter(fs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a fs:" + name + " error!!!" + webgl.getShaderInfoLog(fs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(fs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.FS, fs, code);
                this.mapFS[name] = s;
                return s;
            };
            shaderPool.prototype.linkProgram = function (webgl, nameVS, nameFS) {
                var program = webgl.createProgram();
                webgl.attachShader(program, this.mapVS[nameVS].shader);
                webgl.attachShader(program, this.mapFS[nameFS].shader);
                webgl.linkProgram(program);
                var r3 = webgl.getProgramParameter(program, webgl.LINK_STATUS);
                if (r3 == false) {
                    alert("vs:" + nameVS + "   fs:" + nameFS + "a webgl program error:" + webgl.getProgramInfoLog(program));
                    webgl.deleteProgram(program);
                    return null;
                }
                var name = nameVS + "_" + nameFS;
                var glp = new glProgram(this.mapVS[nameVS], this.mapFS[nameFS], program);
                glp.initUniforms(webgl);
                glp.initAttribute(webgl);
                this.mapProgram[name] = glp;
                return glp;
            };
            shaderPool.prototype.linkProgrambyPassType = function (webgl, type, nameVS, nameFS) {
                var vsStr = this.mapVSString[nameVS];
                var fsStr = this.mapFSString[nameFS];
                if (type == "base") {
                }
                else if (type == "base_fog" || type == "fog") {
                    vsStr = "#define FOG \n" + vsStr;
                    fsStr = "#define FOG \n" + fsStr;
                }
                else if (type == "skin") {
                    vsStr = "#define SKIN \n" + vsStr;
                    fsStr = "#define SKIN \n" + fsStr;
                }
                else if (type == "skin_fog") {
                    vsStr = "#define SKIN \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define SKIN \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "lightmap") {
                    vsStr = "#define LIGHTMAP \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + fsStr;
                }
                else if (type == "lightmap_fog") {
                    vsStr = "#define LIGHTMAP \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "quad") {
                    vsStr = "#define QUAD \n" + vsStr;
                    fsStr = "#define QUAD \n" + fsStr;
                }
                this.compileVS(webgl, nameVS + type, vsStr);
                this.compileFS(webgl, nameFS + type, fsStr);
                var pro = this.linkProgram(webgl, nameVS + type, nameFS + type);
                return pro;
            };
            return shaderPool;
        }());
        render.shaderPool = shaderPool;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var TextureFormatEnum;
        (function (TextureFormatEnum) {
            TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
            TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
            TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
        })(TextureFormatEnum = render.TextureFormatEnum || (render.TextureFormatEnum = {}));
        var textureReader = (function () {
            function textureReader(webgl, texRGBA, width, height, gray) {
                if (gray === void 0) { gray = false; }
                this._gray = gray;
                this._width = width;
                this._height = height;
                this.webgl = webgl;
                this._data = new Uint8Array(this._width * this._height * 4);
                if (gray)
                    this._grayData = new Uint8Array(this._width * this._height);
                this.refresh(texRGBA);
            }
            Object.defineProperty(textureReader.prototype, "width", {
                get: function () { return this._width; },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(textureReader.prototype, "height", {
                get: function () { return this._height; },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(textureReader.prototype, "data", {
                get: function () {
                    if (this._gray) {
                        return this._grayData;
                    }
                    else {
                        return this._data;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(textureReader.prototype, "gray", {
                get: function () { return this._gray; },
                enumerable: true,
                configurable: true
            });
            textureReader.prototype.getPixel = function (u, v) {
                var x = (u * this._width) | 0;
                var y = (v * this._height) | 0;
                if (x < 0 || x >= this._width || y < 0 || y >= this._height)
                    return 0;
                if (this._gray) {
                    return this._grayData[y * this._width + x];
                }
                else {
                    var i = (y * this._width + x) * 4;
                    return new gd3d.math.color(this._data[i], this._data[i + 1], this._data[i + 2], this._data[i + 3]);
                }
            };
            textureReader.prototype.refresh = function (texRGBA) {
                if (!texRGBA) {
                    console.warn("texRGBA is null ");
                    return;
                }
                var fbo = this.webgl.createFramebuffer();
                var fbold = this.webgl.getParameter(this.webgl.FRAMEBUFFER_BINDING);
                this.webgl.bindFramebuffer(this.webgl.FRAMEBUFFER, fbo);
                this.webgl.framebufferTexture2D(this.webgl.FRAMEBUFFER, this.webgl.COLOR_ATTACHMENT0, this.webgl.TEXTURE_2D, texRGBA, 0);
                this._data[0] = 2;
                this.webgl.readPixels(0, 0, this._width, this._height, this.webgl.RGBA, this.webgl.UNSIGNED_BYTE, this._data);
                this.webgl.deleteFramebuffer(fbo);
                this.webgl.bindFramebuffer(this.webgl.FRAMEBUFFER, fbold);
                if (this._gray) {
                    for (var i = 0; i < this._width * this._height; i++) {
                        this._grayData[i] = this._data[i * 4];
                    }
                }
            };
            return textureReader;
        }());
        render.textureReader = textureReader;
        var glRenderTarget = (function () {
            function glRenderTarget(webgl, width, height, depth, stencil) {
                if (depth === void 0) { depth = false; }
                if (stencil === void 0) { stencil = false; }
                this.width = width;
                this.height = height;
                this.fbo = webgl.createFramebuffer();
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                if (depth || stencil) {
                    this.renderbuffer = webgl.createRenderbuffer();
                    webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                    if (depth && stencil) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else if (depth) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                }
                this.texture = webgl.createTexture();
                this.fbo["width"] = width;
                this.fbo["height"] = height;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            }
            glRenderTarget.prototype.use = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            };
            glRenderTarget.useNull = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            };
            glRenderTarget.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteFramebuffer(this.renderbuffer);
                    this.renderbuffer = null;
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glRenderTarget.prototype.caclByteLength = function () {
                return this.width * this.height * 4;
            };
            glRenderTarget.prototype.isFrameBuffer = function () {
                return true;
            };
            return glRenderTarget;
        }());
        render.glRenderTarget = glRenderTarget;
        var glTexture2D = (function () {
            function glTexture2D(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                this.linear = true;
                this.premultiply = true;
                this.repeat = true;
                this.mirroredU = true;
                this.mirroredV = true;
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.webgl = webgl;
                this.format = format;
                this.linear = linear;
                this.mipmap = mipmap;
                this.texture = webgl.createTexture();
                var extname = "WEBGL_compressed_texture_pvrtc";
                this.ext = this.getExt("WEBGL_compressed_texture_pvrtc");
            }
            glTexture2D.prototype.getExt = function (name) {
                return this.webgl.getExtension(name) || this.webgl.getExtension("MOZ_" + name) ||
                    this.webgl.getExtension("OP_" + name) || this.webgl.getExtension("WEBKIT_" + name) || null;
            };
            glTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = img.width;
                this.height = img.height;
                this.mipmap = mipmap;
                this.linear = linear;
                this.premultiply = premultiply;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, img);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            glTexture2D.prototype.uploadByteArray = function (mipmap, linear, width, height, data, repeat, mirroredU, mirroredV) {
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = width;
                this.height = height;
                this.mipmap = mipmap;
                this.linear = linear;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            glTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            glTexture2D.prototype.getReader = function (redOnly) {
                if (redOnly === void 0) { redOnly = false; }
                if (this.reader != null) {
                    if (this.reader.gray != redOnly)
                        throw new Error("get param diff with this.reader");
                    return this.reader;
                }
                if (this.format != TextureFormatEnum.RGBA)
                    throw new Error("only rgba texture can read");
                if (this.texture == null)
                    return null;
                if (this.reader == null)
                    this.reader = new textureReader(this.webgl, this.texture, this.width, this.height, redOnly);
                return this.reader;
            };
            glTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            glTexture2D.formGrayArray = function (webgl, array, width, height) {
                var mipmap = false;
                var linear = true;
                var t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(array.length * 4);
                for (var y = 0; y < width; y++) {
                    for (var x = 0; x < width; x++) {
                        var fi = y * 512 + x;
                        var i = y * width + x;
                        data[fi * 4] = array[i] * 255;
                        data[fi * 4 + 1] = array[i] * 255;
                        data[fi * 4 + 2] = array[i] * 255;
                        data[fi * 4 + 3] = 255;
                    }
                }
                t.uploadByteArray(mipmap, linear, 512, 512, data);
                return t;
            };
            glTexture2D.staticTexture = function (webgl, name) {
                var t = glTexture2D.mapTexture[name];
                if (t != undefined)
                    return t;
                var mipmap = false;
                var linear = true;
                t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(4);
                var width = 1;
                var height = 1;
                data[0] = 128;
                data[1] = 0;
                data[2] = 128;
                data[3] = 255;
                if (name == "gray") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 128;
                    data[3] = 255;
                }
                else if (name == "white") {
                    data[0] = 255;
                    data[1] = 255;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "black") {
                    data[0] = 0;
                    data[1] = 0;
                    data[2] = 0;
                    data[3] = 255;
                }
                else if (name == "normal") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "grid") {
                    width = 256;
                    height = 256;
                    data = new Uint8Array(width * width * 4);
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            var seek = (y * width + x) * 4;
                            if (((x - width * 0.5) * (y - height * 0.5)) > 0) {
                                data[seek] = 0;
                                data[seek + 1] = 0;
                                data[seek + 2] = 0;
                                data[seek + 3] = 255;
                            }
                            else {
                                data[seek] = 255;
                                data[seek + 1] = 255;
                                data[seek + 2] = 255;
                                data[seek + 3] = 255;
                            }
                        }
                    }
                }
                t.uploadByteArray(mipmap, linear, width, height, data);
                glTexture2D.mapTexture[name] = t;
                return t;
            };
            glTexture2D.mapTexture = {};
            return glTexture2D;
        }());
        render.glTexture2D = glTexture2D;
        var glTextureCube = (function () {
            function glTextureCube(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.linear = false;
                this.webgl = webgl;
                this.format = format;
                this.mipmap = mipmap;
                this.linear = linear;
                this.texture = webgl.createTexture();
            }
            glTextureCube.prototype.uploadImages = function (Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z) {
                var wrc = this.webgl;
                var textures = [Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z];
                var typeArr = [wrc.TEXTURE_CUBE_MAP_NEGATIVE_X, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Y, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Z, wrc.TEXTURE_CUBE_MAP_POSITIVE_X, wrc.TEXTURE_CUBE_MAP_POSITIVE_Y, wrc.TEXTURE_CUBE_MAP_POSITIVE_Z];
                for (var i = 0; i < typeArr.length; i++) {
                    var reader = textures[i].glTexture.getReader();
                    if (!reader) {
                        console.warn("getReader() fail : " + textures[i].getName());
                        return;
                    }
                    this.upload(reader.data, reader.width, reader.height, typeArr[i]);
                }
            };
            glTextureCube.prototype.upload = function (data, width, height, TEXTURE_CUBE_MAP_) {
                this.width = width;
                this.height = height;
                this.loaded = true;
                var gl = this.webgl;
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_CUBE_MAP, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                if (data instanceof HTMLImageElement) {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, data);
                }
                else {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                }
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var mipmap = this.mipmap;
                var linear = this.linear;
            };
            glTextureCube.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen * 6;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            glTextureCube.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glTextureCube.prototype.isFrameBuffer = function () {
                return false;
            };
            return glTextureCube;
        }());
        render.glTextureCube = glTextureCube;
        var WriteableTexture2D = (function () {
            function WriteableTexture2D(webgl, format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.premultiply = true;
                this.repeat = false;
                this.mirroredU = false;
                this.mirroredV = false;
                this.width = 0;
                this.height = 0;
                this.webgl = webgl;
                this.texture = webgl.createTexture();
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.format = format;
                this.formatGL = this.webgl.RGBA;
                if (format == TextureFormatEnum.RGB)
                    this.formatGL = this.webgl.RGB;
                else if (format == TextureFormatEnum.Gray)
                    this.formatGL = this.webgl.LUMINANCE;
                var data = null;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, this.formatGL, width, height, 0, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            }
            WriteableTexture2D.prototype.updateRect = function (data, x, y, width, height) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, width, height, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.updateRectImg = function (data, x, y) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            WriteableTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            WriteableTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                return len;
            };
            return WriteableTexture2D;
        }());
        render.WriteableTexture2D = WriteableTexture2D;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
//# sourceMappingURL=gd3d.js.map